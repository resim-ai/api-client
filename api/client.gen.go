// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.13.4 DO NOT EDIT.
package api

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	openapi_types "github.com/deepmap/oapi-codegen/pkg/types"
)

const (
	OAuthScopes = "OAuth.Scopes"
)

// Defines values for BatchStatus.
const (
	BatchStatusCANCELLED BatchStatus = "CANCELLED"
	BatchStatusFAILED    BatchStatus = "FAILED"
	BatchStatusRUNNING   BatchStatus = "RUNNING"
	BatchStatusSUBMITTED BatchStatus = "SUBMITTED"
	BatchStatusSUCCEEDED BatchStatus = "SUCCEEDED"
)

// Defines values for BranchType.
const (
	CHANGEREQUEST BranchType = "CHANGE_REQUEST"
	MAIN          BranchType = "MAIN"
	RELEASE       BranchType = "RELEASE"
)

// Defines values for JobStatus.
const (
	JobStatusCANCELLED JobStatus = "CANCELLED"
	JobStatusFAILED    JobStatus = "FAILED"
	JobStatusRUNNING   JobStatus = "RUNNING"
	JobStatusSUBMITTED JobStatus = "SUBMITTED"
	JobStatusSUCCEEDED JobStatus = "SUCCEEDED"
)

// Defines values for ObjectType.
const (
	TYPEDCURVESE3    ObjectType = "TYPE_DCURVE_SE3"
	TYPEFRAME        ObjectType = "TYPE_FRAME"
	TYPEFRAMEDVECTOR ObjectType = "TYPE_FRAMED_VECTOR"
	TYPESE3          ObjectType = "TYPE_SE3"
	TYPESO3          ObjectType = "TYPE_SO3"
	TYPETCURVESE3    ObjectType = "TYPE_TCURVE_SE3"
	TYPETRAJECTORY   ObjectType = "TYPE_TRAJECTORY"
)

// Batch defines model for batch.
type Batch struct {
	BatchID                      *BatchID           `json:"batchID,omitempty"`
	BuildID                      *BuildID           `json:"buildID,omitempty"`
	CreationTimestamp            *CreationTimestamp `json:"creationTimestamp,omitempty"`
	FriendlyName                 *FriendlyName      `json:"friendlyName,omitempty"`
	InstantiatedExperienceIDs    *[]ExperienceID    `json:"instantiatedExperienceIDs,omitempty"`
	InstantiatedExperienceTagIDs *[]ExperienceTagID `json:"instantiatedExperienceTagIDs,omitempty"`
	OrgID                        *OrgID             `json:"orgID,omitempty"`
	Status                       *BatchStatus       `json:"status,omitempty"`
	UserID                       *UserID            `json:"userID,omitempty"`
}

// BatchID defines model for batchID.
type BatchID = openapi_types.UUID

// BatchStatus defines model for batchStatus.
type BatchStatus string

// Branch defines model for branch.
type Branch struct {
	BranchID          *BranchID          `json:"branchID,omitempty"`
	BranchType        *BranchType        `json:"branchType,omitempty"`
	CreationTimestamp *CreationTimestamp `json:"creationTimestamp,omitempty"`
	Name              *string            `json:"name,omitempty"`
	OrgID             *OrgID             `json:"orgID,omitempty"`
	ProjectID         *ProjectID         `json:"projectID,omitempty"`
	UserID            *UserID            `json:"userID,omitempty"`
}

// BranchID defines model for branchID.
type BranchID = openapi_types.UUID

// BranchType defines model for branchType.
type BranchType string

// Build defines model for build.
type Build struct {
	BranchID          *BranchID          `json:"branchID,omitempty"`
	BuildID           *BuildID           `json:"buildID,omitempty"`
	CreationTimestamp *CreationTimestamp `json:"creationTimestamp,omitempty"`
	Description       *BuildDescription  `json:"description,omitempty"`
	ImageName         *BuildImageName    `json:"imageName,omitempty"`
	OrgID             *OrgID             `json:"orgID,omitempty"`
	UserID            *UserID            `json:"userID,omitempty"`
	Version           *BuildVersion      `json:"version,omitempty"`
}

// BuildDescription defines model for buildDescription.
type BuildDescription = string

// BuildID defines model for buildID.
type BuildID = openapi_types.UUID

// BuildImageName defines model for buildImageName.
type BuildImageName = string

// BuildVersion defines model for buildVersion.
type BuildVersion = string

// Checksum defines model for checksum.
type Checksum = string

// CreationTimestamp defines model for creationTimestamp.
type CreationTimestamp = time.Time

// Experience defines model for experience.
type Experience struct {
	CreationTimestamp *CreationTimestamp `json:"creationTimestamp,omitempty"`
	Description       *string            `json:"description,omitempty"`
	ExperienceID      *ExperienceID      `json:"experienceID,omitempty"`
	Location          *string            `json:"location,omitempty"`
	Name              *string            `json:"name,omitempty"`
	OrgID             *OrgID             `json:"orgID,omitempty"`
	UserID            *UserID            `json:"userID,omitempty"`
}

// ExperienceID defines model for experienceID.
type ExperienceID = openapi_types.UUID

// ExperienceTag defines model for experienceTag.
type ExperienceTag struct {
	CreationTimestamp *CreationTimestamp `json:"creationTimestamp,omitempty"`
	Description       *string            `json:"description,omitempty"`
	ExperienceTagID   *ExperienceTagID   `json:"experienceTagID,omitempty"`
	Name              *string            `json:"name,omitempty"`
	OrgID             *OrgID             `json:"orgID,omitempty"`
	UserID            *UserID            `json:"userID,omitempty"`
}

// ExperienceTagID defines model for experienceTagID.
type ExperienceTagID = openapi_types.UUID

// FileName defines model for fileName.
type FileName = string

// FileSize defines model for fileSize.
type FileSize = int64

// FriendlyName defines model for friendlyName.
type FriendlyName = string

// Job defines model for job.
type Job struct {
	BuildID        *BuildID      `json:"buildID,omitempty"`
	ExperienceID   *ExperienceID `json:"experienceID,omitempty"`
	JobID          *JobID        `json:"jobID,omitempty"`
	JobStatus      *JobStatus    `json:"jobStatus,omitempty"`
	McapURL        *McapURL      `json:"mcapURL,omitempty"`
	OrgID          *OrgID        `json:"orgID,omitempty"`
	OutputLocation *string       `json:"outputLocation,omitempty"`
	UserID         *UserID       `json:"userID,omitempty"`
}

// JobID defines model for jobID.
type JobID = openapi_types.UUID

// JobStatus defines model for jobStatus.
type JobStatus string

// LineNumber defines model for lineNumber.
type LineNumber = int32

// Log defines model for log.
type Log struct {
	Checksum          *Checksum          `json:"checksum,omitempty"`
	CreationTimestamp *CreationTimestamp `json:"creationTimestamp,omitempty"`
	FileName          *FileName          `json:"fileName,omitempty"`
	FileSize          *FileSize          `json:"fileSize,omitempty"`
	JobID             *JobID             `json:"jobID,omitempty"`
	Location          *LogLocation       `json:"location,omitempty"`
	LogID             *LogID             `json:"logID,omitempty"`
	LogOutputLocation *string            `json:"logOutputLocation,omitempty"`
	OrgID             *OrgID             `json:"orgID,omitempty"`
	UserID            *UserID            `json:"userID,omitempty"`
}

// LogID defines model for logID.
type LogID = openapi_types.UUID

// LogLocation defines model for logLocation.
type LogLocation = string

// McapURL defines model for mcapURL.
type McapURL = string

// ObjectCount defines model for objectCount.
type ObjectCount = int32

// ObjectName defines model for objectName.
type ObjectName = string

// ObjectType defines model for objectType.
type ObjectType string

// OrgID defines model for orgID.
type OrgID = string

// Project defines model for project.
type Project struct {
	CreationTimestamp *CreationTimestamp `json:"creationTimestamp,omitempty"`
	Description       *string            `json:"description,omitempty"`
	Name              *string            `json:"name,omitempty"`
	OrgID             *OrgID             `json:"orgID,omitempty"`
	ProjectID         *ProjectID         `json:"projectID,omitempty"`
	UserID            *UserID            `json:"userID,omitempty"`
}

// ProjectID defines model for projectID.
type ProjectID = openapi_types.UUID

// UpdateMask defines model for updateMask.
type UpdateMask = []string

// UserID defines model for userID.
type UserID = string

// ViewMetadata defines model for viewMetadata.
type ViewMetadata struct {
	FileName   *FileName   `json:"fileName,omitempty"`
	LineNumber *LineNumber `json:"lineNumber,omitempty"`
	ObjectName *ObjectName `json:"objectName,omitempty"`
	ObjectType *ObjectType `json:"objectType,omitempty"`
}

// ViewObject defines model for viewObject.
type ViewObject struct {
	FriendlyName  *FriendlyName  `json:"friendlyName,omitempty"`
	McapURL       *string        `json:"mcapURL,omitempty"`
	ObjectCount   *ObjectCount   `json:"objectCount,omitempty"`
	OrgID         *OrgID         `json:"orgID,omitempty"`
	UserID        *UserID        `json:"userID,omitempty"`
	ViewSessionID *ViewSessionID `json:"viewSessionID,omitempty"`
	ViewTimestamp *ViewTimestamp `json:"viewTimestamp,omitempty"`
	ViewURL       *string        `json:"viewURL,omitempty"`
}

// ViewSessionID defines model for viewSessionID.
type ViewSessionID = openapi_types.UUID

// ViewTimestamp defines model for viewTimestamp.
type ViewTimestamp = time.Time

// ViewUpdateID defines model for viewUpdateID.
type ViewUpdateID = int

// OrderBy defines model for orderBy.
type OrderBy = string

// PageSize defines model for pageSize.
type PageSize = int

// PageToken defines model for pageToken.
type PageToken = string

// ListBatchesParams defines parameters for ListBatches.
type ListBatchesParams struct {
	PageSize  *PageSize  `form:"pageSize,omitempty" json:"pageSize,omitempty"`
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`
	OrderBy   *OrderBy   `form:"orderBy,omitempty" json:"orderBy,omitempty"`
}

// CreateBatchJSONBody defines parameters for CreateBatch.
type CreateBatchJSONBody struct {
	BuildID          *BuildID           `json:"buildID,omitempty"`
	ExperienceIDs    *[]ExperienceID    `json:"experienceIDs,omitempty"`
	ExperienceTagIDs *[]ExperienceTagID `json:"experienceTagIDs,omitempty"`
}

// ListJobsParams defines parameters for ListJobs.
type ListJobsParams struct {
	PageSize  *PageSize  `form:"pageSize,omitempty" json:"pageSize,omitempty"`
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// ListLogsForJobParams defines parameters for ListLogsForJob.
type ListLogsForJobParams struct {
	PageSize  *PageSize  `form:"pageSize,omitempty" json:"pageSize,omitempty"`
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// ListBuildsParams defines parameters for ListBuilds.
type ListBuildsParams struct {
	PageSize  *PageSize  `form:"pageSize,omitempty" json:"pageSize,omitempty"`
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`
	OrderBy   *OrderBy   `form:"orderBy,omitempty" json:"orderBy,omitempty"`
}

// ListExperienceTagsParams defines parameters for ListExperienceTags.
type ListExperienceTagsParams struct {
	PageSize  *PageSize  `form:"pageSize,omitempty" json:"pageSize,omitempty"`
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`
	OrderBy   *OrderBy   `form:"orderBy,omitempty" json:"orderBy,omitempty"`
}

// UpdateExperienceTagJSONBody defines parameters for UpdateExperienceTag.
type UpdateExperienceTagJSONBody struct {
	ExperienceTag *ExperienceTag `json:"experienceTag,omitempty"`
	UpdateMask    *UpdateMask    `json:"updateMask,omitempty"`
}

// ListExperiencesWithExperienceTagParams defines parameters for ListExperiencesWithExperienceTag.
type ListExperiencesWithExperienceTagParams struct {
	PageSize  *PageSize  `form:"pageSize,omitempty" json:"pageSize,omitempty"`
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// ListExperiencesParams defines parameters for ListExperiences.
type ListExperiencesParams struct {
	PageSize  *PageSize  `form:"pageSize,omitempty" json:"pageSize,omitempty"`
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`
	OrderBy   *OrderBy   `form:"orderBy,omitempty" json:"orderBy,omitempty"`
}

// UpdateExperienceJSONBody defines parameters for UpdateExperience.
type UpdateExperienceJSONBody struct {
	Experience *Experience `json:"experience,omitempty"`
	UpdateMask *UpdateMask `json:"updateMask,omitempty"`
}

// ListExperienceTagsForExperienceParams defines parameters for ListExperienceTagsForExperience.
type ListExperienceTagsForExperienceParams struct {
	PageSize  *PageSize  `form:"pageSize,omitempty" json:"pageSize,omitempty"`
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// ListProjectsParams defines parameters for ListProjects.
type ListProjectsParams struct {
	PageSize  *PageSize  `form:"pageSize,omitempty" json:"pageSize,omitempty"`
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`
	OrderBy   *OrderBy   `form:"orderBy,omitempty" json:"orderBy,omitempty"`
}

// UpdateProjectJSONBody defines parameters for UpdateProject.
type UpdateProjectJSONBody struct {
	Project    *Project    `json:"project,omitempty"`
	UpdateMask *UpdateMask `json:"updateMask,omitempty"`
}

// ListBranchesForProjectParams defines parameters for ListBranchesForProject.
type ListBranchesForProjectParams struct {
	PageSize  *PageSize  `form:"pageSize,omitempty" json:"pageSize,omitempty"`
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`
	OrderBy   *OrderBy   `form:"orderBy,omitempty" json:"orderBy,omitempty"`
}

// ListBuildsForBranchParams defines parameters for ListBuildsForBranch.
type ListBuildsForBranchParams struct {
	PageSize  *PageSize  `form:"pageSize,omitempty" json:"pageSize,omitempty"`
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`
	OrderBy   *OrderBy   `form:"orderBy,omitempty" json:"orderBy,omitempty"`
}

// ListBatchesForBuildParams defines parameters for ListBatchesForBuild.
type ListBatchesForBuildParams struct {
	PageSize  *PageSize  `form:"pageSize,omitempty" json:"pageSize,omitempty"`
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`
	OrderBy   *OrderBy   `form:"orderBy,omitempty" json:"orderBy,omitempty"`
}

// DestroySandboxJSONBody defines parameters for DestroySandbox.
type DestroySandboxJSONBody struct {
	OrgID  *string `json:"orgID,omitempty"`
	UserID *string `json:"userID,omitempty"`
}

// SetupSandboxJSONBody defines parameters for SetupSandbox.
type SetupSandboxJSONBody struct {
	OrgID  *string `json:"orgID,omitempty"`
	UserID *string `json:"userID,omitempty"`
}

// ListViewSessionsParams defines parameters for ListViewSessions.
type ListViewSessionsParams struct {
	PageSize  *PageSize  `form:"pageSize,omitempty" json:"pageSize,omitempty"`
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`
	OrderBy   *OrderBy   `form:"orderBy,omitempty" json:"orderBy,omitempty"`
}

// CreateBatchJSONRequestBody defines body for CreateBatch for application/json ContentType.
type CreateBatchJSONRequestBody CreateBatchJSONBody

// CreateLogJSONRequestBody defines body for CreateLog for application/json ContentType.
type CreateLogJSONRequestBody = Log

// CreateExperienceTagJSONRequestBody defines body for CreateExperienceTag for application/json ContentType.
type CreateExperienceTagJSONRequestBody = ExperienceTag

// UpdateExperienceTagJSONRequestBody defines body for UpdateExperienceTag for application/json ContentType.
type UpdateExperienceTagJSONRequestBody UpdateExperienceTagJSONBody

// CreateExperienceJSONRequestBody defines body for CreateExperience for application/json ContentType.
type CreateExperienceJSONRequestBody = Experience

// UpdateExperienceJSONRequestBody defines body for UpdateExperience for application/json ContentType.
type UpdateExperienceJSONRequestBody UpdateExperienceJSONBody

// CreateProjectJSONRequestBody defines body for CreateProject for application/json ContentType.
type CreateProjectJSONRequestBody = Project

// UpdateProjectJSONRequestBody defines body for UpdateProject for application/json ContentType.
type UpdateProjectJSONRequestBody UpdateProjectJSONBody

// CreateBranchForProjectJSONRequestBody defines body for CreateBranchForProject for application/json ContentType.
type CreateBranchForProjectJSONRequestBody = Branch

// CreateBuildForBranchJSONRequestBody defines body for CreateBuildForBranch for application/json ContentType.
type CreateBuildForBranchJSONRequestBody = Build

// DestroySandboxJSONRequestBody defines body for DestroySandbox for application/json ContentType.
type DestroySandboxJSONRequestBody DestroySandboxJSONBody

// SetupSandboxJSONRequestBody defines body for SetupSandbox for application/json ContentType.
type SetupSandboxJSONRequestBody SetupSandboxJSONBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListBatches request
	ListBatches(ctx context.Context, params *ListBatchesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBatchWithBody request with any body
	CreateBatchWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateBatch(ctx context.Context, body CreateBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBatch request
	GetBatch(ctx context.Context, batchID BatchID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CancelBatch request
	CancelBatch(ctx context.Context, batchID BatchID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListJobs request
	ListJobs(ctx context.Context, batchID BatchID, params *ListJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetJob request
	GetJob(ctx context.Context, batchID BatchID, jobID JobID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListLogsForJob request
	ListLogsForJob(ctx context.Context, batchID BatchID, jobID JobID, params *ListLogsForJobParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateLogWithBody request with any body
	CreateLogWithBody(ctx context.Context, batchID BatchID, jobID JobID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateLog(ctx context.Context, batchID BatchID, jobID JobID, body CreateLogJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteLog request
	DeleteLog(ctx context.Context, batchID BatchID, jobID JobID, logID LogID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLog request
	GetLog(ctx context.Context, batchID BatchID, jobID JobID, logID LogID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetJobMetrics request
	GetJobMetrics(ctx context.Context, batchID BatchID, jobID JobID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBuilds request
	ListBuilds(ctx context.Context, params *ListBuildsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBuild request
	GetBuild(ctx context.Context, buildID BuildID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListExperienceTags request
	ListExperienceTags(ctx context.Context, params *ListExperienceTagsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateExperienceTagWithBody request with any body
	CreateExperienceTagWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateExperienceTag(ctx context.Context, body CreateExperienceTagJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteExperienceTag request
	DeleteExperienceTag(ctx context.Context, experienceTagID ExperienceTagID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetExperienceTag request
	GetExperienceTag(ctx context.Context, experienceTagID ExperienceTagID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateExperienceTagWithBody request with any body
	UpdateExperienceTagWithBody(ctx context.Context, experienceTagID ExperienceTagID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateExperienceTag(ctx context.Context, experienceTagID ExperienceTagID, body UpdateExperienceTagJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListExperiencesWithExperienceTag request
	ListExperiencesWithExperienceTag(ctx context.Context, experienceTagID ExperienceTagID, params *ListExperiencesWithExperienceTagParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveExperienceTagFromExperience request
	RemoveExperienceTagFromExperience(ctx context.Context, experienceTagID ExperienceTagID, experienceID ExperienceID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddExperienceTagToExperience request
	AddExperienceTagToExperience(ctx context.Context, experienceTagID ExperienceTagID, experienceID ExperienceID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListExperiences request
	ListExperiences(ctx context.Context, params *ListExperiencesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateExperienceWithBody request with any body
	CreateExperienceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateExperience(ctx context.Context, body CreateExperienceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteExperience request
	DeleteExperience(ctx context.Context, experienceID ExperienceID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetExperience request
	GetExperience(ctx context.Context, experienceID ExperienceID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateExperienceWithBody request with any body
	UpdateExperienceWithBody(ctx context.Context, experienceID ExperienceID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateExperience(ctx context.Context, experienceID ExperienceID, body UpdateExperienceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListExperienceTagsForExperience request
	ListExperienceTagsForExperience(ctx context.Context, experienceID ExperienceID, params *ListExperienceTagsForExperienceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Health request
	Health(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListProjects request
	ListProjects(ctx context.Context, params *ListProjectsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateProjectWithBody request with any body
	CreateProjectWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateProject(ctx context.Context, body CreateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteProject request
	DeleteProject(ctx context.Context, projectID ProjectID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProject request
	GetProject(ctx context.Context, projectID ProjectID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateProjectWithBody request with any body
	UpdateProjectWithBody(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateProject(ctx context.Context, projectID ProjectID, body UpdateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBranchesForProject request
	ListBranchesForProject(ctx context.Context, projectID ProjectID, params *ListBranchesForProjectParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBranchForProjectWithBody request with any body
	CreateBranchForProjectWithBody(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateBranchForProject(ctx context.Context, projectID ProjectID, body CreateBranchForProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteBranchForProject request
	DeleteBranchForProject(ctx context.Context, projectID ProjectID, branchID BranchID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBranchForProject request
	GetBranchForProject(ctx context.Context, projectID ProjectID, branchID BranchID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBuildsForBranch request
	ListBuildsForBranch(ctx context.Context, projectID ProjectID, branchID BranchID, params *ListBuildsForBranchParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBuildForBranchWithBody request with any body
	CreateBuildForBranchWithBody(ctx context.Context, projectID ProjectID, branchID BranchID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateBuildForBranch(ctx context.Context, projectID ProjectID, branchID BranchID, body CreateBuildForBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteBuildForBranch request
	DeleteBuildForBranch(ctx context.Context, projectID ProjectID, branchID BranchID, buildID BuildID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBuildForBranch request
	GetBuildForBranch(ctx context.Context, projectID ProjectID, branchID BranchID, buildID BuildID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBatchesForBuild request
	ListBatchesForBuild(ctx context.Context, projectID ProjectID, branchID BranchID, buildID BuildID, params *ListBatchesForBuildParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DestroySandboxWithBody request with any body
	DestroySandboxWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DestroySandbox(ctx context.Context, body DestroySandboxJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetupSandboxWithBody request with any body
	SetupSandboxWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetupSandbox(ctx context.Context, body SetupSandboxJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListViewSessions request
	ListViewSessions(ctx context.Context, params *ListViewSessionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateViewSession request
	CreateViewSession(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetViewSession request
	GetViewSession(ctx context.Context, viewSessionID ViewSessionID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateViewUpdateWithBody request with any body
	CreateViewUpdateWithBody(ctx context.Context, viewSessionID ViewSessionID, viewUpdateID ViewUpdateID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ListBatches(ctx context.Context, params *ListBatchesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBatchesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBatchWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBatchRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBatch(ctx context.Context, body CreateBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBatchRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBatch(ctx context.Context, batchID BatchID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBatchRequest(c.Server, batchID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelBatch(ctx context.Context, batchID BatchID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelBatchRequest(c.Server, batchID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListJobs(ctx context.Context, batchID BatchID, params *ListJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListJobsRequest(c.Server, batchID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetJob(ctx context.Context, batchID BatchID, jobID JobID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetJobRequest(c.Server, batchID, jobID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListLogsForJob(ctx context.Context, batchID BatchID, jobID JobID, params *ListLogsForJobParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListLogsForJobRequest(c.Server, batchID, jobID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLogWithBody(ctx context.Context, batchID BatchID, jobID JobID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLogRequestWithBody(c.Server, batchID, jobID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLog(ctx context.Context, batchID BatchID, jobID JobID, body CreateLogJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLogRequest(c.Server, batchID, jobID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteLog(ctx context.Context, batchID BatchID, jobID JobID, logID LogID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteLogRequest(c.Server, batchID, jobID, logID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLog(ctx context.Context, batchID BatchID, jobID JobID, logID LogID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLogRequest(c.Server, batchID, jobID, logID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetJobMetrics(ctx context.Context, batchID BatchID, jobID JobID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetJobMetricsRequest(c.Server, batchID, jobID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBuilds(ctx context.Context, params *ListBuildsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBuildsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBuild(ctx context.Context, buildID BuildID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBuildRequest(c.Server, buildID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListExperienceTags(ctx context.Context, params *ListExperienceTagsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListExperienceTagsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateExperienceTagWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateExperienceTagRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateExperienceTag(ctx context.Context, body CreateExperienceTagJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateExperienceTagRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteExperienceTag(ctx context.Context, experienceTagID ExperienceTagID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteExperienceTagRequest(c.Server, experienceTagID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetExperienceTag(ctx context.Context, experienceTagID ExperienceTagID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetExperienceTagRequest(c.Server, experienceTagID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateExperienceTagWithBody(ctx context.Context, experienceTagID ExperienceTagID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateExperienceTagRequestWithBody(c.Server, experienceTagID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateExperienceTag(ctx context.Context, experienceTagID ExperienceTagID, body UpdateExperienceTagJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateExperienceTagRequest(c.Server, experienceTagID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListExperiencesWithExperienceTag(ctx context.Context, experienceTagID ExperienceTagID, params *ListExperiencesWithExperienceTagParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListExperiencesWithExperienceTagRequest(c.Server, experienceTagID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveExperienceTagFromExperience(ctx context.Context, experienceTagID ExperienceTagID, experienceID ExperienceID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveExperienceTagFromExperienceRequest(c.Server, experienceTagID, experienceID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddExperienceTagToExperience(ctx context.Context, experienceTagID ExperienceTagID, experienceID ExperienceID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddExperienceTagToExperienceRequest(c.Server, experienceTagID, experienceID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListExperiences(ctx context.Context, params *ListExperiencesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListExperiencesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateExperienceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateExperienceRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateExperience(ctx context.Context, body CreateExperienceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateExperienceRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteExperience(ctx context.Context, experienceID ExperienceID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteExperienceRequest(c.Server, experienceID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetExperience(ctx context.Context, experienceID ExperienceID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetExperienceRequest(c.Server, experienceID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateExperienceWithBody(ctx context.Context, experienceID ExperienceID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateExperienceRequestWithBody(c.Server, experienceID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateExperience(ctx context.Context, experienceID ExperienceID, body UpdateExperienceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateExperienceRequest(c.Server, experienceID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListExperienceTagsForExperience(ctx context.Context, experienceID ExperienceID, params *ListExperienceTagsForExperienceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListExperienceTagsForExperienceRequest(c.Server, experienceID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Health(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHealthRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListProjects(ctx context.Context, params *ListProjectsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListProjectsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProjectWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProjectRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProject(ctx context.Context, body CreateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProjectRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProject(ctx context.Context, projectID ProjectID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteProjectRequest(c.Server, projectID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProject(ctx context.Context, projectID ProjectID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProjectRequest(c.Server, projectID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProjectWithBody(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProjectRequestWithBody(c.Server, projectID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProject(ctx context.Context, projectID ProjectID, body UpdateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProjectRequest(c.Server, projectID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBranchesForProject(ctx context.Context, projectID ProjectID, params *ListBranchesForProjectParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBranchesForProjectRequest(c.Server, projectID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBranchForProjectWithBody(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBranchForProjectRequestWithBody(c.Server, projectID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBranchForProject(ctx context.Context, projectID ProjectID, body CreateBranchForProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBranchForProjectRequest(c.Server, projectID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteBranchForProject(ctx context.Context, projectID ProjectID, branchID BranchID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteBranchForProjectRequest(c.Server, projectID, branchID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBranchForProject(ctx context.Context, projectID ProjectID, branchID BranchID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBranchForProjectRequest(c.Server, projectID, branchID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBuildsForBranch(ctx context.Context, projectID ProjectID, branchID BranchID, params *ListBuildsForBranchParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBuildsForBranchRequest(c.Server, projectID, branchID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBuildForBranchWithBody(ctx context.Context, projectID ProjectID, branchID BranchID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBuildForBranchRequestWithBody(c.Server, projectID, branchID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBuildForBranch(ctx context.Context, projectID ProjectID, branchID BranchID, body CreateBuildForBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBuildForBranchRequest(c.Server, projectID, branchID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteBuildForBranch(ctx context.Context, projectID ProjectID, branchID BranchID, buildID BuildID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteBuildForBranchRequest(c.Server, projectID, branchID, buildID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBuildForBranch(ctx context.Context, projectID ProjectID, branchID BranchID, buildID BuildID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBuildForBranchRequest(c.Server, projectID, branchID, buildID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBatchesForBuild(ctx context.Context, projectID ProjectID, branchID BranchID, buildID BuildID, params *ListBatchesForBuildParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBatchesForBuildRequest(c.Server, projectID, branchID, buildID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DestroySandboxWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDestroySandboxRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DestroySandbox(ctx context.Context, body DestroySandboxJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDestroySandboxRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetupSandboxWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetupSandboxRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetupSandbox(ctx context.Context, body SetupSandboxJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetupSandboxRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListViewSessions(ctx context.Context, params *ListViewSessionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListViewSessionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateViewSession(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateViewSessionRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetViewSession(ctx context.Context, viewSessionID ViewSessionID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetViewSessionRequest(c.Server, viewSessionID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateViewUpdateWithBody(ctx context.Context, viewSessionID ViewSessionID, viewUpdateID ViewUpdateID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateViewUpdateRequestWithBody(c.Server, viewSessionID, viewUpdateID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewListBatchesRequest generates requests for ListBatches
func NewListBatchesRequest(server string, params *ListBatchesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/batches")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateBatchRequest calls the generic CreateBatch builder with application/json body
func NewCreateBatchRequest(server string, body CreateBatchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateBatchRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateBatchRequestWithBody generates requests for CreateBatch with any type of body
func NewCreateBatchRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/batches")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetBatchRequest generates requests for GetBatch
func NewGetBatchRequest(server string, batchID BatchID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "batchID", runtime.ParamLocationPath, batchID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/batches/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCancelBatchRequest generates requests for CancelBatch
func NewCancelBatchRequest(server string, batchID BatchID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "batchID", runtime.ParamLocationPath, batchID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/batches/%s/:cancel", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListJobsRequest generates requests for ListJobs
func NewListJobsRequest(server string, batchID BatchID, params *ListJobsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "batchID", runtime.ParamLocationPath, batchID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/batches/%s/jobs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetJobRequest generates requests for GetJob
func NewGetJobRequest(server string, batchID BatchID, jobID JobID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "batchID", runtime.ParamLocationPath, batchID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "jobID", runtime.ParamLocationPath, jobID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/batches/%s/jobs/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListLogsForJobRequest generates requests for ListLogsForJob
func NewListLogsForJobRequest(server string, batchID BatchID, jobID JobID, params *ListLogsForJobParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "batchID", runtime.ParamLocationPath, batchID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "jobID", runtime.ParamLocationPath, jobID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/batches/%s/jobs/%s/logs", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateLogRequest calls the generic CreateLog builder with application/json body
func NewCreateLogRequest(server string, batchID BatchID, jobID JobID, body CreateLogJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateLogRequestWithBody(server, batchID, jobID, "application/json", bodyReader)
}

// NewCreateLogRequestWithBody generates requests for CreateLog with any type of body
func NewCreateLogRequestWithBody(server string, batchID BatchID, jobID JobID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "batchID", runtime.ParamLocationPath, batchID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "jobID", runtime.ParamLocationPath, jobID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/batches/%s/jobs/%s/logs", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteLogRequest generates requests for DeleteLog
func NewDeleteLogRequest(server string, batchID BatchID, jobID JobID, logID LogID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "batchID", runtime.ParamLocationPath, batchID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "jobID", runtime.ParamLocationPath, jobID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "logID", runtime.ParamLocationPath, logID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/batches/%s/jobs/%s/logs/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLogRequest generates requests for GetLog
func NewGetLogRequest(server string, batchID BatchID, jobID JobID, logID LogID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "batchID", runtime.ParamLocationPath, batchID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "jobID", runtime.ParamLocationPath, jobID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "logID", runtime.ParamLocationPath, logID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/batches/%s/jobs/%s/logs/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetJobMetricsRequest generates requests for GetJobMetrics
func NewGetJobMetricsRequest(server string, batchID BatchID, jobID JobID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "batchID", runtime.ParamLocationPath, batchID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "jobID", runtime.ParamLocationPath, jobID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/batches/%s/jobs/%s/metrics", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListBuildsRequest generates requests for ListBuilds
func NewListBuildsRequest(server string, params *ListBuildsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/builds")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBuildRequest generates requests for GetBuild
func NewGetBuildRequest(server string, buildID BuildID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "buildID", runtime.ParamLocationPath, buildID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/builds/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListExperienceTagsRequest generates requests for ListExperienceTags
func NewListExperienceTagsRequest(server string, params *ListExperienceTagsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/experienceTags")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateExperienceTagRequest calls the generic CreateExperienceTag builder with application/json body
func NewCreateExperienceTagRequest(server string, body CreateExperienceTagJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateExperienceTagRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateExperienceTagRequestWithBody generates requests for CreateExperienceTag with any type of body
func NewCreateExperienceTagRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/experienceTags")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteExperienceTagRequest generates requests for DeleteExperienceTag
func NewDeleteExperienceTagRequest(server string, experienceTagID ExperienceTagID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "experienceTagID", runtime.ParamLocationPath, experienceTagID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/experienceTags/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetExperienceTagRequest generates requests for GetExperienceTag
func NewGetExperienceTagRequest(server string, experienceTagID ExperienceTagID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "experienceTagID", runtime.ParamLocationPath, experienceTagID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/experienceTags/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateExperienceTagRequest calls the generic UpdateExperienceTag builder with application/json body
func NewUpdateExperienceTagRequest(server string, experienceTagID ExperienceTagID, body UpdateExperienceTagJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateExperienceTagRequestWithBody(server, experienceTagID, "application/json", bodyReader)
}

// NewUpdateExperienceTagRequestWithBody generates requests for UpdateExperienceTag with any type of body
func NewUpdateExperienceTagRequestWithBody(server string, experienceTagID ExperienceTagID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "experienceTagID", runtime.ParamLocationPath, experienceTagID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/experienceTags/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListExperiencesWithExperienceTagRequest generates requests for ListExperiencesWithExperienceTag
func NewListExperiencesWithExperienceTagRequest(server string, experienceTagID ExperienceTagID, params *ListExperiencesWithExperienceTagParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "experienceTagID", runtime.ParamLocationPath, experienceTagID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/experienceTags/%s/experiences", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveExperienceTagFromExperienceRequest generates requests for RemoveExperienceTagFromExperience
func NewRemoveExperienceTagFromExperienceRequest(server string, experienceTagID ExperienceTagID, experienceID ExperienceID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "experienceTagID", runtime.ParamLocationPath, experienceTagID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "experienceID", runtime.ParamLocationPath, experienceID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/experienceTags/%s/experiences/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddExperienceTagToExperienceRequest generates requests for AddExperienceTagToExperience
func NewAddExperienceTagToExperienceRequest(server string, experienceTagID ExperienceTagID, experienceID ExperienceID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "experienceTagID", runtime.ParamLocationPath, experienceTagID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "experienceID", runtime.ParamLocationPath, experienceID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/experienceTags/%s/experiences/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListExperiencesRequest generates requests for ListExperiences
func NewListExperiencesRequest(server string, params *ListExperiencesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/experiences")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateExperienceRequest calls the generic CreateExperience builder with application/json body
func NewCreateExperienceRequest(server string, body CreateExperienceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateExperienceRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateExperienceRequestWithBody generates requests for CreateExperience with any type of body
func NewCreateExperienceRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/experiences")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteExperienceRequest generates requests for DeleteExperience
func NewDeleteExperienceRequest(server string, experienceID ExperienceID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "experienceID", runtime.ParamLocationPath, experienceID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/experiences/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetExperienceRequest generates requests for GetExperience
func NewGetExperienceRequest(server string, experienceID ExperienceID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "experienceID", runtime.ParamLocationPath, experienceID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/experiences/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateExperienceRequest calls the generic UpdateExperience builder with application/json body
func NewUpdateExperienceRequest(server string, experienceID ExperienceID, body UpdateExperienceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateExperienceRequestWithBody(server, experienceID, "application/json", bodyReader)
}

// NewUpdateExperienceRequestWithBody generates requests for UpdateExperience with any type of body
func NewUpdateExperienceRequestWithBody(server string, experienceID ExperienceID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "experienceID", runtime.ParamLocationPath, experienceID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/experiences/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListExperienceTagsForExperienceRequest generates requests for ListExperienceTagsForExperience
func NewListExperienceTagsForExperienceRequest(server string, experienceID ExperienceID, params *ListExperienceTagsForExperienceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "experienceID", runtime.ParamLocationPath, experienceID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/experiences/%s/experienceTags", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewHealthRequest generates requests for Health
func NewHealthRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/health")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListProjectsRequest generates requests for ListProjects
func NewListProjectsRequest(server string, params *ListProjectsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateProjectRequest calls the generic CreateProject builder with application/json body
func NewCreateProjectRequest(server string, body CreateProjectJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateProjectRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateProjectRequestWithBody generates requests for CreateProject with any type of body
func NewCreateProjectRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteProjectRequest generates requests for DeleteProject
func NewDeleteProjectRequest(server string, projectID ProjectID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProjectRequest generates requests for GetProject
func NewGetProjectRequest(server string, projectID ProjectID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateProjectRequest calls the generic UpdateProject builder with application/json body
func NewUpdateProjectRequest(server string, projectID ProjectID, body UpdateProjectJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateProjectRequestWithBody(server, projectID, "application/json", bodyReader)
}

// NewUpdateProjectRequestWithBody generates requests for UpdateProject with any type of body
func NewUpdateProjectRequestWithBody(server string, projectID ProjectID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListBranchesForProjectRequest generates requests for ListBranchesForProject
func NewListBranchesForProjectRequest(server string, projectID ProjectID, params *ListBranchesForProjectParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/branches", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateBranchForProjectRequest calls the generic CreateBranchForProject builder with application/json body
func NewCreateBranchForProjectRequest(server string, projectID ProjectID, body CreateBranchForProjectJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateBranchForProjectRequestWithBody(server, projectID, "application/json", bodyReader)
}

// NewCreateBranchForProjectRequestWithBody generates requests for CreateBranchForProject with any type of body
func NewCreateBranchForProjectRequestWithBody(server string, projectID ProjectID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/branches", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteBranchForProjectRequest generates requests for DeleteBranchForProject
func NewDeleteBranchForProjectRequest(server string, projectID ProjectID, branchID BranchID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branchID", runtime.ParamLocationPath, branchID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/branches/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBranchForProjectRequest generates requests for GetBranchForProject
func NewGetBranchForProjectRequest(server string, projectID ProjectID, branchID BranchID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branchID", runtime.ParamLocationPath, branchID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/branches/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListBuildsForBranchRequest generates requests for ListBuildsForBranch
func NewListBuildsForBranchRequest(server string, projectID ProjectID, branchID BranchID, params *ListBuildsForBranchParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branchID", runtime.ParamLocationPath, branchID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/branches/%s/builds", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateBuildForBranchRequest calls the generic CreateBuildForBranch builder with application/json body
func NewCreateBuildForBranchRequest(server string, projectID ProjectID, branchID BranchID, body CreateBuildForBranchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateBuildForBranchRequestWithBody(server, projectID, branchID, "application/json", bodyReader)
}

// NewCreateBuildForBranchRequestWithBody generates requests for CreateBuildForBranch with any type of body
func NewCreateBuildForBranchRequestWithBody(server string, projectID ProjectID, branchID BranchID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branchID", runtime.ParamLocationPath, branchID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/branches/%s/builds", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteBuildForBranchRequest generates requests for DeleteBuildForBranch
func NewDeleteBuildForBranchRequest(server string, projectID ProjectID, branchID BranchID, buildID BuildID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branchID", runtime.ParamLocationPath, branchID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "buildID", runtime.ParamLocationPath, buildID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/branches/%s/builds/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBuildForBranchRequest generates requests for GetBuildForBranch
func NewGetBuildForBranchRequest(server string, projectID ProjectID, branchID BranchID, buildID BuildID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branchID", runtime.ParamLocationPath, branchID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "buildID", runtime.ParamLocationPath, buildID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/branches/%s/builds/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListBatchesForBuildRequest generates requests for ListBatchesForBuild
func NewListBatchesForBuildRequest(server string, projectID ProjectID, branchID BranchID, buildID BuildID, params *ListBatchesForBuildParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branchID", runtime.ParamLocationPath, branchID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "buildID", runtime.ParamLocationPath, buildID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/branches/%s/builds/%s/batches", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDestroySandboxRequest calls the generic DestroySandbox builder with application/json body
func NewDestroySandboxRequest(server string, body DestroySandboxJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDestroySandboxRequestWithBody(server, "application/json", bodyReader)
}

// NewDestroySandboxRequestWithBody generates requests for DestroySandbox with any type of body
func NewDestroySandboxRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandbox/:destroy")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSetupSandboxRequest calls the generic SetupSandbox builder with application/json body
func NewSetupSandboxRequest(server string, body SetupSandboxJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetupSandboxRequestWithBody(server, "application/json", bodyReader)
}

// NewSetupSandboxRequestWithBody generates requests for SetupSandbox with any type of body
func NewSetupSandboxRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandbox/:setup")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListViewSessionsRequest generates requests for ListViewSessions
func NewListViewSessionsRequest(server string, params *ListViewSessionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/view/sessions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateViewSessionRequest generates requests for CreateViewSession
func NewCreateViewSessionRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/view/sessions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetViewSessionRequest generates requests for GetViewSession
func NewGetViewSessionRequest(server string, viewSessionID ViewSessionID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "viewSessionID", runtime.ParamLocationPath, viewSessionID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/view/sessions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateViewUpdateRequestWithBody generates requests for CreateViewUpdate with any type of body
func NewCreateViewUpdateRequestWithBody(server string, viewSessionID ViewSessionID, viewUpdateID ViewUpdateID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "viewSessionID", runtime.ParamLocationPath, viewSessionID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "viewUpdateID", runtime.ParamLocationPath, viewUpdateID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/view/sessions/%s/updates/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListBatchesWithResponse request
	ListBatchesWithResponse(ctx context.Context, params *ListBatchesParams, reqEditors ...RequestEditorFn) (*ListBatchesResponse, error)

	// CreateBatchWithBodyWithResponse request with any body
	CreateBatchWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBatchResponse, error)

	CreateBatchWithResponse(ctx context.Context, body CreateBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBatchResponse, error)

	// GetBatchWithResponse request
	GetBatchWithResponse(ctx context.Context, batchID BatchID, reqEditors ...RequestEditorFn) (*GetBatchResponse, error)

	// CancelBatchWithResponse request
	CancelBatchWithResponse(ctx context.Context, batchID BatchID, reqEditors ...RequestEditorFn) (*CancelBatchResponse, error)

	// ListJobsWithResponse request
	ListJobsWithResponse(ctx context.Context, batchID BatchID, params *ListJobsParams, reqEditors ...RequestEditorFn) (*ListJobsResponse, error)

	// GetJobWithResponse request
	GetJobWithResponse(ctx context.Context, batchID BatchID, jobID JobID, reqEditors ...RequestEditorFn) (*GetJobResponse, error)

	// ListLogsForJobWithResponse request
	ListLogsForJobWithResponse(ctx context.Context, batchID BatchID, jobID JobID, params *ListLogsForJobParams, reqEditors ...RequestEditorFn) (*ListLogsForJobResponse, error)

	// CreateLogWithBodyWithResponse request with any body
	CreateLogWithBodyWithResponse(ctx context.Context, batchID BatchID, jobID JobID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLogResponse, error)

	CreateLogWithResponse(ctx context.Context, batchID BatchID, jobID JobID, body CreateLogJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLogResponse, error)

	// DeleteLogWithResponse request
	DeleteLogWithResponse(ctx context.Context, batchID BatchID, jobID JobID, logID LogID, reqEditors ...RequestEditorFn) (*DeleteLogResponse, error)

	// GetLogWithResponse request
	GetLogWithResponse(ctx context.Context, batchID BatchID, jobID JobID, logID LogID, reqEditors ...RequestEditorFn) (*GetLogResponse, error)

	// GetJobMetricsWithResponse request
	GetJobMetricsWithResponse(ctx context.Context, batchID BatchID, jobID JobID, reqEditors ...RequestEditorFn) (*GetJobMetricsResponse, error)

	// ListBuildsWithResponse request
	ListBuildsWithResponse(ctx context.Context, params *ListBuildsParams, reqEditors ...RequestEditorFn) (*ListBuildsResponse, error)

	// GetBuildWithResponse request
	GetBuildWithResponse(ctx context.Context, buildID BuildID, reqEditors ...RequestEditorFn) (*GetBuildResponse, error)

	// ListExperienceTagsWithResponse request
	ListExperienceTagsWithResponse(ctx context.Context, params *ListExperienceTagsParams, reqEditors ...RequestEditorFn) (*ListExperienceTagsResponse, error)

	// CreateExperienceTagWithBodyWithResponse request with any body
	CreateExperienceTagWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateExperienceTagResponse, error)

	CreateExperienceTagWithResponse(ctx context.Context, body CreateExperienceTagJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateExperienceTagResponse, error)

	// DeleteExperienceTagWithResponse request
	DeleteExperienceTagWithResponse(ctx context.Context, experienceTagID ExperienceTagID, reqEditors ...RequestEditorFn) (*DeleteExperienceTagResponse, error)

	// GetExperienceTagWithResponse request
	GetExperienceTagWithResponse(ctx context.Context, experienceTagID ExperienceTagID, reqEditors ...RequestEditorFn) (*GetExperienceTagResponse, error)

	// UpdateExperienceTagWithBodyWithResponse request with any body
	UpdateExperienceTagWithBodyWithResponse(ctx context.Context, experienceTagID ExperienceTagID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateExperienceTagResponse, error)

	UpdateExperienceTagWithResponse(ctx context.Context, experienceTagID ExperienceTagID, body UpdateExperienceTagJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateExperienceTagResponse, error)

	// ListExperiencesWithExperienceTagWithResponse request
	ListExperiencesWithExperienceTagWithResponse(ctx context.Context, experienceTagID ExperienceTagID, params *ListExperiencesWithExperienceTagParams, reqEditors ...RequestEditorFn) (*ListExperiencesWithExperienceTagResponse, error)

	// RemoveExperienceTagFromExperienceWithResponse request
	RemoveExperienceTagFromExperienceWithResponse(ctx context.Context, experienceTagID ExperienceTagID, experienceID ExperienceID, reqEditors ...RequestEditorFn) (*RemoveExperienceTagFromExperienceResponse, error)

	// AddExperienceTagToExperienceWithResponse request
	AddExperienceTagToExperienceWithResponse(ctx context.Context, experienceTagID ExperienceTagID, experienceID ExperienceID, reqEditors ...RequestEditorFn) (*AddExperienceTagToExperienceResponse, error)

	// ListExperiencesWithResponse request
	ListExperiencesWithResponse(ctx context.Context, params *ListExperiencesParams, reqEditors ...RequestEditorFn) (*ListExperiencesResponse, error)

	// CreateExperienceWithBodyWithResponse request with any body
	CreateExperienceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateExperienceResponse, error)

	CreateExperienceWithResponse(ctx context.Context, body CreateExperienceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateExperienceResponse, error)

	// DeleteExperienceWithResponse request
	DeleteExperienceWithResponse(ctx context.Context, experienceID ExperienceID, reqEditors ...RequestEditorFn) (*DeleteExperienceResponse, error)

	// GetExperienceWithResponse request
	GetExperienceWithResponse(ctx context.Context, experienceID ExperienceID, reqEditors ...RequestEditorFn) (*GetExperienceResponse, error)

	// UpdateExperienceWithBodyWithResponse request with any body
	UpdateExperienceWithBodyWithResponse(ctx context.Context, experienceID ExperienceID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateExperienceResponse, error)

	UpdateExperienceWithResponse(ctx context.Context, experienceID ExperienceID, body UpdateExperienceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateExperienceResponse, error)

	// ListExperienceTagsForExperienceWithResponse request
	ListExperienceTagsForExperienceWithResponse(ctx context.Context, experienceID ExperienceID, params *ListExperienceTagsForExperienceParams, reqEditors ...RequestEditorFn) (*ListExperienceTagsForExperienceResponse, error)

	// HealthWithResponse request
	HealthWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*HealthResponse, error)

	// ListProjectsWithResponse request
	ListProjectsWithResponse(ctx context.Context, params *ListProjectsParams, reqEditors ...RequestEditorFn) (*ListProjectsResponse, error)

	// CreateProjectWithBodyWithResponse request with any body
	CreateProjectWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProjectResponse, error)

	CreateProjectWithResponse(ctx context.Context, body CreateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProjectResponse, error)

	// DeleteProjectWithResponse request
	DeleteProjectWithResponse(ctx context.Context, projectID ProjectID, reqEditors ...RequestEditorFn) (*DeleteProjectResponse, error)

	// GetProjectWithResponse request
	GetProjectWithResponse(ctx context.Context, projectID ProjectID, reqEditors ...RequestEditorFn) (*GetProjectResponse, error)

	// UpdateProjectWithBodyWithResponse request with any body
	UpdateProjectWithBodyWithResponse(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProjectResponse, error)

	UpdateProjectWithResponse(ctx context.Context, projectID ProjectID, body UpdateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProjectResponse, error)

	// ListBranchesForProjectWithResponse request
	ListBranchesForProjectWithResponse(ctx context.Context, projectID ProjectID, params *ListBranchesForProjectParams, reqEditors ...RequestEditorFn) (*ListBranchesForProjectResponse, error)

	// CreateBranchForProjectWithBodyWithResponse request with any body
	CreateBranchForProjectWithBodyWithResponse(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBranchForProjectResponse, error)

	CreateBranchForProjectWithResponse(ctx context.Context, projectID ProjectID, body CreateBranchForProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBranchForProjectResponse, error)

	// DeleteBranchForProjectWithResponse request
	DeleteBranchForProjectWithResponse(ctx context.Context, projectID ProjectID, branchID BranchID, reqEditors ...RequestEditorFn) (*DeleteBranchForProjectResponse, error)

	// GetBranchForProjectWithResponse request
	GetBranchForProjectWithResponse(ctx context.Context, projectID ProjectID, branchID BranchID, reqEditors ...RequestEditorFn) (*GetBranchForProjectResponse, error)

	// ListBuildsForBranchWithResponse request
	ListBuildsForBranchWithResponse(ctx context.Context, projectID ProjectID, branchID BranchID, params *ListBuildsForBranchParams, reqEditors ...RequestEditorFn) (*ListBuildsForBranchResponse, error)

	// CreateBuildForBranchWithBodyWithResponse request with any body
	CreateBuildForBranchWithBodyWithResponse(ctx context.Context, projectID ProjectID, branchID BranchID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBuildForBranchResponse, error)

	CreateBuildForBranchWithResponse(ctx context.Context, projectID ProjectID, branchID BranchID, body CreateBuildForBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBuildForBranchResponse, error)

	// DeleteBuildForBranchWithResponse request
	DeleteBuildForBranchWithResponse(ctx context.Context, projectID ProjectID, branchID BranchID, buildID BuildID, reqEditors ...RequestEditorFn) (*DeleteBuildForBranchResponse, error)

	// GetBuildForBranchWithResponse request
	GetBuildForBranchWithResponse(ctx context.Context, projectID ProjectID, branchID BranchID, buildID BuildID, reqEditors ...RequestEditorFn) (*GetBuildForBranchResponse, error)

	// ListBatchesForBuildWithResponse request
	ListBatchesForBuildWithResponse(ctx context.Context, projectID ProjectID, branchID BranchID, buildID BuildID, params *ListBatchesForBuildParams, reqEditors ...RequestEditorFn) (*ListBatchesForBuildResponse, error)

	// DestroySandboxWithBodyWithResponse request with any body
	DestroySandboxWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DestroySandboxResponse, error)

	DestroySandboxWithResponse(ctx context.Context, body DestroySandboxJSONRequestBody, reqEditors ...RequestEditorFn) (*DestroySandboxResponse, error)

	// SetupSandboxWithBodyWithResponse request with any body
	SetupSandboxWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetupSandboxResponse, error)

	SetupSandboxWithResponse(ctx context.Context, body SetupSandboxJSONRequestBody, reqEditors ...RequestEditorFn) (*SetupSandboxResponse, error)

	// ListViewSessionsWithResponse request
	ListViewSessionsWithResponse(ctx context.Context, params *ListViewSessionsParams, reqEditors ...RequestEditorFn) (*ListViewSessionsResponse, error)

	// CreateViewSessionWithResponse request
	CreateViewSessionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CreateViewSessionResponse, error)

	// GetViewSessionWithResponse request
	GetViewSessionWithResponse(ctx context.Context, viewSessionID ViewSessionID, reqEditors ...RequestEditorFn) (*GetViewSessionResponse, error)

	// CreateViewUpdateWithBodyWithResponse request with any body
	CreateViewUpdateWithBodyWithResponse(ctx context.Context, viewSessionID ViewSessionID, viewUpdateID ViewUpdateID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateViewUpdateResponse, error)
}

type ListBatchesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Batches       *[]Batch `json:"batches,omitempty"`
		NextPageToken *string  `json:"nextPageToken,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListBatchesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBatchesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBatchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Batch
}

// Status returns HTTPResponse.Status
func (r CreateBatchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBatchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBatchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Batch
}

// Status returns HTTPResponse.Status
func (r GetBatchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBatchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CancelBatchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CancelBatchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CancelBatchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Jobs          *[]Job  `json:"jobs,omitempty"`
		NextPageToken *string `json:"nextPageToken,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Job
}

// Status returns HTTPResponse.Status
func (r GetJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListLogsForJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Logs          *[]Log  `json:"logs,omitempty"`
		NextPageToken *string `json:"nextPageToken,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListLogsForJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListLogsForJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateLogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Log
}

// Status returns HTTPResponse.Status
func (r CreateLogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateLogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteLogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteLogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteLogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Log
}

// Status returns HTTPResponse.Status
func (r GetLogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetJobMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r GetJobMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetJobMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBuildsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Builds        *[]Build `json:"builds,omitempty"`
		NextPageToken *string  `json:"nextPageToken,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListBuildsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBuildsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBuildResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Build
}

// Status returns HTTPResponse.Status
func (r GetBuildResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBuildResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListExperienceTagsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		ExperienceTags *[]ExperienceTag `json:"experienceTags,omitempty"`
		NextPageToken  *string          `json:"nextPageToken,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListExperienceTagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListExperienceTagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateExperienceTagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ExperienceTag
}

// Status returns HTTPResponse.Status
func (r CreateExperienceTagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateExperienceTagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteExperienceTagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteExperienceTagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteExperienceTagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetExperienceTagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ExperienceTag
}

// Status returns HTTPResponse.Status
func (r GetExperienceTagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetExperienceTagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateExperienceTagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ExperienceTag
}

// Status returns HTTPResponse.Status
func (r UpdateExperienceTagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateExperienceTagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListExperiencesWithExperienceTagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Experiences   *[]Experience `json:"experiences,omitempty"`
		NextPageToken *string       `json:"nextPageToken,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListExperiencesWithExperienceTagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListExperiencesWithExperienceTagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveExperienceTagFromExperienceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveExperienceTagFromExperienceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveExperienceTagFromExperienceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddExperienceTagToExperienceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AddExperienceTagToExperienceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddExperienceTagToExperienceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListExperiencesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Experiences   *[]Experience `json:"experiences,omitempty"`
		NextPageToken *string       `json:"nextPageToken,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListExperiencesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListExperiencesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateExperienceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Experience
}

// Status returns HTTPResponse.Status
func (r CreateExperienceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateExperienceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteExperienceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteExperienceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteExperienceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetExperienceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Experience
}

// Status returns HTTPResponse.Status
func (r GetExperienceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetExperienceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateExperienceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Experience
}

// Status returns HTTPResponse.Status
func (r UpdateExperienceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateExperienceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListExperienceTagsForExperienceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		ExperienceTags *[]ExperienceTag `json:"experienceTags,omitempty"`
		NextPageToken  *string          `json:"nextPageToken,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListExperienceTagsForExperienceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListExperienceTagsForExperienceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HealthResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r HealthResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HealthResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListProjectsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		NextPageToken *string    `json:"nextPageToken,omitempty"`
		Projects      *[]Project `json:"projects,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListProjectsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListProjectsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Project
}

// Status returns HTTPResponse.Status
func (r CreateProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Project
}

// Status returns HTTPResponse.Status
func (r GetProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Project
}

// Status returns HTTPResponse.Status
func (r UpdateProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBranchesForProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Branches      *[]Branch `json:"branches,omitempty"`
		NextPageToken *string   `json:"nextPageToken,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListBranchesForProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBranchesForProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBranchForProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Branch
}

// Status returns HTTPResponse.Status
func (r CreateBranchForProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBranchForProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteBranchForProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteBranchForProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteBranchForProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBranchForProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Branch
}

// Status returns HTTPResponse.Status
func (r GetBranchForProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBranchForProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBuildsForBranchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Builds        *[]Build `json:"builds,omitempty"`
		NextPageToken *string  `json:"nextPageToken,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListBuildsForBranchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBuildsForBranchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBuildForBranchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Build
}

// Status returns HTTPResponse.Status
func (r CreateBuildForBranchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBuildForBranchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteBuildForBranchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteBuildForBranchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteBuildForBranchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBuildForBranchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Build
}

// Status returns HTTPResponse.Status
func (r GetBuildForBranchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBuildForBranchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBatchesForBuildResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Batches       *[]Batch `json:"batches,omitempty"`
		NextPageToken *string  `json:"nextPageToken,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListBatchesForBuildResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBatchesForBuildResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DestroySandboxResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DestroySandboxResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DestroySandboxResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetupSandboxResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetupSandboxResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetupSandboxResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListViewSessionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		NextPageToken *string       `json:"nextPageToken,omitempty"`
		ViewSessions  *[]ViewObject `json:"viewSessions,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListViewSessionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListViewSessionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateViewSessionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ViewSessionID
}

// Status returns HTTPResponse.Status
func (r CreateViewSessionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateViewSessionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetViewSessionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		ViewMetadata *[]ViewMetadata `json:"viewMetadata,omitempty"`
		ViewObject   *ViewObject     `json:"viewObject,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetViewSessionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetViewSessionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateViewUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Id   *ViewSessionID `json:"id,omitempty"`
		Mcap *McapURL       `json:"mcap,omitempty"`

		// View A link to view the session.
		View *string `json:"view,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateViewUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateViewUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListBatchesWithResponse request returning *ListBatchesResponse
func (c *ClientWithResponses) ListBatchesWithResponse(ctx context.Context, params *ListBatchesParams, reqEditors ...RequestEditorFn) (*ListBatchesResponse, error) {
	rsp, err := c.ListBatches(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBatchesResponse(rsp)
}

// CreateBatchWithBodyWithResponse request with arbitrary body returning *CreateBatchResponse
func (c *ClientWithResponses) CreateBatchWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBatchResponse, error) {
	rsp, err := c.CreateBatchWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBatchResponse(rsp)
}

func (c *ClientWithResponses) CreateBatchWithResponse(ctx context.Context, body CreateBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBatchResponse, error) {
	rsp, err := c.CreateBatch(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBatchResponse(rsp)
}

// GetBatchWithResponse request returning *GetBatchResponse
func (c *ClientWithResponses) GetBatchWithResponse(ctx context.Context, batchID BatchID, reqEditors ...RequestEditorFn) (*GetBatchResponse, error) {
	rsp, err := c.GetBatch(ctx, batchID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBatchResponse(rsp)
}

// CancelBatchWithResponse request returning *CancelBatchResponse
func (c *ClientWithResponses) CancelBatchWithResponse(ctx context.Context, batchID BatchID, reqEditors ...RequestEditorFn) (*CancelBatchResponse, error) {
	rsp, err := c.CancelBatch(ctx, batchID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelBatchResponse(rsp)
}

// ListJobsWithResponse request returning *ListJobsResponse
func (c *ClientWithResponses) ListJobsWithResponse(ctx context.Context, batchID BatchID, params *ListJobsParams, reqEditors ...RequestEditorFn) (*ListJobsResponse, error) {
	rsp, err := c.ListJobs(ctx, batchID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListJobsResponse(rsp)
}

// GetJobWithResponse request returning *GetJobResponse
func (c *ClientWithResponses) GetJobWithResponse(ctx context.Context, batchID BatchID, jobID JobID, reqEditors ...RequestEditorFn) (*GetJobResponse, error) {
	rsp, err := c.GetJob(ctx, batchID, jobID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetJobResponse(rsp)
}

// ListLogsForJobWithResponse request returning *ListLogsForJobResponse
func (c *ClientWithResponses) ListLogsForJobWithResponse(ctx context.Context, batchID BatchID, jobID JobID, params *ListLogsForJobParams, reqEditors ...RequestEditorFn) (*ListLogsForJobResponse, error) {
	rsp, err := c.ListLogsForJob(ctx, batchID, jobID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListLogsForJobResponse(rsp)
}

// CreateLogWithBodyWithResponse request with arbitrary body returning *CreateLogResponse
func (c *ClientWithResponses) CreateLogWithBodyWithResponse(ctx context.Context, batchID BatchID, jobID JobID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLogResponse, error) {
	rsp, err := c.CreateLogWithBody(ctx, batchID, jobID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLogResponse(rsp)
}

func (c *ClientWithResponses) CreateLogWithResponse(ctx context.Context, batchID BatchID, jobID JobID, body CreateLogJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLogResponse, error) {
	rsp, err := c.CreateLog(ctx, batchID, jobID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLogResponse(rsp)
}

// DeleteLogWithResponse request returning *DeleteLogResponse
func (c *ClientWithResponses) DeleteLogWithResponse(ctx context.Context, batchID BatchID, jobID JobID, logID LogID, reqEditors ...RequestEditorFn) (*DeleteLogResponse, error) {
	rsp, err := c.DeleteLog(ctx, batchID, jobID, logID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteLogResponse(rsp)
}

// GetLogWithResponse request returning *GetLogResponse
func (c *ClientWithResponses) GetLogWithResponse(ctx context.Context, batchID BatchID, jobID JobID, logID LogID, reqEditors ...RequestEditorFn) (*GetLogResponse, error) {
	rsp, err := c.GetLog(ctx, batchID, jobID, logID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLogResponse(rsp)
}

// GetJobMetricsWithResponse request returning *GetJobMetricsResponse
func (c *ClientWithResponses) GetJobMetricsWithResponse(ctx context.Context, batchID BatchID, jobID JobID, reqEditors ...RequestEditorFn) (*GetJobMetricsResponse, error) {
	rsp, err := c.GetJobMetrics(ctx, batchID, jobID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetJobMetricsResponse(rsp)
}

// ListBuildsWithResponse request returning *ListBuildsResponse
func (c *ClientWithResponses) ListBuildsWithResponse(ctx context.Context, params *ListBuildsParams, reqEditors ...RequestEditorFn) (*ListBuildsResponse, error) {
	rsp, err := c.ListBuilds(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBuildsResponse(rsp)
}

// GetBuildWithResponse request returning *GetBuildResponse
func (c *ClientWithResponses) GetBuildWithResponse(ctx context.Context, buildID BuildID, reqEditors ...RequestEditorFn) (*GetBuildResponse, error) {
	rsp, err := c.GetBuild(ctx, buildID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBuildResponse(rsp)
}

// ListExperienceTagsWithResponse request returning *ListExperienceTagsResponse
func (c *ClientWithResponses) ListExperienceTagsWithResponse(ctx context.Context, params *ListExperienceTagsParams, reqEditors ...RequestEditorFn) (*ListExperienceTagsResponse, error) {
	rsp, err := c.ListExperienceTags(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListExperienceTagsResponse(rsp)
}

// CreateExperienceTagWithBodyWithResponse request with arbitrary body returning *CreateExperienceTagResponse
func (c *ClientWithResponses) CreateExperienceTagWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateExperienceTagResponse, error) {
	rsp, err := c.CreateExperienceTagWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateExperienceTagResponse(rsp)
}

func (c *ClientWithResponses) CreateExperienceTagWithResponse(ctx context.Context, body CreateExperienceTagJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateExperienceTagResponse, error) {
	rsp, err := c.CreateExperienceTag(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateExperienceTagResponse(rsp)
}

// DeleteExperienceTagWithResponse request returning *DeleteExperienceTagResponse
func (c *ClientWithResponses) DeleteExperienceTagWithResponse(ctx context.Context, experienceTagID ExperienceTagID, reqEditors ...RequestEditorFn) (*DeleteExperienceTagResponse, error) {
	rsp, err := c.DeleteExperienceTag(ctx, experienceTagID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteExperienceTagResponse(rsp)
}

// GetExperienceTagWithResponse request returning *GetExperienceTagResponse
func (c *ClientWithResponses) GetExperienceTagWithResponse(ctx context.Context, experienceTagID ExperienceTagID, reqEditors ...RequestEditorFn) (*GetExperienceTagResponse, error) {
	rsp, err := c.GetExperienceTag(ctx, experienceTagID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetExperienceTagResponse(rsp)
}

// UpdateExperienceTagWithBodyWithResponse request with arbitrary body returning *UpdateExperienceTagResponse
func (c *ClientWithResponses) UpdateExperienceTagWithBodyWithResponse(ctx context.Context, experienceTagID ExperienceTagID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateExperienceTagResponse, error) {
	rsp, err := c.UpdateExperienceTagWithBody(ctx, experienceTagID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateExperienceTagResponse(rsp)
}

func (c *ClientWithResponses) UpdateExperienceTagWithResponse(ctx context.Context, experienceTagID ExperienceTagID, body UpdateExperienceTagJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateExperienceTagResponse, error) {
	rsp, err := c.UpdateExperienceTag(ctx, experienceTagID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateExperienceTagResponse(rsp)
}

// ListExperiencesWithExperienceTagWithResponse request returning *ListExperiencesWithExperienceTagResponse
func (c *ClientWithResponses) ListExperiencesWithExperienceTagWithResponse(ctx context.Context, experienceTagID ExperienceTagID, params *ListExperiencesWithExperienceTagParams, reqEditors ...RequestEditorFn) (*ListExperiencesWithExperienceTagResponse, error) {
	rsp, err := c.ListExperiencesWithExperienceTag(ctx, experienceTagID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListExperiencesWithExperienceTagResponse(rsp)
}

// RemoveExperienceTagFromExperienceWithResponse request returning *RemoveExperienceTagFromExperienceResponse
func (c *ClientWithResponses) RemoveExperienceTagFromExperienceWithResponse(ctx context.Context, experienceTagID ExperienceTagID, experienceID ExperienceID, reqEditors ...RequestEditorFn) (*RemoveExperienceTagFromExperienceResponse, error) {
	rsp, err := c.RemoveExperienceTagFromExperience(ctx, experienceTagID, experienceID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveExperienceTagFromExperienceResponse(rsp)
}

// AddExperienceTagToExperienceWithResponse request returning *AddExperienceTagToExperienceResponse
func (c *ClientWithResponses) AddExperienceTagToExperienceWithResponse(ctx context.Context, experienceTagID ExperienceTagID, experienceID ExperienceID, reqEditors ...RequestEditorFn) (*AddExperienceTagToExperienceResponse, error) {
	rsp, err := c.AddExperienceTagToExperience(ctx, experienceTagID, experienceID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddExperienceTagToExperienceResponse(rsp)
}

// ListExperiencesWithResponse request returning *ListExperiencesResponse
func (c *ClientWithResponses) ListExperiencesWithResponse(ctx context.Context, params *ListExperiencesParams, reqEditors ...RequestEditorFn) (*ListExperiencesResponse, error) {
	rsp, err := c.ListExperiences(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListExperiencesResponse(rsp)
}

// CreateExperienceWithBodyWithResponse request with arbitrary body returning *CreateExperienceResponse
func (c *ClientWithResponses) CreateExperienceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateExperienceResponse, error) {
	rsp, err := c.CreateExperienceWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateExperienceResponse(rsp)
}

func (c *ClientWithResponses) CreateExperienceWithResponse(ctx context.Context, body CreateExperienceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateExperienceResponse, error) {
	rsp, err := c.CreateExperience(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateExperienceResponse(rsp)
}

// DeleteExperienceWithResponse request returning *DeleteExperienceResponse
func (c *ClientWithResponses) DeleteExperienceWithResponse(ctx context.Context, experienceID ExperienceID, reqEditors ...RequestEditorFn) (*DeleteExperienceResponse, error) {
	rsp, err := c.DeleteExperience(ctx, experienceID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteExperienceResponse(rsp)
}

// GetExperienceWithResponse request returning *GetExperienceResponse
func (c *ClientWithResponses) GetExperienceWithResponse(ctx context.Context, experienceID ExperienceID, reqEditors ...RequestEditorFn) (*GetExperienceResponse, error) {
	rsp, err := c.GetExperience(ctx, experienceID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetExperienceResponse(rsp)
}

// UpdateExperienceWithBodyWithResponse request with arbitrary body returning *UpdateExperienceResponse
func (c *ClientWithResponses) UpdateExperienceWithBodyWithResponse(ctx context.Context, experienceID ExperienceID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateExperienceResponse, error) {
	rsp, err := c.UpdateExperienceWithBody(ctx, experienceID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateExperienceResponse(rsp)
}

func (c *ClientWithResponses) UpdateExperienceWithResponse(ctx context.Context, experienceID ExperienceID, body UpdateExperienceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateExperienceResponse, error) {
	rsp, err := c.UpdateExperience(ctx, experienceID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateExperienceResponse(rsp)
}

// ListExperienceTagsForExperienceWithResponse request returning *ListExperienceTagsForExperienceResponse
func (c *ClientWithResponses) ListExperienceTagsForExperienceWithResponse(ctx context.Context, experienceID ExperienceID, params *ListExperienceTagsForExperienceParams, reqEditors ...RequestEditorFn) (*ListExperienceTagsForExperienceResponse, error) {
	rsp, err := c.ListExperienceTagsForExperience(ctx, experienceID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListExperienceTagsForExperienceResponse(rsp)
}

// HealthWithResponse request returning *HealthResponse
func (c *ClientWithResponses) HealthWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*HealthResponse, error) {
	rsp, err := c.Health(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHealthResponse(rsp)
}

// ListProjectsWithResponse request returning *ListProjectsResponse
func (c *ClientWithResponses) ListProjectsWithResponse(ctx context.Context, params *ListProjectsParams, reqEditors ...RequestEditorFn) (*ListProjectsResponse, error) {
	rsp, err := c.ListProjects(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListProjectsResponse(rsp)
}

// CreateProjectWithBodyWithResponse request with arbitrary body returning *CreateProjectResponse
func (c *ClientWithResponses) CreateProjectWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProjectResponse, error) {
	rsp, err := c.CreateProjectWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProjectResponse(rsp)
}

func (c *ClientWithResponses) CreateProjectWithResponse(ctx context.Context, body CreateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProjectResponse, error) {
	rsp, err := c.CreateProject(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProjectResponse(rsp)
}

// DeleteProjectWithResponse request returning *DeleteProjectResponse
func (c *ClientWithResponses) DeleteProjectWithResponse(ctx context.Context, projectID ProjectID, reqEditors ...RequestEditorFn) (*DeleteProjectResponse, error) {
	rsp, err := c.DeleteProject(ctx, projectID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProjectResponse(rsp)
}

// GetProjectWithResponse request returning *GetProjectResponse
func (c *ClientWithResponses) GetProjectWithResponse(ctx context.Context, projectID ProjectID, reqEditors ...RequestEditorFn) (*GetProjectResponse, error) {
	rsp, err := c.GetProject(ctx, projectID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProjectResponse(rsp)
}

// UpdateProjectWithBodyWithResponse request with arbitrary body returning *UpdateProjectResponse
func (c *ClientWithResponses) UpdateProjectWithBodyWithResponse(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProjectResponse, error) {
	rsp, err := c.UpdateProjectWithBody(ctx, projectID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProjectResponse(rsp)
}

func (c *ClientWithResponses) UpdateProjectWithResponse(ctx context.Context, projectID ProjectID, body UpdateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProjectResponse, error) {
	rsp, err := c.UpdateProject(ctx, projectID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProjectResponse(rsp)
}

// ListBranchesForProjectWithResponse request returning *ListBranchesForProjectResponse
func (c *ClientWithResponses) ListBranchesForProjectWithResponse(ctx context.Context, projectID ProjectID, params *ListBranchesForProjectParams, reqEditors ...RequestEditorFn) (*ListBranchesForProjectResponse, error) {
	rsp, err := c.ListBranchesForProject(ctx, projectID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBranchesForProjectResponse(rsp)
}

// CreateBranchForProjectWithBodyWithResponse request with arbitrary body returning *CreateBranchForProjectResponse
func (c *ClientWithResponses) CreateBranchForProjectWithBodyWithResponse(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBranchForProjectResponse, error) {
	rsp, err := c.CreateBranchForProjectWithBody(ctx, projectID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBranchForProjectResponse(rsp)
}

func (c *ClientWithResponses) CreateBranchForProjectWithResponse(ctx context.Context, projectID ProjectID, body CreateBranchForProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBranchForProjectResponse, error) {
	rsp, err := c.CreateBranchForProject(ctx, projectID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBranchForProjectResponse(rsp)
}

// DeleteBranchForProjectWithResponse request returning *DeleteBranchForProjectResponse
func (c *ClientWithResponses) DeleteBranchForProjectWithResponse(ctx context.Context, projectID ProjectID, branchID BranchID, reqEditors ...RequestEditorFn) (*DeleteBranchForProjectResponse, error) {
	rsp, err := c.DeleteBranchForProject(ctx, projectID, branchID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteBranchForProjectResponse(rsp)
}

// GetBranchForProjectWithResponse request returning *GetBranchForProjectResponse
func (c *ClientWithResponses) GetBranchForProjectWithResponse(ctx context.Context, projectID ProjectID, branchID BranchID, reqEditors ...RequestEditorFn) (*GetBranchForProjectResponse, error) {
	rsp, err := c.GetBranchForProject(ctx, projectID, branchID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBranchForProjectResponse(rsp)
}

// ListBuildsForBranchWithResponse request returning *ListBuildsForBranchResponse
func (c *ClientWithResponses) ListBuildsForBranchWithResponse(ctx context.Context, projectID ProjectID, branchID BranchID, params *ListBuildsForBranchParams, reqEditors ...RequestEditorFn) (*ListBuildsForBranchResponse, error) {
	rsp, err := c.ListBuildsForBranch(ctx, projectID, branchID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBuildsForBranchResponse(rsp)
}

// CreateBuildForBranchWithBodyWithResponse request with arbitrary body returning *CreateBuildForBranchResponse
func (c *ClientWithResponses) CreateBuildForBranchWithBodyWithResponse(ctx context.Context, projectID ProjectID, branchID BranchID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBuildForBranchResponse, error) {
	rsp, err := c.CreateBuildForBranchWithBody(ctx, projectID, branchID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBuildForBranchResponse(rsp)
}

func (c *ClientWithResponses) CreateBuildForBranchWithResponse(ctx context.Context, projectID ProjectID, branchID BranchID, body CreateBuildForBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBuildForBranchResponse, error) {
	rsp, err := c.CreateBuildForBranch(ctx, projectID, branchID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBuildForBranchResponse(rsp)
}

// DeleteBuildForBranchWithResponse request returning *DeleteBuildForBranchResponse
func (c *ClientWithResponses) DeleteBuildForBranchWithResponse(ctx context.Context, projectID ProjectID, branchID BranchID, buildID BuildID, reqEditors ...RequestEditorFn) (*DeleteBuildForBranchResponse, error) {
	rsp, err := c.DeleteBuildForBranch(ctx, projectID, branchID, buildID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteBuildForBranchResponse(rsp)
}

// GetBuildForBranchWithResponse request returning *GetBuildForBranchResponse
func (c *ClientWithResponses) GetBuildForBranchWithResponse(ctx context.Context, projectID ProjectID, branchID BranchID, buildID BuildID, reqEditors ...RequestEditorFn) (*GetBuildForBranchResponse, error) {
	rsp, err := c.GetBuildForBranch(ctx, projectID, branchID, buildID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBuildForBranchResponse(rsp)
}

// ListBatchesForBuildWithResponse request returning *ListBatchesForBuildResponse
func (c *ClientWithResponses) ListBatchesForBuildWithResponse(ctx context.Context, projectID ProjectID, branchID BranchID, buildID BuildID, params *ListBatchesForBuildParams, reqEditors ...RequestEditorFn) (*ListBatchesForBuildResponse, error) {
	rsp, err := c.ListBatchesForBuild(ctx, projectID, branchID, buildID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBatchesForBuildResponse(rsp)
}

// DestroySandboxWithBodyWithResponse request with arbitrary body returning *DestroySandboxResponse
func (c *ClientWithResponses) DestroySandboxWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DestroySandboxResponse, error) {
	rsp, err := c.DestroySandboxWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDestroySandboxResponse(rsp)
}

func (c *ClientWithResponses) DestroySandboxWithResponse(ctx context.Context, body DestroySandboxJSONRequestBody, reqEditors ...RequestEditorFn) (*DestroySandboxResponse, error) {
	rsp, err := c.DestroySandbox(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDestroySandboxResponse(rsp)
}

// SetupSandboxWithBodyWithResponse request with arbitrary body returning *SetupSandboxResponse
func (c *ClientWithResponses) SetupSandboxWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetupSandboxResponse, error) {
	rsp, err := c.SetupSandboxWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetupSandboxResponse(rsp)
}

func (c *ClientWithResponses) SetupSandboxWithResponse(ctx context.Context, body SetupSandboxJSONRequestBody, reqEditors ...RequestEditorFn) (*SetupSandboxResponse, error) {
	rsp, err := c.SetupSandbox(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetupSandboxResponse(rsp)
}

// ListViewSessionsWithResponse request returning *ListViewSessionsResponse
func (c *ClientWithResponses) ListViewSessionsWithResponse(ctx context.Context, params *ListViewSessionsParams, reqEditors ...RequestEditorFn) (*ListViewSessionsResponse, error) {
	rsp, err := c.ListViewSessions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListViewSessionsResponse(rsp)
}

// CreateViewSessionWithResponse request returning *CreateViewSessionResponse
func (c *ClientWithResponses) CreateViewSessionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CreateViewSessionResponse, error) {
	rsp, err := c.CreateViewSession(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateViewSessionResponse(rsp)
}

// GetViewSessionWithResponse request returning *GetViewSessionResponse
func (c *ClientWithResponses) GetViewSessionWithResponse(ctx context.Context, viewSessionID ViewSessionID, reqEditors ...RequestEditorFn) (*GetViewSessionResponse, error) {
	rsp, err := c.GetViewSession(ctx, viewSessionID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetViewSessionResponse(rsp)
}

// CreateViewUpdateWithBodyWithResponse request with arbitrary body returning *CreateViewUpdateResponse
func (c *ClientWithResponses) CreateViewUpdateWithBodyWithResponse(ctx context.Context, viewSessionID ViewSessionID, viewUpdateID ViewUpdateID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateViewUpdateResponse, error) {
	rsp, err := c.CreateViewUpdateWithBody(ctx, viewSessionID, viewUpdateID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateViewUpdateResponse(rsp)
}

// ParseListBatchesResponse parses an HTTP response from a ListBatchesWithResponse call
func ParseListBatchesResponse(rsp *http.Response) (*ListBatchesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListBatchesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Batches       *[]Batch `json:"batches,omitempty"`
			NextPageToken *string  `json:"nextPageToken,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateBatchResponse parses an HTTP response from a CreateBatchWithResponse call
func ParseCreateBatchResponse(rsp *http.Response) (*CreateBatchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBatchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Batch
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseGetBatchResponse parses an HTTP response from a GetBatchWithResponse call
func ParseGetBatchResponse(rsp *http.Response) (*GetBatchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBatchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Batch
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCancelBatchResponse parses an HTTP response from a CancelBatchWithResponse call
func ParseCancelBatchResponse(rsp *http.Response) (*CancelBatchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CancelBatchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListJobsResponse parses an HTTP response from a ListJobsWithResponse call
func ParseListJobsResponse(rsp *http.Response) (*ListJobsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Jobs          *[]Job  `json:"jobs,omitempty"`
			NextPageToken *string `json:"nextPageToken,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetJobResponse parses an HTTP response from a GetJobWithResponse call
func ParseGetJobResponse(rsp *http.Response) (*GetJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Job
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListLogsForJobResponse parses an HTTP response from a ListLogsForJobWithResponse call
func ParseListLogsForJobResponse(rsp *http.Response) (*ListLogsForJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListLogsForJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Logs          *[]Log  `json:"logs,omitempty"`
			NextPageToken *string `json:"nextPageToken,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateLogResponse parses an HTTP response from a CreateLogWithResponse call
func ParseCreateLogResponse(rsp *http.Response) (*CreateLogResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateLogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Log
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseDeleteLogResponse parses an HTTP response from a DeleteLogWithResponse call
func ParseDeleteLogResponse(rsp *http.Response) (*DeleteLogResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteLogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetLogResponse parses an HTTP response from a GetLogWithResponse call
func ParseGetLogResponse(rsp *http.Response) (*GetLogResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Log
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetJobMetricsResponse parses an HTTP response from a GetJobMetricsWithResponse call
func ParseGetJobMetricsResponse(rsp *http.Response) (*GetJobMetricsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetJobMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListBuildsResponse parses an HTTP response from a ListBuildsWithResponse call
func ParseListBuildsResponse(rsp *http.Response) (*ListBuildsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListBuildsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Builds        *[]Build `json:"builds,omitempty"`
			NextPageToken *string  `json:"nextPageToken,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetBuildResponse parses an HTTP response from a GetBuildWithResponse call
func ParseGetBuildResponse(rsp *http.Response) (*GetBuildResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBuildResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Build
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListExperienceTagsResponse parses an HTTP response from a ListExperienceTagsWithResponse call
func ParseListExperienceTagsResponse(rsp *http.Response) (*ListExperienceTagsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListExperienceTagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			ExperienceTags *[]ExperienceTag `json:"experienceTags,omitempty"`
			NextPageToken  *string          `json:"nextPageToken,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateExperienceTagResponse parses an HTTP response from a CreateExperienceTagWithResponse call
func ParseCreateExperienceTagResponse(rsp *http.Response) (*CreateExperienceTagResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateExperienceTagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ExperienceTag
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseDeleteExperienceTagResponse parses an HTTP response from a DeleteExperienceTagWithResponse call
func ParseDeleteExperienceTagResponse(rsp *http.Response) (*DeleteExperienceTagResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteExperienceTagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetExperienceTagResponse parses an HTTP response from a GetExperienceTagWithResponse call
func ParseGetExperienceTagResponse(rsp *http.Response) (*GetExperienceTagResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetExperienceTagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ExperienceTag
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateExperienceTagResponse parses an HTTP response from a UpdateExperienceTagWithResponse call
func ParseUpdateExperienceTagResponse(rsp *http.Response) (*UpdateExperienceTagResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateExperienceTagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ExperienceTag
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListExperiencesWithExperienceTagResponse parses an HTTP response from a ListExperiencesWithExperienceTagWithResponse call
func ParseListExperiencesWithExperienceTagResponse(rsp *http.Response) (*ListExperiencesWithExperienceTagResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListExperiencesWithExperienceTagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Experiences   *[]Experience `json:"experiences,omitempty"`
			NextPageToken *string       `json:"nextPageToken,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRemoveExperienceTagFromExperienceResponse parses an HTTP response from a RemoveExperienceTagFromExperienceWithResponse call
func ParseRemoveExperienceTagFromExperienceResponse(rsp *http.Response) (*RemoveExperienceTagFromExperienceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveExperienceTagFromExperienceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAddExperienceTagToExperienceResponse parses an HTTP response from a AddExperienceTagToExperienceWithResponse call
func ParseAddExperienceTagToExperienceResponse(rsp *http.Response) (*AddExperienceTagToExperienceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddExperienceTagToExperienceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListExperiencesResponse parses an HTTP response from a ListExperiencesWithResponse call
func ParseListExperiencesResponse(rsp *http.Response) (*ListExperiencesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListExperiencesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Experiences   *[]Experience `json:"experiences,omitempty"`
			NextPageToken *string       `json:"nextPageToken,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateExperienceResponse parses an HTTP response from a CreateExperienceWithResponse call
func ParseCreateExperienceResponse(rsp *http.Response) (*CreateExperienceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateExperienceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Experience
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseDeleteExperienceResponse parses an HTTP response from a DeleteExperienceWithResponse call
func ParseDeleteExperienceResponse(rsp *http.Response) (*DeleteExperienceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteExperienceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetExperienceResponse parses an HTTP response from a GetExperienceWithResponse call
func ParseGetExperienceResponse(rsp *http.Response) (*GetExperienceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetExperienceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Experience
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateExperienceResponse parses an HTTP response from a UpdateExperienceWithResponse call
func ParseUpdateExperienceResponse(rsp *http.Response) (*UpdateExperienceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateExperienceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Experience
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListExperienceTagsForExperienceResponse parses an HTTP response from a ListExperienceTagsForExperienceWithResponse call
func ParseListExperienceTagsForExperienceResponse(rsp *http.Response) (*ListExperienceTagsForExperienceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListExperienceTagsForExperienceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			ExperienceTags *[]ExperienceTag `json:"experienceTags,omitempty"`
			NextPageToken  *string          `json:"nextPageToken,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseHealthResponse parses an HTTP response from a HealthWithResponse call
func ParseHealthResponse(rsp *http.Response) (*HealthResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HealthResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListProjectsResponse parses an HTTP response from a ListProjectsWithResponse call
func ParseListProjectsResponse(rsp *http.Response) (*ListProjectsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListProjectsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			NextPageToken *string    `json:"nextPageToken,omitempty"`
			Projects      *[]Project `json:"projects,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateProjectResponse parses an HTTP response from a CreateProjectWithResponse call
func ParseCreateProjectResponse(rsp *http.Response) (*CreateProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Project
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseDeleteProjectResponse parses an HTTP response from a DeleteProjectWithResponse call
func ParseDeleteProjectResponse(rsp *http.Response) (*DeleteProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetProjectResponse parses an HTTP response from a GetProjectWithResponse call
func ParseGetProjectResponse(rsp *http.Response) (*GetProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Project
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateProjectResponse parses an HTTP response from a UpdateProjectWithResponse call
func ParseUpdateProjectResponse(rsp *http.Response) (*UpdateProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Project
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListBranchesForProjectResponse parses an HTTP response from a ListBranchesForProjectWithResponse call
func ParseListBranchesForProjectResponse(rsp *http.Response) (*ListBranchesForProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListBranchesForProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Branches      *[]Branch `json:"branches,omitempty"`
			NextPageToken *string   `json:"nextPageToken,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateBranchForProjectResponse parses an HTTP response from a CreateBranchForProjectWithResponse call
func ParseCreateBranchForProjectResponse(rsp *http.Response) (*CreateBranchForProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBranchForProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Branch
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseDeleteBranchForProjectResponse parses an HTTP response from a DeleteBranchForProjectWithResponse call
func ParseDeleteBranchForProjectResponse(rsp *http.Response) (*DeleteBranchForProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteBranchForProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetBranchForProjectResponse parses an HTTP response from a GetBranchForProjectWithResponse call
func ParseGetBranchForProjectResponse(rsp *http.Response) (*GetBranchForProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBranchForProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Branch
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListBuildsForBranchResponse parses an HTTP response from a ListBuildsForBranchWithResponse call
func ParseListBuildsForBranchResponse(rsp *http.Response) (*ListBuildsForBranchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListBuildsForBranchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Builds        *[]Build `json:"builds,omitempty"`
			NextPageToken *string  `json:"nextPageToken,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateBuildForBranchResponse parses an HTTP response from a CreateBuildForBranchWithResponse call
func ParseCreateBuildForBranchResponse(rsp *http.Response) (*CreateBuildForBranchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBuildForBranchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Build
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseDeleteBuildForBranchResponse parses an HTTP response from a DeleteBuildForBranchWithResponse call
func ParseDeleteBuildForBranchResponse(rsp *http.Response) (*DeleteBuildForBranchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteBuildForBranchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetBuildForBranchResponse parses an HTTP response from a GetBuildForBranchWithResponse call
func ParseGetBuildForBranchResponse(rsp *http.Response) (*GetBuildForBranchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBuildForBranchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Build
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListBatchesForBuildResponse parses an HTTP response from a ListBatchesForBuildWithResponse call
func ParseListBatchesForBuildResponse(rsp *http.Response) (*ListBatchesForBuildResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListBatchesForBuildResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Batches       *[]Batch `json:"batches,omitempty"`
			NextPageToken *string  `json:"nextPageToken,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDestroySandboxResponse parses an HTTP response from a DestroySandboxWithResponse call
func ParseDestroySandboxResponse(rsp *http.Response) (*DestroySandboxResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DestroySandboxResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetupSandboxResponse parses an HTTP response from a SetupSandboxWithResponse call
func ParseSetupSandboxResponse(rsp *http.Response) (*SetupSandboxResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetupSandboxResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListViewSessionsResponse parses an HTTP response from a ListViewSessionsWithResponse call
func ParseListViewSessionsResponse(rsp *http.Response) (*ListViewSessionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListViewSessionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			NextPageToken *string       `json:"nextPageToken,omitempty"`
			ViewSessions  *[]ViewObject `json:"viewSessions,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateViewSessionResponse parses an HTTP response from a CreateViewSessionWithResponse call
func ParseCreateViewSessionResponse(rsp *http.Response) (*CreateViewSessionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateViewSessionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ViewSessionID
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseGetViewSessionResponse parses an HTTP response from a GetViewSessionWithResponse call
func ParseGetViewSessionResponse(rsp *http.Response) (*GetViewSessionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetViewSessionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			ViewMetadata *[]ViewMetadata `json:"viewMetadata,omitempty"`
			ViewObject   *ViewObject     `json:"viewObject,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateViewUpdateResponse parses an HTTP response from a CreateViewUpdateWithResponse call
func ParseCreateViewUpdateResponse(rsp *http.Response) (*CreateViewUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateViewUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Id   *ViewSessionID `json:"id,omitempty"`
			Mcap *McapURL       `json:"mcap,omitempty"`

			// View A link to view the session.
			View *string `json:"view,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}
