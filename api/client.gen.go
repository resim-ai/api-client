// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.13.4 DO NOT EDIT.
package api

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	openapi_types "github.com/deepmap/oapi-codegen/pkg/types"
)

const (
	OAuthScopes = "OAuth.Scopes"
)

// Defines values for BatchStatus.
const (
	BatchStatusBATCHMETRICSQUEUED  BatchStatus = "BATCH_METRICS_QUEUED"
	BatchStatusBATCHMETRICSRUNNING BatchStatus = "BATCH_METRICS_RUNNING"
	BatchStatusCANCELLED           BatchStatus = "CANCELLED"
	BatchStatusERROR               BatchStatus = "ERROR"
	BatchStatusEXPERIENCESRUNNING  BatchStatus = "EXPERIENCES_RUNNING"
	BatchStatusSUBMITTED           BatchStatus = "SUBMITTED"
	BatchStatusSUCCEEDED           BatchStatus = "SUCCEEDED"
)

// Defines values for BatchType.
const (
	DEBUGEXPERIENCE BatchType = "DEBUG_EXPERIENCE"
	NORMAL          BatchType = "NORMAL"
)

// Defines values for BranchType.
const (
	CHANGEREQUEST BranchType = "CHANGE_REQUEST"
	MAIN          BranchType = "MAIN"
	RELEASE       BranchType = "RELEASE"
)

// Defines values for CompareBatchesStatusFilter.
const (
	BOTHFAILING CompareBatchesStatusFilter = "BOTH_FAILING"
	BOTHPASSING CompareBatchesStatusFilter = "BOTH_PASSING"
	ONEFAILING  CompareBatchesStatusFilter = "ONE_FAILING"
)

// Defines values for ConflatedJobStatus.
const (
	ConflatedJobStatusBLOCKER   ConflatedJobStatus = "BLOCKER"
	ConflatedJobStatusCANCELLED ConflatedJobStatus = "CANCELLED"
	ConflatedJobStatusERROR     ConflatedJobStatus = "ERROR"
	ConflatedJobStatusPASSED    ConflatedJobStatus = "PASSED"
	ConflatedJobStatusQUEUED    ConflatedJobStatus = "QUEUED"
	ConflatedJobStatusRUNNING   ConflatedJobStatus = "RUNNING"
	ConflatedJobStatusWARNING   ConflatedJobStatus = "WARNING"
)

// Defines values for EventTimestampType.
const (
	ABSOLUTE EventTimestampType = "ABSOLUTE"
	RELATIVE EventTimestampType = "RELATIVE"
)

// Defines values for ExecutionStep.
const (
	BATCHMETRICS ExecutionStep = "BATCH_METRICS"
	EXPERIENCE   ExecutionStep = "EXPERIENCE"
	METRICS      ExecutionStep = "METRICS"
	REPORT       ExecutionStep = "REPORT"
)

// Defines values for JobStatus.
const (
	JobStatusCANCELLED         JobStatus = "CANCELLED"
	JobStatusERROR             JobStatus = "ERROR"
	JobStatusEXPERIENCERUNNING JobStatus = "EXPERIENCE_RUNNING"
	JobStatusMETRICSQUEUED     JobStatus = "METRICS_QUEUED"
	JobStatusMETRICSRUNNING    JobStatus = "METRICS_RUNNING"
	JobStatusSUBMITTED         JobStatus = "SUBMITTED"
	JobStatusSUCCEEDED         JobStatus = "SUCCEEDED"
)

// Defines values for LogType.
const (
	ARCHIVELOG       LogType = "ARCHIVE_LOG"
	CONTAINERLOG     LogType = "CONTAINER_LOG"
	EMISSIONSLOG     LogType = "EMISSIONS_LOG"
	ERRORLOG         LogType = "ERROR_LOG"
	EXECUTIONLOG     LogType = "EXECUTION_LOG"
	FOXGLOVEMCAPLOG  LogType = "FOXGLOVE_MCAP_LOG"
	MCAPLOG          LogType = "MCAP_LOG"
	METRICSOUTPUTLOG LogType = "METRICS_OUTPUT_LOG"
	MP4LOG           LogType = "MP4_LOG"
	OTHERLOG         LogType = "OTHER_LOG"
	RERUNIOLOG       LogType = "RERUN_IO_LOG"
	SERVICELOG       LogType = "SERVICE_LOG"
)

// Defines values for MetricStatus.
const (
	FAILBLOCK        MetricStatus = "FAIL_BLOCK"
	FAILWARN         MetricStatus = "FAIL_WARN"
	NOSTATUSREPORTED MetricStatus = "NO_STATUS_REPORTED"
	NOTAPPLICABLE    MetricStatus = "NOT_APPLICABLE"
	PASSED           MetricStatus = "PASSED"
	RAW              MetricStatus = "RAW"
)

// Defines values for MetricType.
const (
	COMPOSITE MetricType = "COMPOSITE"
	SCALAR    MetricType = "SCALAR"
)

// Defines values for MetricsDataType.
const (
	EXTERNALFILE MetricsDataType = "EXTERNAL_FILE"
	STANDARD     MetricsDataType = "STANDARD"
)

// Defines values for ObjectType.
const (
	TYPEDCURVESE3    ObjectType = "TYPE_DCURVE_SE3"
	TYPEFRAME        ObjectType = "TYPE_FRAME"
	TYPEFRAMEDVECTOR ObjectType = "TYPE_FRAMED_VECTOR"
	TYPESE3          ObjectType = "TYPE_SE3"
	TYPESO3          ObjectType = "TYPE_SO3"
	TYPETCURVESE3    ObjectType = "TYPE_TCURVE_SE3"
	TYPETRAJECTORY   ObjectType = "TYPE_TRAJECTORY"
)

// Defines values for ParameterSweepStatus.
const (
	ParameterSweepStatusCANCELLED ParameterSweepStatus = "CANCELLED"
	ParameterSweepStatusERROR     ParameterSweepStatus = "ERROR"
	ParameterSweepStatusRUNNING   ParameterSweepStatus = "RUNNING"
	ParameterSweepStatusSUBMITTED ParameterSweepStatus = "SUBMITTED"
	ParameterSweepStatusSUCCEEDED ParameterSweepStatus = "SUCCEEDED"
)

// Defines values for ReportStatus.
const (
	ReportStatusERROR     ReportStatus = "ERROR"
	ReportStatusRUNNING   ReportStatus = "RUNNING"
	ReportStatusSUBMITTED ReportStatus = "SUBMITTED"
	ReportStatusSUCCEEDED ReportStatus = "SUCCEEDED"
)

// Defines values for TriggeredVia.
const (
	GITHUB TriggeredVia = "GITHUB"
	GITLAB TriggeredVia = "GITLAB"
	LOCAL  TriggeredVia = "LOCAL"
	WEBAPP TriggeredVia = "WEBAPP"
)

// Defines values for ListExperienceTagsParamsOrderBy.
const (
	ListExperienceTagsParamsOrderById        ListExperienceTagsParamsOrderBy = "id"
	ListExperienceTagsParamsOrderByRank      ListExperienceTagsParamsOrderBy = "rank"
	ListExperienceTagsParamsOrderByTimestamp ListExperienceTagsParamsOrderBy = "timestamp"
)

// AddSuitesToExperiencesInput defines model for addSuitesToExperiencesInput.
type AddSuitesToExperiencesInput struct {
	AllExperiences *bool                  `json:"allExperiences,omitempty"`
	Experiences    *[]ExperienceID        `json:"experiences,omitempty"`
	Filters        *ExperienceFilterInput `json:"filters,omitempty"`
	TestSuiteIDs   []TestSuiteID          `json:"testSuiteIDs"`
}

// AddTagsToExperiencesInput defines model for addTagsToExperiencesInput.
type AddTagsToExperiencesInput struct {
	AllExperiences   *bool                  `json:"allExperiences,omitempty"`
	ExperienceTagIDs []ExperienceTagID      `json:"experienceTagIDs"`
	Experiences      *[]ExperienceID        `json:"experiences,omitempty"`
	Filters          *ExperienceFilterInput `json:"filters,omitempty"`
}

// Archived defines model for archived.
type Archived = bool

// AssociatedAccount defines model for associatedAccount.
type AssociatedAccount = string

// Batch defines model for batch.
type Batch struct {
	AdhocTestSuite          *bool                   `json:"adhocTestSuite,omitempty"`
	AllowableFailurePercent *int                    `json:"allowable_failure_percent,omitempty"`
	AssociatedAccount       AssociatedAccount       `json:"associatedAccount"`
	BatchID                 *BatchID                `json:"batchID,omitempty"`
	BatchMetricsStatus      *MetricStatus           `json:"batchMetricsStatus,omitempty"`
	BatchType               *BatchType              `json:"batchType,omitempty"`
	BranchID                *BranchID               `json:"branchID,omitempty"`
	BuildID                 *BuildID                `json:"buildID,omitempty"`
	CreationTimestamp       *Timestamp              `json:"creationTimestamp,omitempty"`
	Description             *string                 `json:"description,omitempty"`
	ExecutionError          *ExecutionError         `json:"executionError,omitempty"`
	ExecutionErrors         *[]ExecutionError       `json:"executionErrors"`
	FriendlyName            *FriendlyName           `json:"friendlyName,omitempty"`
	JobMetricsStatusCounts  *JobMetricsStatusCounts `json:"jobMetricsStatusCounts,omitempty"`
	JobStatusCounts         *BatchJobStatusCounts   `json:"jobStatusCounts,omitempty"`
	JobsMetricsStatus       *MetricStatus           `json:"jobsMetricsStatus,omitempty"`
	LastRunTimestamp        *Timestamp              `json:"lastRunTimestamp,omitempty"`
	LastUpdatedTimestamp    *Timestamp              `json:"lastUpdatedTimestamp,omitempty"`
	MetricsBuildID          *MetricsBuildID         `json:"metricsBuildID,omitempty"`
	MetricsSetName          *MetricsSetName         `json:"metricsSetName"`
	OrgID                   *OrgID                  `json:"orgID,omitempty"`
	OverallMetricsStatus    *MetricStatus           `json:"overallMetricsStatus,omitempty"`
	Parameters              *BatchParameters        `json:"parameters,omitempty"`
	PoolLabels              *PoolLabels             `json:"poolLabels,omitempty"`
	ProjectID               *ProjectID              `json:"projectID,omitempty"`
	RunCounter              *RunCounter             `json:"runCounter,omitempty"`
	Status                  *BatchStatus            `json:"status,omitempty"`
	StatusHistory           *BatchStatusHistory     `json:"statusHistory,omitempty"`
	SystemID                *SystemID               `json:"systemID,omitempty"`
	TestSuiteID             *TestSuiteID            `json:"testSuiteID,omitempty"`
	TestSuiteRevision       *TestSuiteRevision      `json:"testSuiteRevision,omitempty"`
	TotalJobs               *BatchTotalJobs         `json:"totalJobs,omitempty"`
	UserID                  *UserID                 `json:"userID,omitempty"`
}

// BatchID defines model for batchID.
type BatchID = openapi_types.UUID

// BatchInput defines model for batchInput.
type BatchInput struct {
	AllowableFailurePercent *int                    `json:"allowableFailurePercent"`
	AssociatedAccount       *AssociatedAccount      `json:"associatedAccount,omitempty"`
	BatchName               *Name                   `json:"batchName,omitempty"`
	BuildID                 *BuildID                `json:"buildID,omitempty"`
	ExcludedExperienceIDs   *[]ExcludedExperienceID `json:"excludedExperienceIDs"`
	ExperienceIDs           *[]ExperienceID         `json:"experienceIDs"`
	ExperienceNames         *[]ExperienceName       `json:"experienceNames"`
	ExperienceTagIDs        *[]ExperienceTagID      `json:"experienceTagIDs"`
	ExperienceTagNames      *[]ExperienceTagName    `json:"experienceTagNames"`
	Filters                 *ExperienceFilterInput  `json:"filters,omitempty"`
	MetricsBuildID          *MetricsBuildID         `json:"metricsBuildID,omitempty"`
	MetricsSetName          *MetricsSetName         `json:"metricsSetName"`
	Parameters              *BatchParameters        `json:"parameters,omitempty"`
	PoolLabels              *PoolLabels             `json:"poolLabels,omitempty"`
	TriggeredVia            *TriggeredVia           `json:"triggeredVia,omitempty"`
}

// BatchJobStatusCounts defines model for batchJobStatusCounts.
type BatchJobStatusCounts struct {
	Cancelled      int `json:"cancelled"`
	Error          int `json:"error"`
	MetricsQueued  int `json:"metricsQueued"`
	MetricsRunning int `json:"metricsRunning"`
	Running        int `json:"running"`
	Submitted      int `json:"submitted"`
	Succeeded      int `json:"succeeded"`
}

// BatchLog defines model for batchLog.
type BatchLog struct {
	BatchID           *BatchID       `json:"batchID,omitempty"`
	Checksum          *Checksum      `json:"checksum,omitempty"`
	CreationTimestamp *Timestamp     `json:"creationTimestamp,omitempty"`
	ExecutionStep     *ExecutionStep `json:"executionStep,omitempty"`
	FileName          *FileName      `json:"fileName,omitempty"`
	FileSize          *FileSize      `json:"fileSize,omitempty"`
	Location          *LogLocation   `json:"location,omitempty"`
	LogID             *LogID         `json:"logID,omitempty"`
	LogOutputLocation *string        `json:"logOutputLocation,omitempty"`
	LogType           *LogType       `json:"logType,omitempty"`
	OrgID             *OrgID         `json:"orgID,omitempty"`
	UserID            *UserID        `json:"userID,omitempty"`
}

// BatchMetric defines model for batchMetric.
type BatchMetric struct {
	BatchID           *BatchID         `json:"batchID,omitempty"`
	CreationTimestamp *Timestamp       `json:"creationTimestamp,omitempty"`
	DataIDs           *[]MetricsDataID `json:"dataIDs,omitempty"`

	// EventMetric true if this metric is for an event
	EventMetric  *bool           `json:"eventMetric,omitempty"`
	FileLocation *MetricLocation `json:"fileLocation,omitempty"`
	MetricID     *MetricID       `json:"metricID,omitempty"`
	MetricURL    *MetricURL      `json:"metricURL,omitempty"`
	Name         *MetricName     `json:"name,omitempty"`
	OrgID        *OrgID          `json:"orgID,omitempty"`
	ProjectID    *ProjectID      `json:"projectID,omitempty"`
	Status       *MetricStatus   `json:"status,omitempty"`
	Type         *MetricType     `json:"type,omitempty"`
	Unit         *string         `json:"unit"`
	UserID       *UserID         `json:"userID,omitempty"`
	Value        *MetricValue    `json:"value"`
}

// BatchMetricsData defines model for batchMetricsData.
type BatchMetricsData struct {
	BatchID           *BatchID             `json:"batchID,omitempty"`
	CreationTimestamp *Timestamp           `json:"creationTimestamp,omitempty"`
	DataID            *MetricsDataID       `json:"dataID,omitempty"`
	FileLocation      *MetricsDataLocation `json:"fileLocation,omitempty"`
	Filename          *string              `json:"filename"`
	MetricsDataType   *MetricsDataType     `json:"metricsDataType,omitempty"`
	MetricsDataURL    *MetricsDataURL      `json:"metricsDataURL,omitempty"`
	Name              *string              `json:"name,omitempty"`
	OrgID             *OrgID               `json:"orgID,omitempty"`
	UserID            *UserID              `json:"userID,omitempty"`
}

// BatchMetricsDataAndIDs defines model for batchMetricsDataAndIDs.
type BatchMetricsDataAndIDs struct {
	BatchMetricID    *MetricID         `json:"batchMetricID,omitempty"`
	BatchMetricsData *BatchMetricsData `json:"batchMetricsData,omitempty"`
}

// BatchParameters defines model for batchParameters.
type BatchParameters map[string]string

// BatchStatus defines model for batchStatus.
type BatchStatus string

// BatchStatusHistory defines model for batchStatusHistory.
type BatchStatusHistory = []BatchStatusHistoryType

// BatchStatusHistoryType defines model for batchStatusHistoryType.
type BatchStatusHistoryType struct {
	Status    *BatchStatus `json:"status,omitempty"`
	UpdatedAt *Timestamp   `json:"updatedAt,omitempty"`
}

// BatchSuggestionsOutput defines model for batchSuggestionsOutput.
type BatchSuggestionsOutput struct {
	LastPassingOnBranch *Batch `json:"lastPassingOnBranch"`
	LastPassingOnMain   *Batch `json:"lastPassingOnMain"`
	LatestOnBranch      *Batch `json:"latestOnBranch"`
	LatestOnMain        *Batch `json:"latestOnMain"`
}

// BatchTotalJobs defines model for batchTotalJobs.
type BatchTotalJobs = int

// BatchType defines model for batchType.
type BatchType string

// Branch defines model for branch.
type Branch struct {
	BranchID          BranchID   `json:"branchID"`
	BranchType        BranchType `json:"branchType"`
	CreationTimestamp Timestamp  `json:"creationTimestamp"`
	Name              string     `json:"name"`
	OrgID             OrgID      `json:"orgID"`
	ProjectID         ProjectID  `json:"projectID"`
	UserID            UserID     `json:"userID"`
}

// BranchID defines model for branchID.
type BranchID = openapi_types.UUID

// BranchType defines model for branchType.
type BranchType string

// Build defines model for build.
type Build struct {
	AssociatedAccount AssociatedAccount `json:"associatedAccount"`
	BranchID          BranchID          `json:"branchID"`
	BuildID           BuildID           `json:"buildID"`

	// BuildSpecification Build spec in YAML format.
	BuildSpecification BuildSpecificationOutput `json:"buildSpecification"`
	CreationTimestamp  Timestamp                `json:"creationTimestamp"`

	// Description The description of the build. May be a SHA or commit message.
	// Deprecated:
	Description BuildDescription `json:"description"`
	ImageUri    BuildImageUri    `json:"imageUri"`

	// Name The name of the build.
	Name      BuildName    `json:"name"`
	OrgID     OrgID        `json:"orgID"`
	ProjectID ProjectID    `json:"projectID"`
	SystemID  SystemID     `json:"systemID"`
	UserID    UserID       `json:"userID"`
	Version   BuildVersion `json:"version"`
}

// BuildDescription The description of the build. May be a SHA or commit message.
type BuildDescription = string

// BuildID defines model for buildID.
type BuildID = openapi_types.UUID

// BuildImageUri defines model for buildImageUri.
type BuildImageUri = string

// BuildName The name of the build.
type BuildName = string

// BuildSpecificationInput defines model for buildSpecificationInput.
type BuildSpecificationInput = []byte

// BuildSpecificationOutput Build spec in YAML format.
type BuildSpecificationOutput = string

// BuildVersion defines model for buildVersion.
type BuildVersion = string

// Checksum defines model for checksum.
type Checksum = string

// CompareBatchTest defines model for compareBatchTest.
type CompareBatchTest struct {
	ExperienceID   ExperienceID             `json:"experienceID"`
	ExperienceName ExperienceName           `json:"experienceName"`
	FromTest       *CompareBatchTestDetails `json:"fromTest"`
	ToTest         *CompareBatchTestDetails `json:"toTest"`
}

// CompareBatchTestDetails defines model for compareBatchTestDetails.
type CompareBatchTestDetails struct {
	JobID JobID `json:"jobID"`

	// NumMetrics The number of failblock/failwarn/passing metrics (based on job's status). Otherwise this will be null
	NumMetrics *int               `json:"numMetrics"`
	Status     ConflatedJobStatus `json:"status"`
}

// CompareBatchesOutput defines model for compareBatchesOutput.
type CompareBatchesOutput struct {
	NextPageToken string             `json:"nextPageToken"`
	Tests         []CompareBatchTest `json:"tests"`
	Total         int                `json:"total"`
}

// CompareBatchesStatusFilter defines model for compareBatchesStatusFilter.
type CompareBatchesStatusFilter string

// ConflatedJobStatus defines model for conflatedJobStatus.
type ConflatedJobStatus string

// CreateBranchInput defines model for createBranchInput.
type CreateBranchInput struct {
	BranchType BranchType `json:"branchType"`
	Name       string     `json:"name"`
}

// CreateBuildForBranchInput defines model for createBuildForBranchInput.
type CreateBuildForBranchInput struct {
	AssociatedAccount  *AssociatedAccount       `json:"associatedAccount,omitempty"`
	BuildSpecification *BuildSpecificationInput `json:"buildSpecification,omitempty"`

	// Description The description of the build. May be a SHA or commit message.
	// Deprecated:
	Description *BuildDescription `json:"description,omitempty"`
	ImageUri    *BuildImageUri    `json:"imageUri,omitempty"`

	// Name The name of the build.
	Name     *BuildName   `json:"name,omitempty"`
	SystemID SystemID     `json:"systemID"`
	Version  BuildVersion `json:"version"`
	union    json.RawMessage
}

// CreateBuildForBranchInput0 defines model for .
type CreateBuildForBranchInput0 = interface{}

// CreateBuildForBranchInput1 defines model for .
type CreateBuildForBranchInput1 = interface{}

// CreateBuildForSystemInput defines model for createBuildForSystemInput.
type CreateBuildForSystemInput struct {
	AssociatedAccount  *AssociatedAccount       `json:"associatedAccount,omitempty"`
	BranchID           BranchID                 `json:"branchID"`
	BuildSpecification *BuildSpecificationInput `json:"buildSpecification,omitempty"`

	// Description The description of the build. May be a SHA or commit message.
	// Deprecated:
	Description *BuildDescription `json:"description,omitempty"`
	ImageUri    *BuildImageUri    `json:"imageUri,omitempty"`

	// Name The name of the build.
	Name         *BuildName    `json:"name,omitempty"`
	TriggeredVia *TriggeredVia `json:"triggeredVia,omitempty"`
	Version      BuildVersion  `json:"version"`
	union        json.RawMessage
}

// CreateBuildForSystemInput0 defines model for .
type CreateBuildForSystemInput0 = interface{}

// CreateBuildForSystemInput1 defines model for .
type CreateBuildForSystemInput1 = interface{}

// CreateExperienceInput defines model for createExperienceInput.
type CreateExperienceInput struct {
	// CacheExempt If true, the experience will not be cached.
	CacheExempt             *bool                  `json:"cacheExempt,omitempty"`
	ContainerTimeoutSeconds *int32                 `json:"containerTimeoutSeconds,omitempty"`
	Description             string                 `json:"description"`
	EnvironmentVariables    *[]EnvironmentVariable `json:"environmentVariables,omitempty"`
	ExperienceTagIDs        *[]ExperienceTagID     `json:"experienceTagIDs,omitempty"`

	// Location [DEPRECATED] This field was previously used to define an experience's location. Experiences can now be defined with multiple locations, using the locations field. This field will be removed in a later release.
	// Deprecated:
	Location  *string        `json:"location,omitempty"`
	Locations *[]string      `json:"locations,omitempty"`
	Name      ExperienceName `json:"name"`
	Profile   *Profile       `json:"profile,omitempty"`
	SystemIDs *[]SystemID    `json:"systemIDs,omitempty"`
}

// CreateExperienceTagInput defines model for createExperienceTagInput.
type CreateExperienceTagInput struct {
	Description string            `json:"description"`
	Name        ExperienceTagName `json:"name"`
}

// CreateMetricsBuildInput defines model for createMetricsBuildInput.
type CreateMetricsBuildInput struct {
	ImageUri MetricsBuildImageUri `json:"imageUri"`
	Name     MetricsBuildName     `json:"name"`
	Version  MetricsBuildVersion  `json:"version"`
}

// CreateProjectInput defines model for createProjectInput.
type CreateProjectInput struct {
	Description string `json:"description"`
	Name        string `json:"name"`
}

// CreateSystemInput defines model for createSystemInput.
type CreateSystemInput struct {
	BuildGpus                  int    `json:"build_gpus"`
	BuildMemoryMib             int    `json:"build_memory_mib"`
	BuildSharedMemoryMb        int    `json:"build_shared_memory_mb"`
	BuildVcpus                 int    `json:"build_vcpus"`
	Description                string `json:"description"`
	MetricsBuildGpus           int    `json:"metrics_build_gpus"`
	MetricsBuildMemoryMib      int    `json:"metrics_build_memory_mib"`
	MetricsBuildSharedMemoryMb int    `json:"metrics_build_shared_memory_mb"`
	MetricsBuildVcpus          int    `json:"metrics_build_vcpus"`
	Name                       string `json:"name"`
}

// CreateTestSuiteInput defines model for createTestSuiteInput.
type CreateTestSuiteInput struct {
	AllExperiences        *bool                   `json:"allExperiences,omitempty"`
	Description           TestSuiteDescription    `json:"description"`
	ExcludedExperienceIDs *[]ExcludedExperienceID `json:"excludedExperienceIDs,omitempty"`
	Experiences           []ExperienceID          `json:"experiences"`
	Filters               *ExperienceFilterInput  `json:"filters,omitempty"`
	MetricsBuildID        *MetricsBuildID         `json:"metricsBuildID,omitempty"`
	MetricsSetName        *MetricsSetName         `json:"metricsSetName"`
	Name                  TestSuiteName           `json:"name"`
	ShowOnSummary         *bool                   `json:"showOnSummary,omitempty"`
	SummaryReferenceDate  *Timestamp              `json:"summaryReferenceDate,omitempty"`
	SystemID              SystemID                `json:"systemID"`
}

// CustomMetric defines model for customMetric.
type CustomMetric struct {
	Name  string  `json:"name"`
	Unit  *string `json:"unit,omitempty"`
	Value float64 `json:"value"`
}

// DebugExperienceInput defines model for debugExperienceInput.
type DebugExperienceInput struct {
	BatchID     *BatchID     `json:"batchID,omitempty"`
	BuildID     *BuildID     `json:"buildID,omitempty"`
	PoolLabels  *PoolLabels  `json:"poolLabels,omitempty"`
	TestSuiteID *TestSuiteID `json:"testSuiteID,omitempty"`
}

// DebugExperienceOutput defines model for debugExperienceOutput.
type DebugExperienceOutput struct {
	BatchID         *BatchID `json:"batchID,omitempty"`
	ClusterCAData   *string  `json:"clusterCAData,omitempty"`
	ClusterEndpoint *string  `json:"clusterEndpoint,omitempty"`
	ClusterToken    *string  `json:"clusterToken,omitempty"`
	Namespace       *string  `json:"namespace,omitempty"`
}

// EnvironmentVariable defines model for environmentVariable.
type EnvironmentVariable struct {
	Name  string `json:"name"`
	Value string `json:"value"`
}

// Event defines model for event.
type Event struct {
	CreationTimestamp Timestamp          `json:"creationTimestamp"`
	Description       string             `json:"description"`
	EventID           EventID            `json:"eventID"`
	MetricsIDs        []MetricID         `json:"metricsIDs"`
	Name              string             `json:"name"`
	Status            MetricStatus       `json:"status"`
	Tags              EventTags          `json:"tags"`
	Timestamp         Timestamp          `json:"timestamp"`
	TimestampType     EventTimestampType `json:"timestampType"`
}

// EventID defines model for eventID.
type EventID = openapi_types.UUID

// EventTags defines model for eventTags.
type EventTags = []string

// EventTimestampType defines model for eventTimestampType.
type EventTimestampType string

// ExcludedExperienceID defines model for excludedExperienceID.
type ExcludedExperienceID = openapi_types.UUID

// ExecutionError defines model for executionError.
type ExecutionError struct {
	// ErrorCode Standardized error code (e.g., UNKNOWN_ERROR, NONZERO_EXIT_CODE)
	ErrorCode string `json:"errorCode"`

	// ErrorText Error text
	ErrorText *string `json:"errorText,omitempty"`

	// Metadata Error metadata
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// ParentID ID of the parent object (e.g., job ID, batch ID)
	ParentID *openapi_types.UUID `json:"parentID,omitempty"`

	// ParentType Type of the parent object (e.g., JOB, BATCH)
	ParentType *string `json:"parentType,omitempty"`

	// RunCounter Run counter of the error
	RunCounter *int `json:"runCounter,omitempty"`
}

// ExecutionStep defines model for executionStep.
type ExecutionStep string

// Experience defines model for experience.
type Experience struct {
	Archived                bool                  `json:"archived"`
	CacheExempt             bool                  `json:"cacheExempt"`
	ContainerTimeoutSeconds int32                 `json:"containerTimeoutSeconds"`
	CreationTimestamp       Timestamp             `json:"creationTimestamp"`
	Description             string                `json:"description"`
	EnvironmentVariables    []EnvironmentVariable `json:"environmentVariables"`
	ExperienceID            ExperienceID          `json:"experienceID"`

	// Location [DEPRECATED] This field was previously used to report an experience's location. Experiences can now be defined with multiple locations, this field will display the first location; this field will be removed in a future version.
	// Deprecated:
	Location  string         `json:"location"`
	Locations []string       `json:"locations"`
	Name      ExperienceName `json:"name"`
	OrgID     OrgID          `json:"orgID"`
	Profile   Profile        `json:"profile"`
	ProjectID ProjectID      `json:"projectID"`
	UserID    UserID         `json:"userID"`
}

// ExperienceFilterInput defines model for experienceFilterInput.
type ExperienceFilterInput struct {
	// Name Filter experiences by name
	Name *string `json:"name,omitempty"`

	// Search A search query. Supports searching by tag_id
	Search *string `json:"search,omitempty"`

	// Text Filter experiences by a text string on name and description
	Text *string `json:"text,omitempty"`
}

// ExperienceID defines model for experienceID.
type ExperienceID = openapi_types.UUID

// ExperienceLocation defines model for experienceLocation.
type ExperienceLocation struct {
	Location *string `json:"location,omitempty"`
}

// ExperienceLocationContents defines model for experienceLocationContents.
type ExperienceLocationContents struct {
	IsCloud     *bool     `json:"isCloud,omitempty"`
	ObjectCount *int      `json:"objectCount,omitempty"`
	Objects     *[]string `json:"objects,omitempty"`
}

// ExperienceName defines model for experienceName.
type ExperienceName = string

// ExperienceTag defines model for experienceTag.
type ExperienceTag struct {
	CreationTimestamp Timestamp         `json:"creationTimestamp"`
	Description       string            `json:"description"`
	ExperienceTagID   ExperienceTagID   `json:"experienceTagID"`
	Name              ExperienceTagName `json:"name"`
	OrgID             OrgID             `json:"orgID"`
	ProjectID         ProjectID         `json:"projectID"`
	UserID            UserID            `json:"userID"`
}

// ExperienceTagID defines model for experienceTagID.
type ExperienceTagID = openapi_types.UUID

// ExperienceTagName defines model for experienceTagName.
type ExperienceTagName = string

// FileName defines model for fileName.
type FileName = string

// FileSize defines model for fileSize.
type FileSize = int64

// FirstBuildMetric The first batch metric in the sequence, and some info about how it has changed
type FirstBuildMetric struct {
	Delta float64   `json:"delta"`
	Time  Timestamp `json:"time"`
	Value float64   `json:"value"`
}

// FriendlyName defines model for friendlyName.
type FriendlyName = string

// GetQuotaOutput defines model for getQuotaOutput.
type GetQuotaOutput struct {
	AvailableTokens     *int32 `json:"availableTokens,omitempty"`
	MaxTokens           *int32 `json:"maxTokens,omitempty"`
	OrgID               *OrgID `json:"orgID,omitempty"`
	SecondsUntilRefresh *int32 `json:"secondsUntilRefresh,omitempty"`
}

// Job defines model for job.
type Job struct {
	BatchID                        *BatchID               `json:"batchID,omitempty"`
	BranchID                       *BranchID              `json:"branchID,omitempty"`
	BuildID                        *BuildID               `json:"buildID,omitempty"`
	ConflatedStatus                *ConflatedJobStatus    `json:"conflatedStatus,omitempty"`
	CreationTimestamp              *Timestamp             `json:"creationTimestamp,omitempty"`
	Description                    *string                `json:"description,omitempty"`
	ExecutionError                 *ExecutionError        `json:"executionError,omitempty"`
	ExecutionErrors                *[]ExecutionError      `json:"executionErrors"`
	ExperienceEnvironmentVariables *[]EnvironmentVariable `json:"experienceEnvironmentVariables,omitempty"`
	ExperienceID                   *ExperienceID          `json:"experienceID,omitempty"`
	ExperienceName                 *ExperienceName        `json:"experienceName,omitempty"`
	ExperienceProfile              *string                `json:"experienceProfile,omitempty"`
	JobID                          *JobID                 `json:"jobID,omitempty"`
	JobMetricsStatus               *MetricStatus          `json:"jobMetricsStatus,omitempty"`
	JobStatus                      *JobStatus             `json:"jobStatus,omitempty"`
	LastRunTimestamp               *Timestamp             `json:"lastRunTimestamp,omitempty"`
	LastUpdatedTimestamp           *Timestamp             `json:"lastUpdatedTimestamp,omitempty"`
	OrgID                          *OrgID                 `json:"orgID,omitempty"`
	OutputLocation                 *string                `json:"outputLocation,omitempty"`
	Parameters                     *BatchParameters       `json:"parameters,omitempty"`
	ProjectID                      *ProjectID             `json:"projectID,omitempty"`
	RunCounter                     *RunCounter            `json:"runCounter,omitempty"`
	StatusHistory                  *JobStatusHistory      `json:"statusHistory,omitempty"`
	SystemID                       *SystemID              `json:"systemID,omitempty"`
	UserID                         *UserID                `json:"userID,omitempty"`
}

// JobID defines model for jobID.
type JobID = openapi_types.UUID

// JobLog defines model for jobLog.
type JobLog struct {
	Checksum          *Checksum      `json:"checksum,omitempty"`
	CreationTimestamp *Timestamp     `json:"creationTimestamp,omitempty"`
	ExecutionStep     *ExecutionStep `json:"executionStep,omitempty"`
	FileName          *FileName      `json:"fileName,omitempty"`
	FileSize          *FileSize      `json:"fileSize,omitempty"`
	JobID             *JobID         `json:"jobID,omitempty"`
	Location          *LogLocation   `json:"location,omitempty"`
	LogID             *LogID         `json:"logID,omitempty"`
	LogOutputLocation *string        `json:"logOutputLocation,omitempty"`
	LogType           *LogType       `json:"logType,omitempty"`
	OrgID             *OrgID         `json:"orgID,omitempty"`
	UserID            *UserID        `json:"userID,omitempty"`
}

// JobMetric defines model for jobMetric.
type JobMetric struct {
	BatchID           *BatchID         `json:"batchID,omitempty"`
	CreationTimestamp *Timestamp       `json:"creationTimestamp,omitempty"`
	DataIDs           *[]MetricsDataID `json:"dataIDs,omitempty"`

	// EventMetric true if this metric is for an event
	EventMetric  *bool           `json:"eventMetric,omitempty"`
	FileLocation *MetricLocation `json:"fileLocation,omitempty"`
	JobID        *JobID          `json:"jobID,omitempty"`
	MetricID     *MetricID       `json:"metricID,omitempty"`
	MetricURL    *MetricURL      `json:"metricURL,omitempty"`
	Name         *MetricName     `json:"name,omitempty"`
	OrgID        *OrgID          `json:"orgID,omitempty"`
	ProjectID    *ProjectID      `json:"projectID,omitempty"`
	Status       *MetricStatus   `json:"status,omitempty"`
	Type         *MetricType     `json:"type,omitempty"`
	Unit         *string         `json:"unit"`
	UserID       *UserID         `json:"userID,omitempty"`
	Value        *MetricValue    `json:"value"`
}

// JobMetricsData defines model for jobMetricsData.
type JobMetricsData struct {
	CreationTimestamp *Timestamp           `json:"creationTimestamp,omitempty"`
	DataID            *MetricsDataID       `json:"dataID,omitempty"`
	FileLocation      *MetricsDataLocation `json:"fileLocation,omitempty"`
	Filename          *string              `json:"filename"`
	JobID             *JobID               `json:"jobID,omitempty"`
	MetricsDataType   *MetricsDataType     `json:"metricsDataType,omitempty"`
	MetricsDataURL    *MetricsDataURL      `json:"metricsDataURL,omitempty"`
	Name              *string              `json:"name,omitempty"`
	OrgID             *OrgID               `json:"orgID,omitempty"`
	UserID            *UserID              `json:"userID,omitempty"`
}

// JobMetricsStatusCounts defines model for jobMetricsStatusCounts.
type JobMetricsStatusCounts struct {
	FailBlock        int `json:"failBlock"`
	FailWarn         int `json:"failWarn"`
	NoStatusReported int `json:"noStatusReported"`
	NotApplicable    int `json:"notApplicable"`
	Passed           int `json:"passed"`
	Raw              int `json:"raw"`
}

// JobStatus defines model for jobStatus.
type JobStatus string

// JobStatusHistory defines model for jobStatusHistory.
type JobStatusHistory = []JobStatusHistoryType

// JobStatusHistoryType defines model for jobStatusHistoryType.
type JobStatusHistoryType struct {
	Status    *JobStatus `json:"status,omitempty"`
	UpdatedAt *Timestamp `json:"updatedAt,omitempty"`
}

// KeyMetric defines model for keyMetric.
type KeyMetric struct {
	// FirstBuildMetric The first batch metric in the sequence, and some info about how it has changed
	FirstBuildMetric *FirstBuildMetric           `json:"firstBuildMetric"`
	LatestValue      float64                     `json:"latestValue"`
	Name             string                      `json:"name"`
	Performance      []KeyMetricPerformancePoint `json:"performance"`

	// Target The optional desired target for this metric
	Target *KeyMetricTarget `json:"target"`
	Unit   *string          `json:"unit"`
}

// KeyMetricPerformancePoint defines model for keyMetricPerformancePoint.
type KeyMetricPerformancePoint struct {
	Time  Timestamp `json:"time"`
	Value float64   `json:"value"`
}

// KeyMetricTarget The optional desired target for this metric
type KeyMetricTarget struct {
	Operator string  `json:"operator"`
	Value    float64 `json:"value"`
}

// LineNumber defines model for lineNumber.
type LineNumber = int32

// ListAllJobsOutput defines model for listAllJobsOutput.
type ListAllJobsOutput struct {
	Jobs          *[]Job  `json:"jobs,omitempty"`
	NextPageToken *string `json:"nextPageToken,omitempty"`
	Total         *int    `json:"total,omitempty"`
}

// ListBatchErrorsOutput defines model for listBatchErrorsOutput.
type ListBatchErrorsOutput struct {
	Errors *[]ExecutionError `json:"errors,omitempty"`
}

// ListBatchLogsOutput defines model for listBatchLogsOutput.
type ListBatchLogsOutput struct {
	Logs          *[]BatchLog `json:"logs,omitempty"`
	NextPageToken *string     `json:"nextPageToken,omitempty"`
}

// ListBatchMetricsDataForBatchMetricIDsOutput defines model for listBatchMetricsDataForBatchMetricIDsOutput.
type ListBatchMetricsDataForBatchMetricIDsOutput struct {
	BatchMetricsDataAndIDs *[]BatchMetricsDataAndIDs `json:"batchMetricsDataAndIDs,omitempty"`
	NextPageToken          *string                   `json:"nextPageToken,omitempty"`
}

// ListBatchMetricsDataOutput defines model for listBatchMetricsDataOutput.
type ListBatchMetricsDataOutput struct {
	BatchMetricsData *[]BatchMetricsData `json:"batchMetricsData,omitempty"`
	NextPageToken    *string             `json:"nextPageToken,omitempty"`
}

// ListBatchMetricsOutput defines model for listBatchMetricsOutput.
type ListBatchMetricsOutput struct {
	BatchMetrics  *[]BatchMetric `json:"batchMetrics,omitempty"`
	NextPageToken *string        `json:"nextPageToken,omitempty"`
}

// ListBatchesOutput defines model for listBatchesOutput.
type ListBatchesOutput struct {
	Batches       *[]Batch `json:"batches,omitempty"`
	NextPageToken *string  `json:"nextPageToken,omitempty"`
	Total         *int     `json:"total,omitempty"`
}

// ListBranchesOutput defines model for listBranchesOutput.
type ListBranchesOutput struct {
	Branches      *[]Branch `json:"branches,omitempty"`
	NextPageToken *string   `json:"nextPageToken,omitempty"`
}

// ListBuildsOutput defines model for listBuildsOutput.
type ListBuildsOutput struct {
	Builds        []Build `json:"builds"`
	NextPageToken string  `json:"nextPageToken"`
	Total         int     `json:"total"`
}

// ListExperienceTagsOutput defines model for listExperienceTagsOutput.
type ListExperienceTagsOutput struct {
	ExperienceTags *[]ExperienceTag `json:"experienceTags,omitempty"`
	NextPageToken  *string          `json:"nextPageToken,omitempty"`
}

// ListExperiencesOutput defines model for listExperiencesOutput.
type ListExperiencesOutput struct {
	Experiences   *[]Experience `json:"experiences,omitempty"`
	NextPageToken *string       `json:"nextPageToken,omitempty"`
	Total         *int          `json:"total,omitempty"`
}

// ListJobEventTagsOutput defines model for listJobEventTagsOutput.
type ListJobEventTagsOutput struct {
	EventTags     *[]string `json:"eventTags,omitempty"`
	NextPageToken *string   `json:"nextPageToken,omitempty"`
}

// ListJobEventsOutput defines model for listJobEventsOutput.
type ListJobEventsOutput struct {
	Events        *[]Event `json:"events,omitempty"`
	NextPageToken *string  `json:"nextPageToken,omitempty"`
}

// ListJobLogsOutput defines model for listJobLogsOutput.
type ListJobLogsOutput struct {
	Logs          *[]JobLog `json:"logs,omitempty"`
	NextPageToken *string   `json:"nextPageToken,omitempty"`
	Total         *int      `json:"total,omitempty"`
}

// ListJobMetricsDataOutput defines model for listJobMetricsDataOutput.
type ListJobMetricsDataOutput struct {
	MetricsData   *[]JobMetricsData `json:"metricsData,omitempty"`
	NextPageToken *string           `json:"nextPageToken,omitempty"`
}

// ListJobMetricsOutput defines model for listJobMetricsOutput.
type ListJobMetricsOutput struct {
	Metrics       *[]JobMetric `json:"metrics,omitempty"`
	NextPageToken *string      `json:"nextPageToken,omitempty"`
}

// ListJobsOutput defines model for listJobsOutput.
type ListJobsOutput struct {
	Jobs          *[]Job  `json:"jobs,omitempty"`
	NextPageToken *string `json:"nextPageToken,omitempty"`
	Total         *int    `json:"total,omitempty"`
}

// ListMetricsBuildOutput defines model for listMetricsBuildOutput.
type ListMetricsBuildOutput struct {
	MetricsBuilds []MetricsBuild `json:"metricsBuilds"`
	NextPageToken string         `json:"nextPageToken"`
	Total         int            `json:"total"`
}

// ListMetricsDataAndMetricIDOutput defines model for listMetricsDataAndMetricIDOutput.
type ListMetricsDataAndMetricIDOutput struct {
	MetricsDataAndIDs *[]MetricsDataAndMetricID `json:"metricsDataAndIDs,omitempty"`
	NextPageToken     *string                   `json:"nextPageToken,omitempty"`
}

// ListParameterSweepsOutput defines model for listParameterSweepsOutput.
type ListParameterSweepsOutput struct {
	NextPageToken *string           `json:"nextPageToken,omitempty"`
	Sweeps        *[]ParameterSweep `json:"sweeps,omitempty"`
}

// ListProjectsOutput defines model for listProjectsOutput.
type ListProjectsOutput struct {
	NextPageToken *string    `json:"nextPageToken,omitempty"`
	Projects      *[]Project `json:"projects,omitempty"`
}

// ListReportLogsOutput defines model for listReportLogsOutput.
type ListReportLogsOutput struct {
	Logs          *[]ReportLog `json:"logs,omitempty"`
	NextPageToken *string      `json:"nextPageToken,omitempty"`
}

// ListReportMetricsDataForReportMetricIDsOutput defines model for listReportMetricsDataForReportMetricIDsOutput.
type ListReportMetricsDataForReportMetricIDsOutput struct {
	NextPageToken           *string                    `json:"nextPageToken,omitempty"`
	ReportMetricsDataAndIDs *[]ReportMetricsDataAndIDs `json:"reportMetricsDataAndIDs,omitempty"`
}

// ListReportMetricsDataOutput defines model for listReportMetricsDataOutput.
type ListReportMetricsDataOutput struct {
	NextPageToken     *string        `json:"nextPageToken,omitempty"`
	ReportMetricsData *[]MetricsData `json:"reportMetricsData,omitempty"`
}

// ListReportMetricsOutput defines model for listReportMetricsOutput.
type ListReportMetricsOutput struct {
	NextPageToken *string   `json:"nextPageToken,omitempty"`
	ReportMetrics *[]Metric `json:"reportMetrics,omitempty"`
}

// ListReportsOutput defines model for listReportsOutput.
type ListReportsOutput struct {
	NextPageToken *string   `json:"nextPageToken,omitempty"`
	Reports       *[]Report `json:"reports,omitempty"`
	Total         *int      `json:"total,omitempty"`
}

// ListSystemsOutput defines model for listSystemsOutput.
type ListSystemsOutput struct {
	NextPageToken *string   `json:"nextPageToken,omitempty"`
	Systems       *[]System `json:"systems,omitempty"`
}

// ListTagsForBatchMetricsOutput defines model for listTagsForBatchMetricsOutput.
type ListTagsForBatchMetricsOutput struct {
	NextPageToken *string      `json:"nextPageToken,omitempty"`
	Tags          *[]MetricTag `json:"tags,omitempty"`
}

// ListTagsForJobMetricsOutput defines model for listTagsForJobMetricsOutput.
type ListTagsForJobMetricsOutput struct {
	NextPageToken *string      `json:"nextPageToken,omitempty"`
	Tags          *[]MetricTag `json:"tags,omitempty"`
}

// ListTagsForReportMetricsOutput defines model for listTagsForReportMetricsOutput.
type ListTagsForReportMetricsOutput struct {
	NextPageToken *string      `json:"nextPageToken,omitempty"`
	Tags          *[]MetricTag `json:"tags,omitempty"`
}

// ListTestSuiteOutput defines model for listTestSuiteOutput.
type ListTestSuiteOutput struct {
	NextPageToken string      `json:"nextPageToken"`
	TestSuites    []TestSuite `json:"testSuites"`
	Total         int         `json:"total"`
}

// ListTestSuiteRevisionsOutput defines model for listTestSuiteRevisionsOutput.
type ListTestSuiteRevisionsOutput struct {
	NextPageToken *string      `json:"nextPageToken,omitempty"`
	TestSuites    *[]TestSuite `json:"testSuites,omitempty"`
}

// ListUsersOutput defines model for listUsersOutput.
type ListUsersOutput = []string

// ListViewObjectsOutput defines model for listViewObjectsOutput.
type ListViewObjectsOutput struct {
	NextPageToken *string       `json:"nextPageToken,omitempty"`
	ViewSessions  *[]ViewObject `json:"viewSessions,omitempty"`
}

// Log defines model for log.
type Log struct {
	Checksum          *Checksum      `json:"checksum,omitempty"`
	CreationTimestamp *Timestamp     `json:"creationTimestamp,omitempty"`
	ExecutionStep     *ExecutionStep `json:"executionStep,omitempty"`
	FileName          *FileName      `json:"fileName,omitempty"`
	FileSize          *FileSize      `json:"fileSize,omitempty"`
	Location          *LogLocation   `json:"location,omitempty"`
	LogID             *LogID         `json:"logID,omitempty"`
	LogOutputLocation *string        `json:"logOutputLocation,omitempty"`
	LogType           *LogType       `json:"logType,omitempty"`
	OrgID             *OrgID         `json:"orgID,omitempty"`
	UserID            *UserID        `json:"userID,omitempty"`
}

// LogID defines model for logID.
type LogID = openapi_types.UUID

// LogLocation defines model for logLocation.
type LogLocation = string

// LogType defines model for logType.
type LogType string

// McapURL defines model for mcapURL.
type McapURL = string

// Metric defines model for metric.
type Metric struct {
	CreationTimestamp *Timestamp       `json:"creationTimestamp,omitempty"`
	DataIDs           *[]MetricsDataID `json:"dataIDs,omitempty"`

	// EventMetric true if this metric is for an event
	EventMetric  *bool           `json:"eventMetric,omitempty"`
	FileLocation *MetricLocation `json:"fileLocation,omitempty"`
	MetricID     *MetricID       `json:"metricID,omitempty"`
	MetricURL    *MetricURL      `json:"metricURL,omitempty"`
	Name         *MetricName     `json:"name,omitempty"`
	OrgID        *OrgID          `json:"orgID,omitempty"`
	ProjectID    *ProjectID      `json:"projectID,omitempty"`
	Status       *MetricStatus   `json:"status,omitempty"`
	Type         *MetricType     `json:"type,omitempty"`
	Unit         *string         `json:"unit"`
	UserID       *UserID         `json:"userID,omitempty"`
	Value        *MetricValue    `json:"value"`
}

// MetricID defines model for metricID.
type MetricID = openapi_types.UUID

// MetricLocation defines model for metricLocation.
type MetricLocation = string

// MetricName defines model for metricName.
type MetricName = string

// MetricStatus defines model for metricStatus.
type MetricStatus string

// MetricTag defines model for metricTag.
type MetricTag struct {
	CreationTimestamp *time.Time          `json:"creationTimestamp,omitempty"`
	MetricID          *openapi_types.UUID `json:"metricID,omitempty"`
	Name              string              `json:"name"`
	TagID             *TagID              `json:"tagID,omitempty"`
	Value             string              `json:"value"`
}

// MetricType defines model for metricType.
type MetricType string

// MetricURL defines model for metricURL.
type MetricURL = string

// MetricValue defines model for metricValue.
type MetricValue = float64

// MetricsBuild defines model for metricsBuild.
type MetricsBuild struct {
	CreationTimestamp Timestamp            `json:"creationTimestamp"`
	ImageUri          MetricsBuildImageUri `json:"imageUri"`
	MetricsBuildID    MetricsBuildID       `json:"metricsBuildID"`
	Name              MetricsBuildName     `json:"name"`
	OrgID             OrgID                `json:"orgID"`
	ProjectID         ProjectID            `json:"projectID"`
	UserID            UserID               `json:"userID"`
	Version           MetricsBuildVersion  `json:"version"`
}

// MetricsBuildID defines model for metricsBuildID.
type MetricsBuildID = openapi_types.UUID

// MetricsBuildImageUri defines model for metricsBuildImageUri.
type MetricsBuildImageUri = string

// MetricsBuildName defines model for metricsBuildName.
type MetricsBuildName = string

// MetricsBuildVersion defines model for metricsBuildVersion.
type MetricsBuildVersion = string

// MetricsData defines model for metricsData.
type MetricsData struct {
	CreationTimestamp *Timestamp           `json:"creationTimestamp,omitempty"`
	DataID            *MetricsDataID       `json:"dataID,omitempty"`
	FileLocation      *MetricsDataLocation `json:"fileLocation,omitempty"`
	Filename          *string              `json:"filename"`
	MetricsDataType   *MetricsDataType     `json:"metricsDataType,omitempty"`
	MetricsDataURL    *MetricsDataURL      `json:"metricsDataURL,omitempty"`
	Name              *string              `json:"name,omitempty"`
	OrgID             *OrgID               `json:"orgID,omitempty"`
	UserID            *UserID              `json:"userID,omitempty"`
}

// MetricsDataAndMetricID defines model for metricsDataAndMetricID.
type MetricsDataAndMetricID struct {
	MetricID    *MetricID       `json:"metricID,omitempty"`
	MetricsData *JobMetricsData `json:"metricsData,omitempty"`
}

// MetricsDataID defines model for metricsDataID.
type MetricsDataID = openapi_types.UUID

// MetricsDataLocation defines model for metricsDataLocation.
type MetricsDataLocation = string

// MetricsDataType defines model for metricsDataType.
type MetricsDataType string

// MetricsDataURL defines model for metricsDataURL.
type MetricsDataURL = string

// MetricsSetName defines model for metricsSetName.
type MetricsSetName = string

// MutateSystemsToExperienceInput defines model for mutateSystemsToExperienceInput.
type MutateSystemsToExperienceInput struct {
	AllExperiences *bool                  `json:"allExperiences,omitempty"`
	Experiences    *[]ExperienceID        `json:"experiences,omitempty"`
	Filters        *ExperienceFilterInput `json:"filters,omitempty"`
	SystemIDs      []SystemID             `json:"systemIDs"`
}

// Name defines model for name.
type Name = string

// ObjectCount defines model for objectCount.
type ObjectCount = int32

// ObjectName defines model for objectName.
type ObjectName = string

// ObjectType defines model for objectType.
type ObjectType string

// OrgID defines model for orgID.
type OrgID = string

// ParameterSweep defines model for parameterSweep.
type ParameterSweep struct {
	AssociatedAccount    AssociatedAccount            `json:"associatedAccount"`
	Batches              *[]BatchID                   `json:"batches,omitempty"`
	CreationTimestamp    *Timestamp                   `json:"creationTimestamp,omitempty"`
	LastUpdatedTimestamp *Timestamp                   `json:"lastUpdatedTimestamp,omitempty"`
	Name                 *string                      `json:"name,omitempty"`
	OrgID                *OrgID                       `json:"orgID,omitempty"`
	ParameterSweepID     *ParameterSweepID            `json:"parameterSweepID,omitempty"`
	Parameters           *[]SweepParameter            `json:"parameters,omitempty"`
	ProjectID            *ProjectID                   `json:"projectID,omitempty"`
	Status               *ParameterSweepStatus        `json:"status,omitempty"`
	StatusHistory        *ParameterSweepStatusHistory `json:"statusHistory,omitempty"`
	UserID               *UserID                      `json:"userID,omitempty"`
}

// ParameterSweepID defines model for parameterSweepID.
type ParameterSweepID = openapi_types.UUID

// ParameterSweepInput defines model for parameterSweepInput.
type ParameterSweepInput struct {
	AllowableFailurePercent *int                 `json:"allowableFailurePercent"`
	AssociatedAccount       *AssociatedAccount   `json:"associatedAccount,omitempty"`
	BuildID                 *BuildID             `json:"buildID,omitempty"`
	ExperienceIDs           *[]ExperienceID      `json:"experienceIDs"`
	ExperienceNames         *[]ExperienceName    `json:"experienceNames"`
	ExperienceTagIDs        *[]ExperienceTagID   `json:"experienceTagIDs"`
	ExperienceTagNames      *[]ExperienceTagName `json:"experienceTagNames"`
	MetricsBuildID          *MetricsBuildID      `json:"metricsBuildID,omitempty"`
	MetricsSetName          *MetricsSetName      `json:"metricsSetName"`
	Parameters              *[]SweepParameter    `json:"parameters,omitempty"`
	PoolLabels              *PoolLabels          `json:"poolLabels,omitempty"`
	TriggeredVia            *TriggeredVia        `json:"triggeredVia,omitempty"`
}

// ParameterSweepStatus defines model for parameterSweepStatus.
type ParameterSweepStatus string

// ParameterSweepStatusHistory defines model for parameterSweepStatusHistory.
type ParameterSweepStatusHistory = []ParameterSweepStatusHistoryType

// ParameterSweepStatusHistoryType defines model for parameterSweepStatusHistoryType.
type ParameterSweepStatusHistoryType struct {
	Status    *ParameterSweepStatus `json:"status,omitempty"`
	UpdatedAt *Timestamp            `json:"updatedAt,omitempty"`
}

// PoolLabel defines model for poolLabel.
type PoolLabel = string

// PoolLabels defines model for poolLabels.
type PoolLabels = []PoolLabel

// Profile defines model for profile.
type Profile = string

// Project defines model for project.
type Project struct {
	Archived          Archived  `json:"archived"`
	CreationTimestamp Timestamp `json:"creationTimestamp"`
	Description       string    `json:"description"`
	Name              string    `json:"name"`
	OrgID             OrgID     `json:"orgID"`
	ProjectID         ProjectID `json:"projectID"`
	UserID            UserID    `json:"userID"`
}

// ProjectID defines model for projectID.
type ProjectID = openapi_types.UUID

// ReferenceBatchSummary defines model for referenceBatchSummary.
type ReferenceBatchSummary struct {
	FixedTests int64 `json:"fixedTests"`
	NewIssues  int64 `json:"newIssues"`
	NewTests   int64 `json:"newTests"`
}

// Report defines model for report.
type Report struct {
	AssociatedAccount       AssociatedAccount       `json:"associatedAccount"`
	BranchID                BranchID                `json:"branchID"`
	CreationTimestamp       Timestamp               `json:"creationTimestamp"`
	EndTimestamp            Timestamp               `json:"endTimestamp"`
	LastUpdatedTimestamp    Timestamp               `json:"lastUpdatedTimestamp"`
	MetricsBuildID          MetricsBuildID          `json:"metricsBuildID"`
	MetricsSetName          *MetricsSetName         `json:"metricsSetName"`
	MetricsStatus           MetricStatus            `json:"metricsStatus"`
	Name                    Name                    `json:"name"`
	OrgID                   OrgID                   `json:"orgID"`
	OutputLocation          string                  `json:"outputLocation"`
	ProjectID               ProjectID               `json:"projectID"`
	ReportID                ReportID                `json:"reportID"`
	RespectRevisionBoundary RespectRevisionBoundary `json:"respectRevisionBoundary"`
	StartTimestamp          Timestamp               `json:"startTimestamp"`
	Status                  ReportStatus            `json:"status"`
	StatusHistory           ReportStatusHistory     `json:"statusHistory"`
	TestSuiteID             TestSuiteID             `json:"testSuiteID"`
	TestSuiteRevision       TestSuiteRevision       `json:"testSuiteRevision"`
	TriggeredVia            *TriggeredVia           `json:"triggeredVia,omitempty"`
	UserID                  UserID                  `json:"userID"`
}

// ReportID defines model for reportID.
type ReportID = openapi_types.UUID

// ReportInput defines model for reportInput.
type ReportInput struct {
	AssociatedAccount       *AssociatedAccount       `json:"associatedAccount,omitempty"`
	BranchID                BranchID                 `json:"branchID"`
	EndTimestamp            *Timestamp               `json:"endTimestamp,omitempty"`
	MetricsBuildID          MetricsBuildID           `json:"metricsBuildID"`
	MetricsSetName          *MetricsSetName          `json:"metricsSetName"`
	Name                    *Name                    `json:"name,omitempty"`
	PoolLabels              *PoolLabels              `json:"poolLabels,omitempty"`
	RespectRevisionBoundary *RespectRevisionBoundary `json:"respectRevisionBoundary,omitempty"`
	StartTimestamp          Timestamp                `json:"startTimestamp"`
	TestSuiteID             TestSuiteID              `json:"testSuiteID"`
	TestSuiteRevision       *TestSuiteRevision       `json:"testSuiteRevision,omitempty"`
	TriggeredVia            *TriggeredVia            `json:"triggeredVia,omitempty"`
}

// ReportLog defines model for reportLog.
type ReportLog struct {
	Checksum          Checksum    `json:"checksum"`
	CreationTimestamp Timestamp   `json:"creationTimestamp"`
	FileName          FileName    `json:"fileName"`
	FileSize          FileSize    `json:"fileSize"`
	Location          LogLocation `json:"location"`
	LogID             LogID       `json:"logID"`
	LogOutputLocation string      `json:"logOutputLocation"`
	LogType           LogType     `json:"logType"`
	OrgID             OrgID       `json:"orgID"`
	UserID            UserID      `json:"userID"`
}

// ReportMetricsDataAndIDs defines model for reportMetricsDataAndIDs.
type ReportMetricsDataAndIDs struct {
	ReportMetricID    *MetricID    `json:"reportMetricID,omitempty"`
	ReportMetricsData *MetricsData `json:"reportMetricsData,omitempty"`
}

// ReportStatus defines model for reportStatus.
type ReportStatus string

// ReportStatusHistory defines model for reportStatusHistory.
type ReportStatusHistory = []ReportStatusHistoryType

// ReportStatusHistoryType defines model for reportStatusHistoryType.
type ReportStatusHistoryType struct {
	Status    *ReportStatus `json:"status,omitempty"`
	UpdatedAt *Timestamp    `json:"updatedAt,omitempty"`
}

// RerunBatchInput defines model for rerunBatchInput.
type RerunBatchInput struct {
	JobIDs *[]JobID `json:"jobIDs,omitempty"`
}

// RerunBatchOutput defines model for rerunBatchOutput.
type RerunBatchOutput struct {
	BatchID    *BatchID    `json:"batchID,omitempty"`
	JobIDs     *[]JobID    `json:"jobIDs,omitempty"`
	RunCounter *RunCounter `json:"runCounter,omitempty"`
}

// RespectRevisionBoundary defines model for respectRevisionBoundary.
type RespectRevisionBoundary = bool

// ReviseTestSuiteInput defines model for reviseTestSuiteInput.
type ReviseTestSuiteInput struct {
	Adhoc                 *bool                   `json:"adhoc,omitempty"`
	AllExperiences        *bool                   `json:"allExperiences,omitempty"`
	Description           *TestSuiteDescription   `json:"description,omitempty"`
	ExcludedExperienceIDs *[]ExcludedExperienceID `json:"excludedExperienceIDs,omitempty"`
	Experiences           *[]ExperienceID         `json:"experiences,omitempty"`
	Filters               *ExperienceFilterInput  `json:"filters,omitempty"`
	MetricsBuildID        *MetricsBuildID         `json:"metricsBuildID,omitempty"`
	MetricsSetName        *MetricsSetName         `json:"metricsSetName"`
	Name                  *TestSuiteName          `json:"name,omitempty"`
	ShowOnSummary         *bool                   `json:"show_on_summary,omitempty"`
	SystemID              *SystemID               `json:"systemID,omitempty"`
	UpdateMetricsBuild    bool                    `json:"updateMetricsBuild"`
}

// RunCounter defines model for runCounter.
type RunCounter = int

// SelectExperiencesInput defines model for selectExperiencesInput.
type SelectExperiencesInput struct {
	AllExperiences *bool                  `json:"allExperiences,omitempty"`
	Experiences    *[]ExperienceID        `json:"experiences,omitempty"`
	Filters        *ExperienceFilterInput `json:"filters,omitempty"`
}

// SweepParameter defines model for sweepParameter.
type SweepParameter struct {
	Name   *string   `json:"name,omitempty"`
	Values *[]string `json:"values,omitempty"`
}

// System defines model for system.
type System struct {
	Archived                   Archived  `json:"archived"`
	BuildGpus                  int       `json:"build_gpus"`
	BuildMemoryMib             int       `json:"build_memory_mib"`
	BuildSharedMemoryMb        int       `json:"build_shared_memory_mb"`
	BuildVcpus                 int       `json:"build_vcpus"`
	CreationTimestamp          Timestamp `json:"creationTimestamp"`
	Description                string    `json:"description"`
	MetricsBuildGpus           int       `json:"metrics_build_gpus"`
	MetricsBuildMemoryMib      int       `json:"metrics_build_memory_mib"`
	MetricsBuildSharedMemoryMb int       `json:"metrics_build_shared_memory_mb"`
	MetricsBuildVcpus          int       `json:"metrics_build_vcpus"`
	Name                       string    `json:"name"`
	NumBatches                 int       `json:"numBatches"`
	NumBuilds                  int       `json:"numBuilds"`
	NumExperiences             int       `json:"numExperiences"`
	NumMetricsBuilds           int       `json:"numMetricsBuilds"`
	NumTestSuites              int       `json:"numTestSuites"`
	OrgID                      OrgID     `json:"orgID"`
	ProjectID                  ProjectID `json:"projectID"`
	SystemID                   SystemID  `json:"systemID"`
	UserID                     UserID    `json:"userID"`
}

// SystemID defines model for systemID.
type SystemID = openapi_types.UUID

// TagID defines model for tagID.
type TagID = openapi_types.UUID

// TestSuite defines model for testSuite.
type TestSuite struct {
	Archived             bool                 `json:"archived"`
	CreationTimestamp    Timestamp            `json:"creationTimestamp"`
	Description          TestSuiteDescription `json:"description"`
	Experiences          []ExperienceID       `json:"experiences"`
	MetricsBuildID       *MetricsBuildID      `json:"metricsBuildID,omitempty"`
	MetricsSetName       *MetricsSetName      `json:"metricsSetName"`
	Name                 TestSuiteName        `json:"name"`
	OrgID                OrgID                `json:"orgID"`
	ProjectID            ProjectID            `json:"projectID"`
	ShowOnSummary        bool                 `json:"showOnSummary"`
	SummaryReferenceDate *Timestamp           `json:"summaryReferenceDate,omitempty"`
	SystemID             SystemID             `json:"systemID"`
	TestSuiteID          TestSuiteID          `json:"testSuiteID"`
	TestSuiteRevision    TestSuiteRevision    `json:"testSuiteRevision"`
	UserID               UserID               `json:"userID"`
}

// TestSuiteBatchInput defines model for testSuiteBatchInput.
type TestSuiteBatchInput struct {
	AllowableFailurePercent *int               `json:"allowableFailurePercent"`
	AssociatedAccount       *AssociatedAccount `json:"associatedAccount,omitempty"`
	BatchName               *Name              `json:"batchName,omitempty"`
	BuildID                 BuildID            `json:"buildID"`
	Parameters              *BatchParameters   `json:"parameters,omitempty"`
	PoolLabels              *PoolLabels        `json:"poolLabels,omitempty"`
	TriggeredVia            *TriggeredVia      `json:"triggeredVia,omitempty"`
}

// TestSuiteBatchSummaryJobResults defines model for testSuiteBatchSummaryJobResults.
type TestSuiteBatchSummaryJobResults struct {
	BatchCreationTimestamp Timestamp      `json:"batchCreationTimestamp"`
	BatchID                BatchID        `json:"batchID"`
	Blocker                int64          `json:"blocker"`
	BuildCreationTimestamp Timestamp      `json:"buildCreationTimestamp"`
	BuildID                BuildID        `json:"buildID"`
	Cancelled              int64          `json:"cancelled"`
	Error                  int64          `json:"error"`
	Metrics                []CustomMetric `json:"metrics"`
	Passed                 int64          `json:"passed"`
	Queued                 int64          `json:"queued"`
	Running                int64          `json:"running"`
	Total                  int64          `json:"total"`
	Warning                int64          `json:"warning"`
}

// TestSuiteDescription defines model for testSuiteDescription.
type TestSuiteDescription = string

// TestSuiteID defines model for testSuiteID.
type TestSuiteID = openapi_types.UUID

// TestSuiteName defines model for testSuiteName.
type TestSuiteName = string

// TestSuiteRevision defines model for testSuiteRevision.
type TestSuiteRevision = int32

// TestSuiteSummary defines model for testSuiteSummary.
type TestSuiteSummary struct {
	Batches               []TestSuiteBatchSummaryJobResults `json:"batches"`
	BranchID              BranchID                          `json:"branchID"`
	KeyMetric             *KeyMetric                        `json:"keyMetric"`
	Name                  TestSuiteName                     `json:"name"`
	ProjectID             ProjectID                         `json:"projectID"`
	ReferenceBatch        *TestSuiteBatchSummaryJobResults  `json:"referenceBatch,omitempty"`
	ReferenceBatchSummary *ReferenceBatchSummary            `json:"referenceBatchSummary"`
	ReportID              ReportID                          `json:"reportID"`
	Summary               struct {
		FixedTests int64 `json:"fixedTests"`
		NewIssues  int64 `json:"newIssues"`
		NewTests   int64 `json:"newTests"`
	} `json:"summary"`
	SystemID             SystemID             `json:"systemID"`
	TestSuiteDescription TestSuiteDescription `json:"testSuiteDescription"`
	TestSuiteID          TestSuiteID          `json:"testSuiteID"`
	TestSuiteRevision    TestSuiteRevision    `json:"testSuiteRevision"`
}

// TestSuiteSummaryOutput defines model for testSuiteSummaryOutput.
type TestSuiteSummaryOutput struct {
	NextPageToken string             `json:"nextPageToken"`
	TestSuites    []TestSuiteSummary `json:"testSuites"`
}

// Timestamp defines model for timestamp.
type Timestamp = time.Time

// TriggeredVia defines model for triggeredVia.
type TriggeredVia string

// UpdateBatchInput defines model for updateBatchInput.
type UpdateBatchInput struct {
	Description string `json:"description"`
}

// UpdateBuildFields defines model for updateBuildFields.
type UpdateBuildFields struct {
	BranchID *openapi_types.UUID `json:"branchID,omitempty"`

	// Description The description of the build. May be a SHA or commit message.
	// Deprecated:
	Description *BuildDescription `json:"description,omitempty"`

	// Name The name of the build.
	Name *BuildName `json:"name,omitempty"`
}

// UpdateBuildInput defines model for updateBuildInput.
type UpdateBuildInput struct {
	Build      *UpdateBuildFields `json:"build,omitempty"`
	UpdateMask *UpdateMask        `json:"updateMask,omitempty"`
}

// UpdateEventInput defines model for updateEventInput.
type UpdateEventInput struct {
	Description string `json:"description"`
}

// UpdateExperienceFields defines model for updateExperienceFields.
type UpdateExperienceFields struct {
	// CacheExempt If true, the experience will not be cached.
	CacheExempt             *bool                  `json:"cacheExempt,omitempty"`
	ContainerTimeoutSeconds *int32                 `json:"containerTimeoutSeconds,omitempty"`
	Description             *string                `json:"description,omitempty"`
	EnvironmentVariables    *[]EnvironmentVariable `json:"environmentVariables,omitempty"`
	ExperienceTagIDs        *[]ExperienceTagID     `json:"experienceTagIDs,omitempty"`

	// Location [DEPRECATED] This field was previously used to define an experience's location. Experiences can now be defined with multiple locations, using the locations field. This field will be removed in a future version.
	// Deprecated:
	Location  *string         `json:"location,omitempty"`
	Locations *[]string       `json:"locations,omitempty"`
	Name      *ExperienceName `json:"name,omitempty"`
	Profile   *Profile        `json:"profile,omitempty"`
	SystemIDs *[]SystemID     `json:"systemIDs,omitempty"`
}

// UpdateExperienceInput defines model for updateExperienceInput.
type UpdateExperienceInput struct {
	Experience *UpdateExperienceFields `json:"experience,omitempty"`
	UpdateMask *UpdateMask             `json:"updateMask,omitempty"`
}

// UpdateExperienceTagFields defines model for updateExperienceTagFields.
type UpdateExperienceTagFields struct {
	Description *string            `json:"description,omitempty"`
	Name        *ExperienceTagName `json:"name,omitempty"`
}

// UpdateExperienceTagInput defines model for updateExperienceTagInput.
type UpdateExperienceTagInput struct {
	ExperienceTag *UpdateExperienceTagFields `json:"experienceTag,omitempty"`
	UpdateMask    *UpdateMask                `json:"updateMask,omitempty"`
}

// UpdateJobInput defines model for updateJobInput.
type UpdateJobInput struct {
	Description string `json:"description"`
}

// UpdateMask defines model for updateMask.
type UpdateMask = []string

// UpdateProjectFields defines model for updateProjectFields.
type UpdateProjectFields struct {
	Description *string `json:"description,omitempty"`
	Name        *string `json:"name,omitempty"`
}

// UpdateProjectInput defines model for updateProjectInput.
type UpdateProjectInput struct {
	Project    *UpdateProjectFields `json:"project,omitempty"`
	UpdateMask *UpdateMask          `json:"updateMask,omitempty"`
}

// UpdateSystemInput defines model for updateSystemInput.
type UpdateSystemInput struct {
	BuildGpus                  *int    `json:"build_gpus,omitempty"`
	BuildMemoryMib             *int    `json:"build_memory_mib,omitempty"`
	BuildSharedMemoryMb        *int    `json:"build_shared_memory_mb,omitempty"`
	BuildVcpus                 *int    `json:"build_vcpus,omitempty"`
	Description                *string `json:"description,omitempty"`
	MetricsBuildGpus           *int    `json:"metrics_build_gpus,omitempty"`
	MetricsBuildMemoryMib      *int    `json:"metrics_build_memory_mib,omitempty"`
	MetricsBuildSharedMemoryMb *int    `json:"metrics_build_shared_memory_mb,omitempty"`
	MetricsBuildVcpus          *int    `json:"metrics_build_vcpus,omitempty"`
	Name                       *string `json:"name,omitempty"`
}

// UserID defines model for userID.
type UserID = string

// ViewMetadata defines model for viewMetadata.
type ViewMetadata struct {
	FileName   *FileName   `json:"fileName,omitempty"`
	LineNumber *LineNumber `json:"lineNumber,omitempty"`
	ObjectName *ObjectName `json:"objectName,omitempty"`
	ObjectType *ObjectType `json:"objectType,omitempty"`
}

// ViewObject defines model for viewObject.
type ViewObject struct {
	FriendlyName  *FriendlyName  `json:"friendlyName,omitempty"`
	McapURL       *McapURL       `json:"mcapURL,omitempty"`
	ObjectCount   *ObjectCount   `json:"objectCount,omitempty"`
	OrgID         *OrgID         `json:"orgID,omitempty"`
	UserID        *UserID        `json:"userID,omitempty"`
	ViewSessionID *ViewSessionID `json:"viewSessionID,omitempty"`
	ViewTimestamp *Timestamp     `json:"viewTimestamp,omitempty"`
	ViewURL       *string        `json:"viewURL,omitempty"`
}

// ViewObjectAndMetadata defines model for viewObjectAndMetadata.
type ViewObjectAndMetadata struct {
	ViewMetadata *[]ViewMetadata `json:"viewMetadata,omitempty"`
	ViewObject   *ViewObject     `json:"viewObject,omitempty"`
}

// ViewSessionID defines model for viewSessionID.
type ViewSessionID = openapi_types.UUID

// ViewSessionUpdate defines model for viewSessionUpdate.
type ViewSessionUpdate struct {
	Id   *ViewSessionID `json:"id,omitempty"`
	Mcap *McapURL       `json:"mcap,omitempty"`

	// View A link to view the session.
	View *string `json:"view,omitempty"`
}

// ViewUpdateID defines model for viewUpdateID.
type ViewUpdateID = int

// OrderBy defines model for orderBy.
type OrderBy = string

// PageSize defines model for pageSize.
type PageSize = int

// PageSizeUnbounded defines model for pageSizeUnbounded.
type PageSizeUnbounded = int

// PageToken defines model for pageToken.
type PageToken = string

// ListProjectsParams defines parameters for ListProjects.
type ListProjectsParams struct {
	PageSize  *PageSize  `form:"pageSize,omitempty" json:"pageSize,omitempty"`
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`
	OrderBy   *OrderBy   `form:"orderBy,omitempty" json:"orderBy,omitempty"`
}

// ListBatchesParams defines parameters for ListBatches.
type ListBatchesParams struct {
	// Search Filter based on branch_id, build_id, system_id, created_at, status, metrics_status, batch_id
	Search *string `form:"search,omitempty" json:"search,omitempty"`

	// Text Filter batches by a text string on batch name
	Text      *string    `form:"text,omitempty" json:"text,omitempty"`
	PageSize  *PageSize  `form:"pageSize,omitempty" json:"pageSize,omitempty"`
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`
	OrderBy   *OrderBy   `form:"orderBy,omitempty" json:"orderBy,omitempty"`
}

// ListAllJobsParams defines parameters for ListAllJobs.
type ListAllJobsParams struct {
	// Search Filter based on attributes metrics_build_name and metrics_build_version
	Search    *string    `form:"search,omitempty" json:"search,omitempty"`
	PageSize  *PageSize  `form:"pageSize,omitempty" json:"pageSize,omitempty"`
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`
	OrderBy   *OrderBy   `form:"orderBy,omitempty" json:"orderBy,omitempty"`
}

// ListBatchAccountsParams defines parameters for ListBatchAccounts.
type ListBatchAccountsParams struct {
	// Name Filter by the account name
	Name *string `form:"name,omitempty" json:"name,omitempty"`
}

// CompareBatchesParams defines parameters for CompareBatches.
type CompareBatchesParams struct {
	// Status filter tests by their status
	Status *CompareBatchesStatusFilter `form:"status,omitempty" json:"status,omitempty"`

	// Search filter tests by their name
	Search    *string    `form:"search,omitempty" json:"search,omitempty"`
	PageSize  *PageSize  `form:"pageSize,omitempty" json:"pageSize,omitempty"`
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// ListJobsParams defines parameters for ListJobs.
type ListJobsParams struct {
	// Status Filter jobs by status
	Status *JobStatus `form:"status,omitempty" json:"status,omitempty"`

	// ConflatedStatus Filter jobs by their conflated status
	ConflatedStatus *[]ConflatedJobStatus `form:"conflatedStatus,omitempty" json:"conflatedStatus,omitempty"`

	// Name Filter experiences (in job) by name
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// Text Filter experiences (in job) by a text string on name and description
	Text *string `form:"text,omitempty" json:"text,omitempty"`

	// ExperienceTagIDs Filter jobs by the tag id(s) attached to the experience
	ExperienceTagIDs *[]openapi_types.UUID `form:"experienceTagIDs,omitempty" json:"experienceTagIDs,omitempty"`
	PageSize         *PageSize             `form:"pageSize,omitempty" json:"pageSize,omitempty"`
	PageToken        *PageToken            `form:"pageToken,omitempty" json:"pageToken,omitempty"`
	OrderBy          *OrderBy              `form:"orderBy,omitempty" json:"orderBy,omitempty"`
}

// ListEventTagsForJobParams defines parameters for ListEventTagsForJob.
type ListEventTagsForJobParams struct {
	// Name Filter event tags by name
	Name      *string    `form:"name,omitempty" json:"name,omitempty"`
	PageSize  *PageSize  `form:"pageSize,omitempty" json:"pageSize,omitempty"`
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// ListEventsForJobParams defines parameters for ListEventsForJob.
type ListEventsForJobParams struct {
	// EventTags Tags on which to filter the events
	EventTags *EventTags `form:"eventTags,omitempty" json:"eventTags,omitempty"`
	PageSize  *PageSize  `form:"pageSize,omitempty" json:"pageSize,omitempty"`
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// ListJobLogsForJobParams defines parameters for ListJobLogsForJob.
type ListJobLogsForJobParams struct {
	Type *[]LogType `form:"type,omitempty" json:"type,omitempty"`

	// Name Filter logs by name
	Name      *string    `form:"name,omitempty" json:"name,omitempty"`
	PageSize  *PageSize  `form:"pageSize,omitempty" json:"pageSize,omitempty"`
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// ListMetricsForJobParams defines parameters for ListMetricsForJob.
type ListMetricsForJobParams struct {
	PageSize  *PageSize  `form:"pageSize,omitempty" json:"pageSize,omitempty"`
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`
	OrderBy   *OrderBy   `form:"orderBy,omitempty" json:"orderBy,omitempty"`
}

// ListMetricsForMetricIDsParams defines parameters for ListMetricsForMetricIDs.
type ListMetricsForMetricIDsParams struct {
	PageSize  *PageSize  `form:"pageSize,omitempty" json:"pageSize,omitempty"`
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// ListMetricsDataForMetricIDsParams defines parameters for ListMetricsDataForMetricIDs.
type ListMetricsDataForMetricIDsParams struct {
	PageSize  *PageSize  `form:"pageSize,omitempty" json:"pageSize,omitempty"`
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// ListTagsForJobMetricsParams defines parameters for ListTagsForJobMetrics.
type ListTagsForJobMetricsParams struct {
	PageSize  *PageSize  `form:"pageSize,omitempty" json:"pageSize,omitempty"`
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// ListMetricsDataForJobParams defines parameters for ListMetricsDataForJob.
type ListMetricsDataForJobParams struct {
	PageSize  *PageSize  `form:"pageSize,omitempty" json:"pageSize,omitempty"`
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// ListMetricsDataForMetricsDataIDsParams defines parameters for ListMetricsDataForMetricsDataIDs.
type ListMetricsDataForMetricsDataIDsParams struct {
	PageSize  *PageSize  `form:"pageSize,omitempty" json:"pageSize,omitempty"`
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// ListBatchLogsForBatchParams defines parameters for ListBatchLogsForBatch.
type ListBatchLogsForBatchParams struct {
	PageSize  *PageSize  `form:"pageSize,omitempty" json:"pageSize,omitempty"`
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// ListBatchMetricsParams defines parameters for ListBatchMetrics.
type ListBatchMetricsParams struct {
	PageSize  *PageSize  `form:"pageSize,omitempty" json:"pageSize,omitempty"`
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// ListBatchMetricsForBatchMetricIDsParams defines parameters for ListBatchMetricsForBatchMetricIDs.
type ListBatchMetricsForBatchMetricIDsParams struct {
	PageSize  *PageSize  `form:"pageSize,omitempty" json:"pageSize,omitempty"`
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// ListBatchMetricsDataForBatchMetricIDsParams defines parameters for ListBatchMetricsDataForBatchMetricIDs.
type ListBatchMetricsDataForBatchMetricIDsParams struct {
	PageSize  *PageSize  `form:"pageSize,omitempty" json:"pageSize,omitempty"`
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// ListTagsForBatchMetricsParams defines parameters for ListTagsForBatchMetrics.
type ListTagsForBatchMetricsParams struct {
	PageSize  *PageSize  `form:"pageSize,omitempty" json:"pageSize,omitempty"`
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// ListBatchMetricsDataParams defines parameters for ListBatchMetricsData.
type ListBatchMetricsDataParams struct {
	PageSize  *PageSize  `form:"pageSize,omitempty" json:"pageSize,omitempty"`
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// ListBatchMetricsDataForBatchMetricsDataIDsParams defines parameters for ListBatchMetricsDataForBatchMetricsDataIDs.
type ListBatchMetricsDataForBatchMetricsDataIDsParams struct {
	PageSize  *PageSize  `form:"pageSize,omitempty" json:"pageSize,omitempty"`
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// ListBranchesForProjectParams defines parameters for ListBranchesForProject.
type ListBranchesForProjectParams struct {
	// Name Filter branches by name
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// BranchType Filter branches by branchType
	BranchType *BranchType `form:"branchType,omitempty" json:"branchType,omitempty"`
	PageSize   *PageSize   `form:"pageSize,omitempty" json:"pageSize,omitempty"`
	PageToken  *PageToken  `form:"pageToken,omitempty" json:"pageToken,omitempty"`
	OrderBy    *OrderBy    `form:"orderBy,omitempty" json:"orderBy,omitempty"`
}

// ListBuildsForBranchesParams defines parameters for ListBuildsForBranches.
type ListBuildsForBranchesParams struct {
	PageSize  *PageSize  `form:"pageSize,omitempty" json:"pageSize,omitempty"`
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`
	OrderBy   *OrderBy   `form:"orderBy,omitempty" json:"orderBy,omitempty"`
}

// ListBatchesForBuildsParams defines parameters for ListBatchesForBuilds.
type ListBatchesForBuildsParams struct {
	PageSize  *PageSize  `form:"pageSize,omitempty" json:"pageSize,omitempty"`
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`
	OrderBy   *OrderBy   `form:"orderBy,omitempty" json:"orderBy,omitempty"`
}

// ListBuildsParams defines parameters for ListBuilds.
type ListBuildsParams struct {
	// Search A search query. Supports searching by branch_id, system_id
	Search *string `form:"search,omitempty" json:"search,omitempty"`

	// Text Filter builds by their name or description
	Text      *string    `form:"text,omitempty" json:"text,omitempty"`
	PageSize  *PageSize  `form:"pageSize,omitempty" json:"pageSize,omitempty"`
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`
	OrderBy   *OrderBy   `form:"orderBy,omitempty" json:"orderBy,omitempty"`
}

// ListExperienceTagsParams defines parameters for ListExperienceTags.
type ListExperienceTagsParams struct {
	// Name Filter experience tags by name. It is recommended to use orderBy=rank, so you get the most relevant results first.
	Name      *string                          `form:"name,omitempty" json:"name,omitempty"`
	OrderBy   *ListExperienceTagsParamsOrderBy `form:"orderBy,omitempty" json:"orderBy,omitempty"`
	PageSize  *PageSize                        `form:"pageSize,omitempty" json:"pageSize,omitempty"`
	PageToken *PageToken                       `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// ListExperienceTagsParamsOrderBy defines parameters for ListExperienceTags.
type ListExperienceTagsParamsOrderBy string

// ListExperiencesWithExperienceTagParams defines parameters for ListExperiencesWithExperienceTag.
type ListExperiencesWithExperienceTagParams struct {
	// Archived Filter by archived status.
	Archived  *bool      `form:"archived,omitempty" json:"archived,omitempty"`
	PageSize  *PageSize  `form:"pageSize,omitempty" json:"pageSize,omitempty"`
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// ListExperiencesParams defines parameters for ListExperiences.
type ListExperiencesParams struct {
	// Name Filter experiences by name
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// Text Filter experiences by a text string on experience name, experience description, or experience tag name
	Text *string `form:"text,omitempty" json:"text,omitempty"`

	// Search A search query. Supports searching by tag_id, test_suite_id, archived, profile, and system_id
	Search    *string            `form:"search,omitempty" json:"search,omitempty"`
	Archived  *bool              `form:"archived,omitempty" json:"archived,omitempty"`
	PageSize  *PageSizeUnbounded `form:"pageSize,omitempty" json:"pageSize,omitempty"`
	PageToken *PageToken         `form:"pageToken,omitempty" json:"pageToken,omitempty"`
	OrderBy   *OrderBy           `form:"orderBy,omitempty" json:"orderBy,omitempty"`
}

// ListExperienceTagsForExperienceParams defines parameters for ListExperienceTagsForExperience.
type ListExperienceTagsForExperienceParams struct {
	PageSize  *PageSize  `form:"pageSize,omitempty" json:"pageSize,omitempty"`
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// GetSystemsForExperienceParams defines parameters for GetSystemsForExperience.
type GetSystemsForExperienceParams struct {
	PageSize  *PageSize  `form:"pageSize,omitempty" json:"pageSize,omitempty"`
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// ListMetricsBuildsParams defines parameters for ListMetricsBuilds.
type ListMetricsBuildsParams struct {
	// SystemID A search query. Supports searching by system_id
	SystemID *openapi_types.UUID `form:"systemID,omitempty" json:"systemID,omitempty"`

	// Text Free text filter on the metrics build name.
	Text      *string    `form:"text,omitempty" json:"text,omitempty"`
	PageSize  *PageSize  `form:"pageSize,omitempty" json:"pageSize,omitempty"`
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`
	OrderBy   *OrderBy   `form:"orderBy,omitempty" json:"orderBy,omitempty"`
}

// GetSystemsForMetricsBuildParams defines parameters for GetSystemsForMetricsBuild.
type GetSystemsForMetricsBuildParams struct {
	PageSize  *PageSize  `form:"pageSize,omitempty" json:"pageSize,omitempty"`
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// ListReportsParams defines parameters for ListReports.
type ListReportsParams struct {
	// Search Filter based on branch_id, test_suite_id, created_at, status, associated_account
	Search *string `form:"search,omitempty" json:"search,omitempty"`

	// Text Filter reports by a text string (only supports batch id as of 3/21/2025)
	Text      *string    `form:"text,omitempty" json:"text,omitempty"`
	PageSize  *PageSize  `form:"pageSize,omitempty" json:"pageSize,omitempty"`
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`
	OrderBy   *OrderBy   `form:"orderBy,omitempty" json:"orderBy,omitempty"`
}

// ListLogsForReportParams defines parameters for ListLogsForReport.
type ListLogsForReportParams struct {
	PageSize  *PageSize  `form:"pageSize,omitempty" json:"pageSize,omitempty"`
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// ListReportMetricsParams defines parameters for ListReportMetrics.
type ListReportMetricsParams struct {
	PageSize  *PageSize  `form:"pageSize,omitempty" json:"pageSize,omitempty"`
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// ListReportMetricsForReportMetricIDsParams defines parameters for ListReportMetricsForReportMetricIDs.
type ListReportMetricsForReportMetricIDsParams struct {
	PageSize  *PageSize  `form:"pageSize,omitempty" json:"pageSize,omitempty"`
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// ListReportMetricsDataForReportMetricIDsParams defines parameters for ListReportMetricsDataForReportMetricIDs.
type ListReportMetricsDataForReportMetricIDsParams struct {
	PageSize  *PageSize  `form:"pageSize,omitempty" json:"pageSize,omitempty"`
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// ListTagsForReportMetricsParams defines parameters for ListTagsForReportMetrics.
type ListTagsForReportMetricsParams struct {
	PageSize  *PageSize  `form:"pageSize,omitempty" json:"pageSize,omitempty"`
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// ListReportMetricsDataParams defines parameters for ListReportMetricsData.
type ListReportMetricsDataParams struct {
	PageSize  *PageSize  `form:"pageSize,omitempty" json:"pageSize,omitempty"`
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// ListReportMetricsDataForReportMetricsDataIDsParams defines parameters for ListReportMetricsDataForReportMetricsDataIDs.
type ListReportMetricsDataForReportMetricsDataIDsParams struct {
	PageSize  *PageSize  `form:"pageSize,omitempty" json:"pageSize,omitempty"`
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// ListTestSuitesParams defines parameters for ListTestSuites.
type ListTestSuitesParams struct {
	// ExperienceIDs Only return test suites that contain the given experience id(s)
	ExperienceIDs *[]ExperienceID `form:"experienceIDs,omitempty" json:"experienceIDs,omitempty"`

	// SystemID Only return test suites that contain the given system id
	SystemID *openapi_types.UUID `form:"systemID,omitempty" json:"systemID,omitempty"`
	Archived *bool               `form:"archived,omitempty" json:"archived,omitempty"`

	// Name Filter test suites by name
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// Text Filter test suites by a text string on name and description
	Text      *string    `form:"text,omitempty" json:"text,omitempty"`
	PageSize  *PageSize  `form:"pageSize,omitempty" json:"pageSize,omitempty"`
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`
	OrderBy   *OrderBy   `form:"orderBy,omitempty" json:"orderBy,omitempty"`
}

// GetTestSuiteSummaryParams defines parameters for GetTestSuiteSummary.
type GetTestSuiteSummaryParams struct {
	PageSize  *PageSize  `form:"pageSize,omitempty" json:"pageSize,omitempty"`
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// ListBatchesForTestSuiteParams defines parameters for ListBatchesForTestSuite.
type ListBatchesForTestSuiteParams struct {
	PageSize  *PageSize  `form:"pageSize,omitempty" json:"pageSize,omitempty"`
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`
	OrderBy   *OrderBy   `form:"orderBy,omitempty" json:"orderBy,omitempty"`
}

// ListTestSuiteRevisionsParams defines parameters for ListTestSuiteRevisions.
type ListTestSuiteRevisionsParams struct {
	PageSize  *PageSize  `form:"pageSize,omitempty" json:"pageSize,omitempty"`
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// ListBatchesForTestSuiteRevisionParams defines parameters for ListBatchesForTestSuiteRevision.
type ListBatchesForTestSuiteRevisionParams struct {
	PageSize  *PageSize  `form:"pageSize,omitempty" json:"pageSize,omitempty"`
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`
	OrderBy   *OrderBy   `form:"orderBy,omitempty" json:"orderBy,omitempty"`
}

// ListParameterSweepsParams defines parameters for ListParameterSweeps.
type ListParameterSweepsParams struct {
	PageSize  *PageSize  `form:"pageSize,omitempty" json:"pageSize,omitempty"`
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`
	OrderBy   *OrderBy   `form:"orderBy,omitempty" json:"orderBy,omitempty"`
}

// ListSystemsParams defines parameters for ListSystems.
type ListSystemsParams struct {
	// Name Filter systems by name
	Name      *string    `form:"name,omitempty" json:"name,omitempty"`
	PageSize  *PageSize  `form:"pageSize,omitempty" json:"pageSize,omitempty"`
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`
	OrderBy   *OrderBy   `form:"orderBy,omitempty" json:"orderBy,omitempty"`
}

// ListBuildsForSystemParams defines parameters for ListBuildsForSystem.
type ListBuildsForSystemParams struct {
	PageSize  *PageSize  `form:"pageSize,omitempty" json:"pageSize,omitempty"`
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`
	OrderBy   *OrderBy   `form:"orderBy,omitempty" json:"orderBy,omitempty"`
}

// ListExperiencesForSystemParams defines parameters for ListExperiencesForSystem.
type ListExperiencesForSystemParams struct {
	// Archived Filter experiences by archived status
	Archived  *bool      `form:"archived,omitempty" json:"archived,omitempty"`
	PageSize  *PageSize  `form:"pageSize,omitempty" json:"pageSize,omitempty"`
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// ListViewSessionsParams defines parameters for ListViewSessions.
type ListViewSessionsParams struct {
	PageSize  *PageSize  `form:"pageSize,omitempty" json:"pageSize,omitempty"`
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`
	OrderBy   *OrderBy   `form:"orderBy,omitempty" json:"orderBy,omitempty"`
}

// CreateProjectJSONRequestBody defines body for CreateProject for application/json ContentType.
type CreateProjectJSONRequestBody = CreateProjectInput

// UpdateProjectJSONRequestBody defines body for UpdateProject for application/json ContentType.
type UpdateProjectJSONRequestBody = UpdateProjectInput

// CreateBatchJSONRequestBody defines body for CreateBatch for application/json ContentType.
type CreateBatchJSONRequestBody = BatchInput

// UpdateBatchJSONRequestBody defines body for UpdateBatch for application/json ContentType.
type UpdateBatchJSONRequestBody = UpdateBatchInput

// UpdateJobJSONRequestBody defines body for UpdateJob for application/json ContentType.
type UpdateJobJSONRequestBody = UpdateJobInput

// UpdateEventJSONRequestBody defines body for UpdateEvent for application/json ContentType.
type UpdateEventJSONRequestBody = UpdateEventInput

// RerunBatchJSONRequestBody defines body for RerunBatch for application/json ContentType.
type RerunBatchJSONRequestBody = RerunBatchInput

// CreateBranchForProjectJSONRequestBody defines body for CreateBranchForProject for application/json ContentType.
type CreateBranchForProjectJSONRequestBody = CreateBranchInput

// CreateBuildForBranchJSONRequestBody defines body for CreateBuildForBranch for application/json ContentType.
type CreateBuildForBranchJSONRequestBody = CreateBuildForBranchInput

// UpdateBuildJSONRequestBody defines body for UpdateBuild for application/json ContentType.
type UpdateBuildJSONRequestBody = UpdateBuildInput

// CreateExperienceTagJSONRequestBody defines body for CreateExperienceTag for application/json ContentType.
type CreateExperienceTagJSONRequestBody = CreateExperienceTagInput

// AddTagsToExperiencesJSONRequestBody defines body for AddTagsToExperiences for application/json ContentType.
type AddTagsToExperiencesJSONRequestBody = AddTagsToExperiencesInput

// UpdateExperienceTagJSONRequestBody defines body for UpdateExperienceTag for application/json ContentType.
type UpdateExperienceTagJSONRequestBody = UpdateExperienceTagInput

// CreateExperienceJSONRequestBody defines body for CreateExperience for application/json ContentType.
type CreateExperienceJSONRequestBody = CreateExperienceInput

// UpdateExperienceJSONRequestBody defines body for UpdateExperience for application/json ContentType.
type UpdateExperienceJSONRequestBody = UpdateExperienceInput

// DebugExperienceJSONRequestBody defines body for DebugExperience for application/json ContentType.
type DebugExperienceJSONRequestBody = DebugExperienceInput

// CreateMetricsBuildJSONRequestBody defines body for CreateMetricsBuild for application/json ContentType.
type CreateMetricsBuildJSONRequestBody = CreateMetricsBuildInput

// CreateReportJSONRequestBody defines body for CreateReport for application/json ContentType.
type CreateReportJSONRequestBody = ReportInput

// CreateTestSuiteJSONRequestBody defines body for CreateTestSuite for application/json ContentType.
type CreateTestSuiteJSONRequestBody = CreateTestSuiteInput

// AddTestSuitesToExperiencesJSONRequestBody defines body for AddTestSuitesToExperiences for application/json ContentType.
type AddTestSuitesToExperiencesJSONRequestBody = AddSuitesToExperiencesInput

// ReviseTestSuiteJSONRequestBody defines body for ReviseTestSuite for application/json ContentType.
type ReviseTestSuiteJSONRequestBody = ReviseTestSuiteInput

// AddExperiencesToTestSuiteJSONRequestBody defines body for AddExperiencesToTestSuite for application/json ContentType.
type AddExperiencesToTestSuiteJSONRequestBody = SelectExperiencesInput

// CreateBatchForTestSuiteJSONRequestBody defines body for CreateBatchForTestSuite for application/json ContentType.
type CreateBatchForTestSuiteJSONRequestBody = TestSuiteBatchInput

// RemoveExperiencesFromTestSuiteJSONRequestBody defines body for RemoveExperiencesFromTestSuite for application/json ContentType.
type RemoveExperiencesFromTestSuiteJSONRequestBody = SelectExperiencesInput

// CreateBatchForTestSuiteRevisionJSONRequestBody defines body for CreateBatchForTestSuiteRevision for application/json ContentType.
type CreateBatchForTestSuiteRevisionJSONRequestBody = TestSuiteBatchInput

// CreateParameterSweepJSONRequestBody defines body for CreateParameterSweep for application/json ContentType.
type CreateParameterSweepJSONRequestBody = ParameterSweepInput

// CreateSystemJSONRequestBody defines body for CreateSystem for application/json ContentType.
type CreateSystemJSONRequestBody = CreateSystemInput

// AddSystemsToExperiencesJSONRequestBody defines body for AddSystemsToExperiences for application/json ContentType.
type AddSystemsToExperiencesJSONRequestBody = MutateSystemsToExperienceInput

// RemoveSystemsFromExperiencesJSONRequestBody defines body for RemoveSystemsFromExperiences for application/json ContentType.
type RemoveSystemsFromExperiencesJSONRequestBody = MutateSystemsToExperienceInput

// UpdateSystemJSONRequestBody defines body for UpdateSystem for application/json ContentType.
type UpdateSystemJSONRequestBody = UpdateSystemInput

// CreateBuildForSystemJSONRequestBody defines body for CreateBuildForSystem for application/json ContentType.
type CreateBuildForSystemJSONRequestBody = CreateBuildForSystemInput

// ValidateExperienceLocationJSONRequestBody defines body for ValidateExperienceLocation for application/json ContentType.
type ValidateExperienceLocationJSONRequestBody = ExperienceLocation

// AsCreateBuildForBranchInput0 returns the union data inside the CreateBuildForBranchInput as a CreateBuildForBranchInput0
func (t CreateBuildForBranchInput) AsCreateBuildForBranchInput0() (CreateBuildForBranchInput0, error) {
	var body CreateBuildForBranchInput0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateBuildForBranchInput0 overwrites any union data inside the CreateBuildForBranchInput as the provided CreateBuildForBranchInput0
func (t *CreateBuildForBranchInput) FromCreateBuildForBranchInput0(v CreateBuildForBranchInput0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateBuildForBranchInput0 performs a merge with any union data inside the CreateBuildForBranchInput, using the provided CreateBuildForBranchInput0
func (t *CreateBuildForBranchInput) MergeCreateBuildForBranchInput0(v CreateBuildForBranchInput0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateBuildForBranchInput1 returns the union data inside the CreateBuildForBranchInput as a CreateBuildForBranchInput1
func (t CreateBuildForBranchInput) AsCreateBuildForBranchInput1() (CreateBuildForBranchInput1, error) {
	var body CreateBuildForBranchInput1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateBuildForBranchInput1 overwrites any union data inside the CreateBuildForBranchInput as the provided CreateBuildForBranchInput1
func (t *CreateBuildForBranchInput) FromCreateBuildForBranchInput1(v CreateBuildForBranchInput1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateBuildForBranchInput1 performs a merge with any union data inside the CreateBuildForBranchInput, using the provided CreateBuildForBranchInput1
func (t *CreateBuildForBranchInput) MergeCreateBuildForBranchInput1(v CreateBuildForBranchInput1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateBuildForBranchInput) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.AssociatedAccount != nil {
		object["associatedAccount"], err = json.Marshal(t.AssociatedAccount)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'associatedAccount': %w", err)
		}
	}

	if t.BuildSpecification != nil {
		object["buildSpecification"], err = json.Marshal(t.BuildSpecification)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'buildSpecification': %w", err)
		}
	}

	if t.Description != nil {
		object["description"], err = json.Marshal(t.Description)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'description': %w", err)
		}
	}

	if t.ImageUri != nil {
		object["imageUri"], err = json.Marshal(t.ImageUri)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'imageUri': %w", err)
		}
	}

	if t.Name != nil {
		object["name"], err = json.Marshal(t.Name)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'name': %w", err)
		}
	}

	object["systemID"], err = json.Marshal(t.SystemID)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'systemID': %w", err)
	}

	object["version"], err = json.Marshal(t.Version)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'version': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *CreateBuildForBranchInput) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["associatedAccount"]; found {
		err = json.Unmarshal(raw, &t.AssociatedAccount)
		if err != nil {
			return fmt.Errorf("error reading 'associatedAccount': %w", err)
		}
	}

	if raw, found := object["buildSpecification"]; found {
		err = json.Unmarshal(raw, &t.BuildSpecification)
		if err != nil {
			return fmt.Errorf("error reading 'buildSpecification': %w", err)
		}
	}

	if raw, found := object["description"]; found {
		err = json.Unmarshal(raw, &t.Description)
		if err != nil {
			return fmt.Errorf("error reading 'description': %w", err)
		}
	}

	if raw, found := object["imageUri"]; found {
		err = json.Unmarshal(raw, &t.ImageUri)
		if err != nil {
			return fmt.Errorf("error reading 'imageUri': %w", err)
		}
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &t.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
	}

	if raw, found := object["systemID"]; found {
		err = json.Unmarshal(raw, &t.SystemID)
		if err != nil {
			return fmt.Errorf("error reading 'systemID': %w", err)
		}
	}

	if raw, found := object["version"]; found {
		err = json.Unmarshal(raw, &t.Version)
		if err != nil {
			return fmt.Errorf("error reading 'version': %w", err)
		}
	}

	return err
}

// AsCreateBuildForSystemInput0 returns the union data inside the CreateBuildForSystemInput as a CreateBuildForSystemInput0
func (t CreateBuildForSystemInput) AsCreateBuildForSystemInput0() (CreateBuildForSystemInput0, error) {
	var body CreateBuildForSystemInput0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateBuildForSystemInput0 overwrites any union data inside the CreateBuildForSystemInput as the provided CreateBuildForSystemInput0
func (t *CreateBuildForSystemInput) FromCreateBuildForSystemInput0(v CreateBuildForSystemInput0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateBuildForSystemInput0 performs a merge with any union data inside the CreateBuildForSystemInput, using the provided CreateBuildForSystemInput0
func (t *CreateBuildForSystemInput) MergeCreateBuildForSystemInput0(v CreateBuildForSystemInput0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateBuildForSystemInput1 returns the union data inside the CreateBuildForSystemInput as a CreateBuildForSystemInput1
func (t CreateBuildForSystemInput) AsCreateBuildForSystemInput1() (CreateBuildForSystemInput1, error) {
	var body CreateBuildForSystemInput1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateBuildForSystemInput1 overwrites any union data inside the CreateBuildForSystemInput as the provided CreateBuildForSystemInput1
func (t *CreateBuildForSystemInput) FromCreateBuildForSystemInput1(v CreateBuildForSystemInput1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateBuildForSystemInput1 performs a merge with any union data inside the CreateBuildForSystemInput, using the provided CreateBuildForSystemInput1
func (t *CreateBuildForSystemInput) MergeCreateBuildForSystemInput1(v CreateBuildForSystemInput1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateBuildForSystemInput) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.AssociatedAccount != nil {
		object["associatedAccount"], err = json.Marshal(t.AssociatedAccount)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'associatedAccount': %w", err)
		}
	}

	object["branchID"], err = json.Marshal(t.BranchID)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'branchID': %w", err)
	}

	if t.BuildSpecification != nil {
		object["buildSpecification"], err = json.Marshal(t.BuildSpecification)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'buildSpecification': %w", err)
		}
	}

	if t.Description != nil {
		object["description"], err = json.Marshal(t.Description)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'description': %w", err)
		}
	}

	if t.ImageUri != nil {
		object["imageUri"], err = json.Marshal(t.ImageUri)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'imageUri': %w", err)
		}
	}

	if t.Name != nil {
		object["name"], err = json.Marshal(t.Name)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'name': %w", err)
		}
	}

	if t.TriggeredVia != nil {
		object["triggeredVia"], err = json.Marshal(t.TriggeredVia)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'triggeredVia': %w", err)
		}
	}

	object["version"], err = json.Marshal(t.Version)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'version': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *CreateBuildForSystemInput) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["associatedAccount"]; found {
		err = json.Unmarshal(raw, &t.AssociatedAccount)
		if err != nil {
			return fmt.Errorf("error reading 'associatedAccount': %w", err)
		}
	}

	if raw, found := object["branchID"]; found {
		err = json.Unmarshal(raw, &t.BranchID)
		if err != nil {
			return fmt.Errorf("error reading 'branchID': %w", err)
		}
	}

	if raw, found := object["buildSpecification"]; found {
		err = json.Unmarshal(raw, &t.BuildSpecification)
		if err != nil {
			return fmt.Errorf("error reading 'buildSpecification': %w", err)
		}
	}

	if raw, found := object["description"]; found {
		err = json.Unmarshal(raw, &t.Description)
		if err != nil {
			return fmt.Errorf("error reading 'description': %w", err)
		}
	}

	if raw, found := object["imageUri"]; found {
		err = json.Unmarshal(raw, &t.ImageUri)
		if err != nil {
			return fmt.Errorf("error reading 'imageUri': %w", err)
		}
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &t.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
	}

	if raw, found := object["triggeredVia"]; found {
		err = json.Unmarshal(raw, &t.TriggeredVia)
		if err != nil {
			return fmt.Errorf("error reading 'triggeredVia': %w", err)
		}
	}

	if raw, found := object["version"]; found {
		err = json.Unmarshal(raw, &t.Version)
		if err != nil {
			return fmt.Errorf("error reading 'version': %w", err)
		}
	}

	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// Health request
	Health(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListProjects request
	ListProjects(ctx context.Context, params *ListProjectsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateProjectWithBody request with any body
	CreateProjectWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateProject(ctx context.Context, body CreateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArchiveProject request
	ArchiveProject(ctx context.Context, projectID ProjectID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProject request
	GetProject(ctx context.Context, projectID ProjectID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateProjectWithBody request with any body
	UpdateProjectWithBody(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateProject(ctx context.Context, projectID ProjectID, body UpdateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBatches request
	ListBatches(ctx context.Context, projectID ProjectID, params *ListBatchesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBatchWithBody request with any body
	CreateBatchWithBody(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateBatch(ctx context.Context, projectID ProjectID, body CreateBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAllJobs request
	ListAllJobs(ctx context.Context, projectID ProjectID, params *ListAllJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBatchAccounts request
	ListBatchAccounts(ctx context.Context, projectID ProjectID, params *ListBatchAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBatch request
	GetBatch(ctx context.Context, projectID ProjectID, batchID BatchID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateBatchWithBody request with any body
	UpdateBatchWithBody(ctx context.Context, projectID ProjectID, batchID BatchID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateBatch(ctx context.Context, projectID ProjectID, batchID BatchID, body UpdateBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CancelBatch request
	CancelBatch(ctx context.Context, projectID ProjectID, batchID BatchID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CompareBatches request
	CompareBatches(ctx context.Context, projectID ProjectID, batchID BatchID, otherBatchID BatchID, params *CompareBatchesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBatchErrors request
	ListBatchErrors(ctx context.Context, projectID ProjectID, batchID BatchID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListJobs request
	ListJobs(ctx context.Context, projectID ProjectID, batchID BatchID, params *ListJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetJob request
	GetJob(ctx context.Context, projectID ProjectID, batchID BatchID, jobID JobID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateJobWithBody request with any body
	UpdateJobWithBody(ctx context.Context, projectID ProjectID, batchID BatchID, jobID JobID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateJob(ctx context.Context, projectID ProjectID, batchID BatchID, jobID JobID, body UpdateJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListEventTagsForJob request
	ListEventTagsForJob(ctx context.Context, projectID ProjectID, batchID BatchID, jobID JobID, params *ListEventTagsForJobParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListEventsForJob request
	ListEventsForJob(ctx context.Context, projectID ProjectID, batchID BatchID, jobID JobID, params *ListEventsForJobParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEventForJob request
	GetEventForJob(ctx context.Context, projectID ProjectID, batchID BatchID, jobID JobID, eventID EventID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateEventWithBody request with any body
	UpdateEventWithBody(ctx context.Context, projectID ProjectID, batchID BatchID, jobID JobID, eventID EventID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateEvent(ctx context.Context, projectID ProjectID, batchID BatchID, jobID JobID, eventID EventID, body UpdateEventJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListJobLogsForJob request
	ListJobLogsForJob(ctx context.Context, projectID ProjectID, batchID BatchID, jobID JobID, params *ListJobLogsForJobParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteJobLog request
	DeleteJobLog(ctx context.Context, projectID ProjectID, batchID BatchID, jobID JobID, logID LogID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetJobLog request
	GetJobLog(ctx context.Context, projectID ProjectID, batchID BatchID, jobID JobID, logID LogID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListMetricsForJob request
	ListMetricsForJob(ctx context.Context, projectID ProjectID, batchID BatchID, jobID JobID, params *ListMetricsForJobParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListMetricsForMetricIDs request
	ListMetricsForMetricIDs(ctx context.Context, projectID ProjectID, batchID BatchID, jobID JobID, metricID []MetricID, params *ListMetricsForMetricIDsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListMetricsDataForMetricIDs request
	ListMetricsDataForMetricIDs(ctx context.Context, projectID ProjectID, batchID BatchID, jobID JobID, metricID []MetricID, params *ListMetricsDataForMetricIDsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListTagsForJobMetrics request
	ListTagsForJobMetrics(ctx context.Context, projectID ProjectID, batchID BatchID, jobID JobID, metricID []MetricID, params *ListTagsForJobMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListMetricsDataForJob request
	ListMetricsDataForJob(ctx context.Context, projectID ProjectID, batchID BatchID, jobID JobID, params *ListMetricsDataForJobParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListMetricsDataForMetricsDataIDs request
	ListMetricsDataForMetricsDataIDs(ctx context.Context, projectID ProjectID, batchID BatchID, jobID JobID, metricsDataID []MetricsDataID, params *ListMetricsDataForMetricsDataIDsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBatchLogsForBatch request
	ListBatchLogsForBatch(ctx context.Context, projectID ProjectID, batchID BatchID, params *ListBatchLogsForBatchParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteBatchLog request
	DeleteBatchLog(ctx context.Context, projectID ProjectID, batchID BatchID, logID LogID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBatchLog request
	GetBatchLog(ctx context.Context, projectID ProjectID, batchID BatchID, logID LogID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBatchMetrics request
	ListBatchMetrics(ctx context.Context, projectID ProjectID, batchID BatchID, params *ListBatchMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBatchMetricsForBatchMetricIDs request
	ListBatchMetricsForBatchMetricIDs(ctx context.Context, projectID ProjectID, batchID BatchID, metricID []MetricID, params *ListBatchMetricsForBatchMetricIDsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBatchMetricsDataForBatchMetricIDs request
	ListBatchMetricsDataForBatchMetricIDs(ctx context.Context, projectID ProjectID, batchID BatchID, metricID []MetricID, params *ListBatchMetricsDataForBatchMetricIDsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListTagsForBatchMetrics request
	ListTagsForBatchMetrics(ctx context.Context, projectID ProjectID, batchID BatchID, metricID []MetricID, params *ListTagsForBatchMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBatchMetricsData request
	ListBatchMetricsData(ctx context.Context, projectID ProjectID, batchID BatchID, params *ListBatchMetricsDataParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBatchMetricsDataForBatchMetricsDataIDs request
	ListBatchMetricsDataForBatchMetricsDataIDs(ctx context.Context, projectID ProjectID, batchID BatchID, metricsDataID []MetricsDataID, params *ListBatchMetricsDataForBatchMetricsDataIDsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RerunBatchWithBody request with any body
	RerunBatchWithBody(ctx context.Context, projectID ProjectID, batchID BatchID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RerunBatch(ctx context.Context, projectID ProjectID, batchID BatchID, body RerunBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBatchSuggestions request
	GetBatchSuggestions(ctx context.Context, projectID ProjectID, batchID BatchID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBranchesForProject request
	ListBranchesForProject(ctx context.Context, projectID ProjectID, params *ListBranchesForProjectParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBranchForProjectWithBody request with any body
	CreateBranchForProjectWithBody(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateBranchForProject(ctx context.Context, projectID ProjectID, body CreateBranchForProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteBranchForProject request
	DeleteBranchForProject(ctx context.Context, projectID ProjectID, branchID BranchID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBranchForProject request
	GetBranchForProject(ctx context.Context, projectID ProjectID, branchID BranchID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBuildsForBranches request
	ListBuildsForBranches(ctx context.Context, projectID ProjectID, branchID []BranchID, params *ListBuildsForBranchesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBuildForBranchWithBody request with any body
	CreateBuildForBranchWithBody(ctx context.Context, projectID ProjectID, branchID BranchID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateBuildForBranch(ctx context.Context, projectID ProjectID, branchID BranchID, body CreateBuildForBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteBuildForBranch request
	DeleteBuildForBranch(ctx context.Context, projectID ProjectID, branchID BranchID, buildID BuildID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBuildForBranch request
	GetBuildForBranch(ctx context.Context, projectID ProjectID, branchID BranchID, buildID BuildID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBatchesForBuilds request
	ListBatchesForBuilds(ctx context.Context, projectID ProjectID, branchID BranchID, buildID []BuildID, params *ListBatchesForBuildsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBuilds request
	ListBuilds(ctx context.Context, projectID ProjectID, params *ListBuildsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBuildAccounts request
	ListBuildAccounts(ctx context.Context, projectID ProjectID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBuild request
	GetBuild(ctx context.Context, projectID ProjectID, buildID BuildID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateBuildWithBody request with any body
	UpdateBuildWithBody(ctx context.Context, projectID ProjectID, buildID BuildID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateBuild(ctx context.Context, projectID ProjectID, buildID BuildID, body UpdateBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListExperienceTags request
	ListExperienceTags(ctx context.Context, projectID ProjectID, params *ListExperienceTagsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateExperienceTagWithBody request with any body
	CreateExperienceTagWithBody(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateExperienceTag(ctx context.Context, projectID ProjectID, body CreateExperienceTagJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddTagsToExperiencesWithBody request with any body
	AddTagsToExperiencesWithBody(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddTagsToExperiences(ctx context.Context, projectID ProjectID, body AddTagsToExperiencesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteExperienceTag request
	DeleteExperienceTag(ctx context.Context, projectID ProjectID, experienceTagID ExperienceTagID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetExperienceTag request
	GetExperienceTag(ctx context.Context, projectID ProjectID, experienceTagID ExperienceTagID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateExperienceTagWithBody request with any body
	UpdateExperienceTagWithBody(ctx context.Context, projectID ProjectID, experienceTagID ExperienceTagID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateExperienceTag(ctx context.Context, projectID ProjectID, experienceTagID ExperienceTagID, body UpdateExperienceTagJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListExperiencesWithExperienceTag request
	ListExperiencesWithExperienceTag(ctx context.Context, projectID ProjectID, experienceTagID ExperienceTagID, params *ListExperiencesWithExperienceTagParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveExperienceTagFromExperience request
	RemoveExperienceTagFromExperience(ctx context.Context, projectID ProjectID, experienceTagID ExperienceTagID, experienceID ExperienceID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddExperienceTagToExperience request
	AddExperienceTagToExperience(ctx context.Context, projectID ProjectID, experienceTagID ExperienceTagID, experienceID ExperienceID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListExperiences request
	ListExperiences(ctx context.Context, projectID ProjectID, params *ListExperiencesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateExperienceWithBody request with any body
	CreateExperienceWithBody(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateExperience(ctx context.Context, projectID ProjectID, body CreateExperienceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArchiveExperience request
	ArchiveExperience(ctx context.Context, projectID ProjectID, experienceID ExperienceID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetExperience request
	GetExperience(ctx context.Context, projectID ProjectID, experienceID ExperienceID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateExperienceWithBody request with any body
	UpdateExperienceWithBody(ctx context.Context, projectID ProjectID, experienceID ExperienceID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateExperience(ctx context.Context, projectID ProjectID, experienceID ExperienceID, body UpdateExperienceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DebugExperienceWithBody request with any body
	DebugExperienceWithBody(ctx context.Context, projectID ProjectID, experienceID ExperienceID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DebugExperience(ctx context.Context, projectID ProjectID, experienceID ExperienceID, body DebugExperienceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListExperienceTagsForExperience request
	ListExperienceTagsForExperience(ctx context.Context, projectID ProjectID, experienceID ExperienceID, params *ListExperienceTagsForExperienceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RestoreExperience request
	RestoreExperience(ctx context.Context, projectID ProjectID, experienceID ExperienceID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemsForExperience request
	GetSystemsForExperience(ctx context.Context, projectID ProjectID, experienceID ExperienceID, params *GetSystemsForExperienceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListMetricsBuilds request
	ListMetricsBuilds(ctx context.Context, projectID ProjectID, params *ListMetricsBuildsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateMetricsBuildWithBody request with any body
	CreateMetricsBuildWithBody(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateMetricsBuild(ctx context.Context, projectID ProjectID, body CreateMetricsBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMetricsBuild request
	GetMetricsBuild(ctx context.Context, projectID ProjectID, metricsBuildID MetricsBuildID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemsForMetricsBuild request
	GetSystemsForMetricsBuild(ctx context.Context, projectID ProjectID, metricsBuildID MetricsBuildID, params *GetSystemsForMetricsBuildParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListServiceProfiles request
	ListServiceProfiles(ctx context.Context, projectID ProjectID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListReports request
	ListReports(ctx context.Context, projectID ProjectID, params *ListReportsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateReportWithBody request with any body
	CreateReportWithBody(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateReport(ctx context.Context, projectID ProjectID, body CreateReportJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListReportAccounts request
	ListReportAccounts(ctx context.Context, projectID ProjectID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReport request
	GetReport(ctx context.Context, projectID ProjectID, reportID ReportID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListLogsForReport request
	ListLogsForReport(ctx context.Context, projectID ProjectID, reportID ReportID, params *ListLogsForReportParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReportLog request
	GetReportLog(ctx context.Context, projectID ProjectID, reportID ReportID, logID LogID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListReportMetrics request
	ListReportMetrics(ctx context.Context, projectID ProjectID, reportID ReportID, params *ListReportMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListReportMetricsForReportMetricIDs request
	ListReportMetricsForReportMetricIDs(ctx context.Context, projectID ProjectID, reportID ReportID, metricID []MetricID, params *ListReportMetricsForReportMetricIDsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListReportMetricsDataForReportMetricIDs request
	ListReportMetricsDataForReportMetricIDs(ctx context.Context, projectID ProjectID, reportID ReportID, metricID []MetricID, params *ListReportMetricsDataForReportMetricIDsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListTagsForReportMetrics request
	ListTagsForReportMetrics(ctx context.Context, projectID ProjectID, reportID ReportID, metricID []MetricID, params *ListTagsForReportMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListReportMetricsData request
	ListReportMetricsData(ctx context.Context, projectID ProjectID, reportID ReportID, params *ListReportMetricsDataParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListReportMetricsDataForReportMetricsDataIDs request
	ListReportMetricsDataForReportMetricsDataIDs(ctx context.Context, projectID ProjectID, reportID ReportID, metricsDataID []MetricsDataID, params *ListReportMetricsDataForReportMetricsDataIDsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListTestSuites request
	ListTestSuites(ctx context.Context, projectID ProjectID, params *ListTestSuitesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTestSuiteWithBody request with any body
	CreateTestSuiteWithBody(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTestSuite(ctx context.Context, projectID ProjectID, body CreateTestSuiteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddTestSuitesToExperiencesWithBody request with any body
	AddTestSuitesToExperiencesWithBody(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddTestSuitesToExperiences(ctx context.Context, projectID ProjectID, body AddTestSuitesToExperiencesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTestSuiteSummary request
	GetTestSuiteSummary(ctx context.Context, projectID ProjectID, params *GetTestSuiteSummaryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArchiveTestSuite request
	ArchiveTestSuite(ctx context.Context, projectID ProjectID, testSuiteID TestSuiteID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTestSuite request
	GetTestSuite(ctx context.Context, projectID ProjectID, testSuiteID TestSuiteID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReviseTestSuiteWithBody request with any body
	ReviseTestSuiteWithBody(ctx context.Context, projectID ProjectID, testSuiteID TestSuiteID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReviseTestSuite(ctx context.Context, projectID ProjectID, testSuiteID TestSuiteID, body ReviseTestSuiteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddExperiencesToTestSuiteWithBody request with any body
	AddExperiencesToTestSuiteWithBody(ctx context.Context, projectID ProjectID, testSuiteID TestSuiteID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddExperiencesToTestSuite(ctx context.Context, projectID ProjectID, testSuiteID TestSuiteID, body AddExperiencesToTestSuiteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBatchesForTestSuite request
	ListBatchesForTestSuite(ctx context.Context, projectID ProjectID, testSuiteID TestSuiteID, params *ListBatchesForTestSuiteParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBatchForTestSuiteWithBody request with any body
	CreateBatchForTestSuiteWithBody(ctx context.Context, projectID ProjectID, testSuiteID TestSuiteID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateBatchForTestSuite(ctx context.Context, projectID ProjectID, testSuiteID TestSuiteID, body CreateBatchForTestSuiteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveExperiencesFromTestSuiteWithBody request with any body
	RemoveExperiencesFromTestSuiteWithBody(ctx context.Context, projectID ProjectID, testSuiteID TestSuiteID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RemoveExperiencesFromTestSuite(ctx context.Context, projectID ProjectID, testSuiteID TestSuiteID, body RemoveExperiencesFromTestSuiteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RestoreTestSuite request
	RestoreTestSuite(ctx context.Context, projectID ProjectID, testSuiteID TestSuiteID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListTestSuiteRevisions request
	ListTestSuiteRevisions(ctx context.Context, projectID ProjectID, testSuiteID TestSuiteID, params *ListTestSuiteRevisionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTestSuiteRevision request
	GetTestSuiteRevision(ctx context.Context, projectID ProjectID, testSuiteID TestSuiteID, revision TestSuiteRevision, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBatchesForTestSuiteRevision request
	ListBatchesForTestSuiteRevision(ctx context.Context, projectID ProjectID, testSuiteID TestSuiteID, revision TestSuiteRevision, params *ListBatchesForTestSuiteRevisionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBatchForTestSuiteRevisionWithBody request with any body
	CreateBatchForTestSuiteRevisionWithBody(ctx context.Context, projectID ProjectID, testSuiteID TestSuiteID, revision TestSuiteRevision, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateBatchForTestSuiteRevision(ctx context.Context, projectID ProjectID, testSuiteID TestSuiteID, revision TestSuiteRevision, body CreateBatchForTestSuiteRevisionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListParameterSweeps request
	ListParameterSweeps(ctx context.Context, projectID ProjectID, params *ListParameterSweepsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateParameterSweepWithBody request with any body
	CreateParameterSweepWithBody(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateParameterSweep(ctx context.Context, projectID ProjectID, body CreateParameterSweepJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSweepAccounts request
	ListSweepAccounts(ctx context.Context, projectID ProjectID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetParameterSweep request
	GetParameterSweep(ctx context.Context, projectID ProjectID, sweepID ParameterSweepID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CancelParameterSweep request
	CancelParameterSweep(ctx context.Context, projectID ProjectID, sweepID ParameterSweepID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSystems request
	ListSystems(ctx context.Context, projectID ProjectID, params *ListSystemsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSystemWithBody request with any body
	CreateSystemWithBody(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSystem(ctx context.Context, projectID ProjectID, body CreateSystemJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddSystemsToExperiencesWithBody request with any body
	AddSystemsToExperiencesWithBody(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddSystemsToExperiences(ctx context.Context, projectID ProjectID, body AddSystemsToExperiencesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveSystemsFromExperiencesWithBody request with any body
	RemoveSystemsFromExperiencesWithBody(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RemoveSystemsFromExperiences(ctx context.Context, projectID ProjectID, body RemoveSystemsFromExperiencesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArchiveSystem request
	ArchiveSystem(ctx context.Context, projectID ProjectID, systemID SystemID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystem request
	GetSystem(ctx context.Context, projectID ProjectID, systemID SystemID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSystemWithBody request with any body
	UpdateSystemWithBody(ctx context.Context, projectID ProjectID, systemID SystemID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSystem(ctx context.Context, projectID ProjectID, systemID SystemID, body UpdateSystemJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBuildsForSystem request
	ListBuildsForSystem(ctx context.Context, projectID ProjectID, systemID SystemID, params *ListBuildsForSystemParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBuildForSystemWithBody request with any body
	CreateBuildForSystemWithBody(ctx context.Context, projectID ProjectID, systemID SystemID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateBuildForSystem(ctx context.Context, projectID ProjectID, systemID SystemID, body CreateBuildForSystemJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBuildForSystem request
	GetBuildForSystem(ctx context.Context, projectID ProjectID, systemID SystemID, buildID BuildID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListExperiencesForSystem request
	ListExperiencesForSystem(ctx context.Context, projectID ProjectID, systemID SystemID, params *ListExperiencesForSystemParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveSystemFromExperience request
	RemoveSystemFromExperience(ctx context.Context, projectID ProjectID, systemID SystemID, experienceID ExperienceID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddSystemToExperience request
	AddSystemToExperience(ctx context.Context, projectID ProjectID, systemID SystemID, experienceID ExperienceID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveSystemFromMetricsBuild request
	RemoveSystemFromMetricsBuild(ctx context.Context, projectID ProjectID, systemID SystemID, metricsBuildID MetricsBuildID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddSystemToMetricsBuild request
	AddSystemToMetricsBuild(ctx context.Context, projectID ProjectID, systemID SystemID, metricsBuildID MetricsBuildID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetQuota request
	GetQuota(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ValidateExperienceLocationWithBody request with any body
	ValidateExperienceLocationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ValidateExperienceLocation(ctx context.Context, body ValidateExperienceLocationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListViewSessions request
	ListViewSessions(ctx context.Context, params *ListViewSessionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateViewSession request
	CreateViewSession(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetViewSession request
	GetViewSession(ctx context.Context, viewSessionID ViewSessionID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateViewUpdateWithBody request with any body
	CreateViewUpdateWithBody(ctx context.Context, viewSessionID ViewSessionID, viewUpdateID ViewUpdateID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) Health(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHealthRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListProjects(ctx context.Context, params *ListProjectsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListProjectsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProjectWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProjectRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProject(ctx context.Context, body CreateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProjectRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveProject(ctx context.Context, projectID ProjectID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveProjectRequest(c.Server, projectID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProject(ctx context.Context, projectID ProjectID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProjectRequest(c.Server, projectID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProjectWithBody(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProjectRequestWithBody(c.Server, projectID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProject(ctx context.Context, projectID ProjectID, body UpdateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProjectRequest(c.Server, projectID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBatches(ctx context.Context, projectID ProjectID, params *ListBatchesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBatchesRequest(c.Server, projectID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBatchWithBody(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBatchRequestWithBody(c.Server, projectID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBatch(ctx context.Context, projectID ProjectID, body CreateBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBatchRequest(c.Server, projectID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAllJobs(ctx context.Context, projectID ProjectID, params *ListAllJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAllJobsRequest(c.Server, projectID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBatchAccounts(ctx context.Context, projectID ProjectID, params *ListBatchAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBatchAccountsRequest(c.Server, projectID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBatch(ctx context.Context, projectID ProjectID, batchID BatchID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBatchRequest(c.Server, projectID, batchID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateBatchWithBody(ctx context.Context, projectID ProjectID, batchID BatchID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateBatchRequestWithBody(c.Server, projectID, batchID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateBatch(ctx context.Context, projectID ProjectID, batchID BatchID, body UpdateBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateBatchRequest(c.Server, projectID, batchID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelBatch(ctx context.Context, projectID ProjectID, batchID BatchID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelBatchRequest(c.Server, projectID, batchID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CompareBatches(ctx context.Context, projectID ProjectID, batchID BatchID, otherBatchID BatchID, params *CompareBatchesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCompareBatchesRequest(c.Server, projectID, batchID, otherBatchID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBatchErrors(ctx context.Context, projectID ProjectID, batchID BatchID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBatchErrorsRequest(c.Server, projectID, batchID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListJobs(ctx context.Context, projectID ProjectID, batchID BatchID, params *ListJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListJobsRequest(c.Server, projectID, batchID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetJob(ctx context.Context, projectID ProjectID, batchID BatchID, jobID JobID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetJobRequest(c.Server, projectID, batchID, jobID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateJobWithBody(ctx context.Context, projectID ProjectID, batchID BatchID, jobID JobID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateJobRequestWithBody(c.Server, projectID, batchID, jobID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateJob(ctx context.Context, projectID ProjectID, batchID BatchID, jobID JobID, body UpdateJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateJobRequest(c.Server, projectID, batchID, jobID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListEventTagsForJob(ctx context.Context, projectID ProjectID, batchID BatchID, jobID JobID, params *ListEventTagsForJobParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListEventTagsForJobRequest(c.Server, projectID, batchID, jobID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListEventsForJob(ctx context.Context, projectID ProjectID, batchID BatchID, jobID JobID, params *ListEventsForJobParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListEventsForJobRequest(c.Server, projectID, batchID, jobID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEventForJob(ctx context.Context, projectID ProjectID, batchID BatchID, jobID JobID, eventID EventID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEventForJobRequest(c.Server, projectID, batchID, jobID, eventID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateEventWithBody(ctx context.Context, projectID ProjectID, batchID BatchID, jobID JobID, eventID EventID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateEventRequestWithBody(c.Server, projectID, batchID, jobID, eventID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateEvent(ctx context.Context, projectID ProjectID, batchID BatchID, jobID JobID, eventID EventID, body UpdateEventJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateEventRequest(c.Server, projectID, batchID, jobID, eventID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListJobLogsForJob(ctx context.Context, projectID ProjectID, batchID BatchID, jobID JobID, params *ListJobLogsForJobParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListJobLogsForJobRequest(c.Server, projectID, batchID, jobID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteJobLog(ctx context.Context, projectID ProjectID, batchID BatchID, jobID JobID, logID LogID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteJobLogRequest(c.Server, projectID, batchID, jobID, logID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetJobLog(ctx context.Context, projectID ProjectID, batchID BatchID, jobID JobID, logID LogID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetJobLogRequest(c.Server, projectID, batchID, jobID, logID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListMetricsForJob(ctx context.Context, projectID ProjectID, batchID BatchID, jobID JobID, params *ListMetricsForJobParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListMetricsForJobRequest(c.Server, projectID, batchID, jobID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListMetricsForMetricIDs(ctx context.Context, projectID ProjectID, batchID BatchID, jobID JobID, metricID []MetricID, params *ListMetricsForMetricIDsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListMetricsForMetricIDsRequest(c.Server, projectID, batchID, jobID, metricID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListMetricsDataForMetricIDs(ctx context.Context, projectID ProjectID, batchID BatchID, jobID JobID, metricID []MetricID, params *ListMetricsDataForMetricIDsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListMetricsDataForMetricIDsRequest(c.Server, projectID, batchID, jobID, metricID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListTagsForJobMetrics(ctx context.Context, projectID ProjectID, batchID BatchID, jobID JobID, metricID []MetricID, params *ListTagsForJobMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListTagsForJobMetricsRequest(c.Server, projectID, batchID, jobID, metricID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListMetricsDataForJob(ctx context.Context, projectID ProjectID, batchID BatchID, jobID JobID, params *ListMetricsDataForJobParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListMetricsDataForJobRequest(c.Server, projectID, batchID, jobID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListMetricsDataForMetricsDataIDs(ctx context.Context, projectID ProjectID, batchID BatchID, jobID JobID, metricsDataID []MetricsDataID, params *ListMetricsDataForMetricsDataIDsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListMetricsDataForMetricsDataIDsRequest(c.Server, projectID, batchID, jobID, metricsDataID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBatchLogsForBatch(ctx context.Context, projectID ProjectID, batchID BatchID, params *ListBatchLogsForBatchParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBatchLogsForBatchRequest(c.Server, projectID, batchID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteBatchLog(ctx context.Context, projectID ProjectID, batchID BatchID, logID LogID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteBatchLogRequest(c.Server, projectID, batchID, logID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBatchLog(ctx context.Context, projectID ProjectID, batchID BatchID, logID LogID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBatchLogRequest(c.Server, projectID, batchID, logID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBatchMetrics(ctx context.Context, projectID ProjectID, batchID BatchID, params *ListBatchMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBatchMetricsRequest(c.Server, projectID, batchID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBatchMetricsForBatchMetricIDs(ctx context.Context, projectID ProjectID, batchID BatchID, metricID []MetricID, params *ListBatchMetricsForBatchMetricIDsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBatchMetricsForBatchMetricIDsRequest(c.Server, projectID, batchID, metricID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBatchMetricsDataForBatchMetricIDs(ctx context.Context, projectID ProjectID, batchID BatchID, metricID []MetricID, params *ListBatchMetricsDataForBatchMetricIDsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBatchMetricsDataForBatchMetricIDsRequest(c.Server, projectID, batchID, metricID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListTagsForBatchMetrics(ctx context.Context, projectID ProjectID, batchID BatchID, metricID []MetricID, params *ListTagsForBatchMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListTagsForBatchMetricsRequest(c.Server, projectID, batchID, metricID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBatchMetricsData(ctx context.Context, projectID ProjectID, batchID BatchID, params *ListBatchMetricsDataParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBatchMetricsDataRequest(c.Server, projectID, batchID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBatchMetricsDataForBatchMetricsDataIDs(ctx context.Context, projectID ProjectID, batchID BatchID, metricsDataID []MetricsDataID, params *ListBatchMetricsDataForBatchMetricsDataIDsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBatchMetricsDataForBatchMetricsDataIDsRequest(c.Server, projectID, batchID, metricsDataID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RerunBatchWithBody(ctx context.Context, projectID ProjectID, batchID BatchID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRerunBatchRequestWithBody(c.Server, projectID, batchID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RerunBatch(ctx context.Context, projectID ProjectID, batchID BatchID, body RerunBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRerunBatchRequest(c.Server, projectID, batchID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBatchSuggestions(ctx context.Context, projectID ProjectID, batchID BatchID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBatchSuggestionsRequest(c.Server, projectID, batchID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBranchesForProject(ctx context.Context, projectID ProjectID, params *ListBranchesForProjectParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBranchesForProjectRequest(c.Server, projectID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBranchForProjectWithBody(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBranchForProjectRequestWithBody(c.Server, projectID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBranchForProject(ctx context.Context, projectID ProjectID, body CreateBranchForProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBranchForProjectRequest(c.Server, projectID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteBranchForProject(ctx context.Context, projectID ProjectID, branchID BranchID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteBranchForProjectRequest(c.Server, projectID, branchID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBranchForProject(ctx context.Context, projectID ProjectID, branchID BranchID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBranchForProjectRequest(c.Server, projectID, branchID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBuildsForBranches(ctx context.Context, projectID ProjectID, branchID []BranchID, params *ListBuildsForBranchesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBuildsForBranchesRequest(c.Server, projectID, branchID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBuildForBranchWithBody(ctx context.Context, projectID ProjectID, branchID BranchID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBuildForBranchRequestWithBody(c.Server, projectID, branchID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBuildForBranch(ctx context.Context, projectID ProjectID, branchID BranchID, body CreateBuildForBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBuildForBranchRequest(c.Server, projectID, branchID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteBuildForBranch(ctx context.Context, projectID ProjectID, branchID BranchID, buildID BuildID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteBuildForBranchRequest(c.Server, projectID, branchID, buildID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBuildForBranch(ctx context.Context, projectID ProjectID, branchID BranchID, buildID BuildID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBuildForBranchRequest(c.Server, projectID, branchID, buildID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBatchesForBuilds(ctx context.Context, projectID ProjectID, branchID BranchID, buildID []BuildID, params *ListBatchesForBuildsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBatchesForBuildsRequest(c.Server, projectID, branchID, buildID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBuilds(ctx context.Context, projectID ProjectID, params *ListBuildsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBuildsRequest(c.Server, projectID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBuildAccounts(ctx context.Context, projectID ProjectID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBuildAccountsRequest(c.Server, projectID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBuild(ctx context.Context, projectID ProjectID, buildID BuildID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBuildRequest(c.Server, projectID, buildID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateBuildWithBody(ctx context.Context, projectID ProjectID, buildID BuildID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateBuildRequestWithBody(c.Server, projectID, buildID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateBuild(ctx context.Context, projectID ProjectID, buildID BuildID, body UpdateBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateBuildRequest(c.Server, projectID, buildID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListExperienceTags(ctx context.Context, projectID ProjectID, params *ListExperienceTagsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListExperienceTagsRequest(c.Server, projectID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateExperienceTagWithBody(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateExperienceTagRequestWithBody(c.Server, projectID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateExperienceTag(ctx context.Context, projectID ProjectID, body CreateExperienceTagJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateExperienceTagRequest(c.Server, projectID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddTagsToExperiencesWithBody(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddTagsToExperiencesRequestWithBody(c.Server, projectID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddTagsToExperiences(ctx context.Context, projectID ProjectID, body AddTagsToExperiencesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddTagsToExperiencesRequest(c.Server, projectID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteExperienceTag(ctx context.Context, projectID ProjectID, experienceTagID ExperienceTagID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteExperienceTagRequest(c.Server, projectID, experienceTagID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetExperienceTag(ctx context.Context, projectID ProjectID, experienceTagID ExperienceTagID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetExperienceTagRequest(c.Server, projectID, experienceTagID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateExperienceTagWithBody(ctx context.Context, projectID ProjectID, experienceTagID ExperienceTagID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateExperienceTagRequestWithBody(c.Server, projectID, experienceTagID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateExperienceTag(ctx context.Context, projectID ProjectID, experienceTagID ExperienceTagID, body UpdateExperienceTagJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateExperienceTagRequest(c.Server, projectID, experienceTagID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListExperiencesWithExperienceTag(ctx context.Context, projectID ProjectID, experienceTagID ExperienceTagID, params *ListExperiencesWithExperienceTagParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListExperiencesWithExperienceTagRequest(c.Server, projectID, experienceTagID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveExperienceTagFromExperience(ctx context.Context, projectID ProjectID, experienceTagID ExperienceTagID, experienceID ExperienceID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveExperienceTagFromExperienceRequest(c.Server, projectID, experienceTagID, experienceID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddExperienceTagToExperience(ctx context.Context, projectID ProjectID, experienceTagID ExperienceTagID, experienceID ExperienceID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddExperienceTagToExperienceRequest(c.Server, projectID, experienceTagID, experienceID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListExperiences(ctx context.Context, projectID ProjectID, params *ListExperiencesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListExperiencesRequest(c.Server, projectID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateExperienceWithBody(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateExperienceRequestWithBody(c.Server, projectID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateExperience(ctx context.Context, projectID ProjectID, body CreateExperienceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateExperienceRequest(c.Server, projectID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveExperience(ctx context.Context, projectID ProjectID, experienceID ExperienceID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveExperienceRequest(c.Server, projectID, experienceID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetExperience(ctx context.Context, projectID ProjectID, experienceID ExperienceID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetExperienceRequest(c.Server, projectID, experienceID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateExperienceWithBody(ctx context.Context, projectID ProjectID, experienceID ExperienceID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateExperienceRequestWithBody(c.Server, projectID, experienceID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateExperience(ctx context.Context, projectID ProjectID, experienceID ExperienceID, body UpdateExperienceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateExperienceRequest(c.Server, projectID, experienceID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DebugExperienceWithBody(ctx context.Context, projectID ProjectID, experienceID ExperienceID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDebugExperienceRequestWithBody(c.Server, projectID, experienceID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DebugExperience(ctx context.Context, projectID ProjectID, experienceID ExperienceID, body DebugExperienceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDebugExperienceRequest(c.Server, projectID, experienceID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListExperienceTagsForExperience(ctx context.Context, projectID ProjectID, experienceID ExperienceID, params *ListExperienceTagsForExperienceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListExperienceTagsForExperienceRequest(c.Server, projectID, experienceID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreExperience(ctx context.Context, projectID ProjectID, experienceID ExperienceID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreExperienceRequest(c.Server, projectID, experienceID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemsForExperience(ctx context.Context, projectID ProjectID, experienceID ExperienceID, params *GetSystemsForExperienceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemsForExperienceRequest(c.Server, projectID, experienceID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListMetricsBuilds(ctx context.Context, projectID ProjectID, params *ListMetricsBuildsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListMetricsBuildsRequest(c.Server, projectID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateMetricsBuildWithBody(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateMetricsBuildRequestWithBody(c.Server, projectID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateMetricsBuild(ctx context.Context, projectID ProjectID, body CreateMetricsBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateMetricsBuildRequest(c.Server, projectID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMetricsBuild(ctx context.Context, projectID ProjectID, metricsBuildID MetricsBuildID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMetricsBuildRequest(c.Server, projectID, metricsBuildID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemsForMetricsBuild(ctx context.Context, projectID ProjectID, metricsBuildID MetricsBuildID, params *GetSystemsForMetricsBuildParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemsForMetricsBuildRequest(c.Server, projectID, metricsBuildID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListServiceProfiles(ctx context.Context, projectID ProjectID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListServiceProfilesRequest(c.Server, projectID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListReports(ctx context.Context, projectID ProjectID, params *ListReportsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListReportsRequest(c.Server, projectID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateReportWithBody(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateReportRequestWithBody(c.Server, projectID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateReport(ctx context.Context, projectID ProjectID, body CreateReportJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateReportRequest(c.Server, projectID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListReportAccounts(ctx context.Context, projectID ProjectID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListReportAccountsRequest(c.Server, projectID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReport(ctx context.Context, projectID ProjectID, reportID ReportID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReportRequest(c.Server, projectID, reportID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListLogsForReport(ctx context.Context, projectID ProjectID, reportID ReportID, params *ListLogsForReportParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListLogsForReportRequest(c.Server, projectID, reportID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReportLog(ctx context.Context, projectID ProjectID, reportID ReportID, logID LogID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReportLogRequest(c.Server, projectID, reportID, logID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListReportMetrics(ctx context.Context, projectID ProjectID, reportID ReportID, params *ListReportMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListReportMetricsRequest(c.Server, projectID, reportID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListReportMetricsForReportMetricIDs(ctx context.Context, projectID ProjectID, reportID ReportID, metricID []MetricID, params *ListReportMetricsForReportMetricIDsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListReportMetricsForReportMetricIDsRequest(c.Server, projectID, reportID, metricID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListReportMetricsDataForReportMetricIDs(ctx context.Context, projectID ProjectID, reportID ReportID, metricID []MetricID, params *ListReportMetricsDataForReportMetricIDsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListReportMetricsDataForReportMetricIDsRequest(c.Server, projectID, reportID, metricID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListTagsForReportMetrics(ctx context.Context, projectID ProjectID, reportID ReportID, metricID []MetricID, params *ListTagsForReportMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListTagsForReportMetricsRequest(c.Server, projectID, reportID, metricID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListReportMetricsData(ctx context.Context, projectID ProjectID, reportID ReportID, params *ListReportMetricsDataParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListReportMetricsDataRequest(c.Server, projectID, reportID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListReportMetricsDataForReportMetricsDataIDs(ctx context.Context, projectID ProjectID, reportID ReportID, metricsDataID []MetricsDataID, params *ListReportMetricsDataForReportMetricsDataIDsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListReportMetricsDataForReportMetricsDataIDsRequest(c.Server, projectID, reportID, metricsDataID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListTestSuites(ctx context.Context, projectID ProjectID, params *ListTestSuitesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListTestSuitesRequest(c.Server, projectID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTestSuiteWithBody(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTestSuiteRequestWithBody(c.Server, projectID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTestSuite(ctx context.Context, projectID ProjectID, body CreateTestSuiteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTestSuiteRequest(c.Server, projectID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddTestSuitesToExperiencesWithBody(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddTestSuitesToExperiencesRequestWithBody(c.Server, projectID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddTestSuitesToExperiences(ctx context.Context, projectID ProjectID, body AddTestSuitesToExperiencesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddTestSuitesToExperiencesRequest(c.Server, projectID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTestSuiteSummary(ctx context.Context, projectID ProjectID, params *GetTestSuiteSummaryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTestSuiteSummaryRequest(c.Server, projectID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveTestSuite(ctx context.Context, projectID ProjectID, testSuiteID TestSuiteID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveTestSuiteRequest(c.Server, projectID, testSuiteID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTestSuite(ctx context.Context, projectID ProjectID, testSuiteID TestSuiteID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTestSuiteRequest(c.Server, projectID, testSuiteID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReviseTestSuiteWithBody(ctx context.Context, projectID ProjectID, testSuiteID TestSuiteID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReviseTestSuiteRequestWithBody(c.Server, projectID, testSuiteID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReviseTestSuite(ctx context.Context, projectID ProjectID, testSuiteID TestSuiteID, body ReviseTestSuiteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReviseTestSuiteRequest(c.Server, projectID, testSuiteID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddExperiencesToTestSuiteWithBody(ctx context.Context, projectID ProjectID, testSuiteID TestSuiteID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddExperiencesToTestSuiteRequestWithBody(c.Server, projectID, testSuiteID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddExperiencesToTestSuite(ctx context.Context, projectID ProjectID, testSuiteID TestSuiteID, body AddExperiencesToTestSuiteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddExperiencesToTestSuiteRequest(c.Server, projectID, testSuiteID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBatchesForTestSuite(ctx context.Context, projectID ProjectID, testSuiteID TestSuiteID, params *ListBatchesForTestSuiteParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBatchesForTestSuiteRequest(c.Server, projectID, testSuiteID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBatchForTestSuiteWithBody(ctx context.Context, projectID ProjectID, testSuiteID TestSuiteID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBatchForTestSuiteRequestWithBody(c.Server, projectID, testSuiteID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBatchForTestSuite(ctx context.Context, projectID ProjectID, testSuiteID TestSuiteID, body CreateBatchForTestSuiteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBatchForTestSuiteRequest(c.Server, projectID, testSuiteID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveExperiencesFromTestSuiteWithBody(ctx context.Context, projectID ProjectID, testSuiteID TestSuiteID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveExperiencesFromTestSuiteRequestWithBody(c.Server, projectID, testSuiteID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveExperiencesFromTestSuite(ctx context.Context, projectID ProjectID, testSuiteID TestSuiteID, body RemoveExperiencesFromTestSuiteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveExperiencesFromTestSuiteRequest(c.Server, projectID, testSuiteID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreTestSuite(ctx context.Context, projectID ProjectID, testSuiteID TestSuiteID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreTestSuiteRequest(c.Server, projectID, testSuiteID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListTestSuiteRevisions(ctx context.Context, projectID ProjectID, testSuiteID TestSuiteID, params *ListTestSuiteRevisionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListTestSuiteRevisionsRequest(c.Server, projectID, testSuiteID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTestSuiteRevision(ctx context.Context, projectID ProjectID, testSuiteID TestSuiteID, revision TestSuiteRevision, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTestSuiteRevisionRequest(c.Server, projectID, testSuiteID, revision)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBatchesForTestSuiteRevision(ctx context.Context, projectID ProjectID, testSuiteID TestSuiteID, revision TestSuiteRevision, params *ListBatchesForTestSuiteRevisionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBatchesForTestSuiteRevisionRequest(c.Server, projectID, testSuiteID, revision, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBatchForTestSuiteRevisionWithBody(ctx context.Context, projectID ProjectID, testSuiteID TestSuiteID, revision TestSuiteRevision, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBatchForTestSuiteRevisionRequestWithBody(c.Server, projectID, testSuiteID, revision, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBatchForTestSuiteRevision(ctx context.Context, projectID ProjectID, testSuiteID TestSuiteID, revision TestSuiteRevision, body CreateBatchForTestSuiteRevisionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBatchForTestSuiteRevisionRequest(c.Server, projectID, testSuiteID, revision, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListParameterSweeps(ctx context.Context, projectID ProjectID, params *ListParameterSweepsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListParameterSweepsRequest(c.Server, projectID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateParameterSweepWithBody(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateParameterSweepRequestWithBody(c.Server, projectID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateParameterSweep(ctx context.Context, projectID ProjectID, body CreateParameterSweepJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateParameterSweepRequest(c.Server, projectID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSweepAccounts(ctx context.Context, projectID ProjectID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSweepAccountsRequest(c.Server, projectID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetParameterSweep(ctx context.Context, projectID ProjectID, sweepID ParameterSweepID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetParameterSweepRequest(c.Server, projectID, sweepID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelParameterSweep(ctx context.Context, projectID ProjectID, sweepID ParameterSweepID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelParameterSweepRequest(c.Server, projectID, sweepID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSystems(ctx context.Context, projectID ProjectID, params *ListSystemsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSystemsRequest(c.Server, projectID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSystemWithBody(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSystemRequestWithBody(c.Server, projectID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSystem(ctx context.Context, projectID ProjectID, body CreateSystemJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSystemRequest(c.Server, projectID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddSystemsToExperiencesWithBody(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddSystemsToExperiencesRequestWithBody(c.Server, projectID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddSystemsToExperiences(ctx context.Context, projectID ProjectID, body AddSystemsToExperiencesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddSystemsToExperiencesRequest(c.Server, projectID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveSystemsFromExperiencesWithBody(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveSystemsFromExperiencesRequestWithBody(c.Server, projectID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveSystemsFromExperiences(ctx context.Context, projectID ProjectID, body RemoveSystemsFromExperiencesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveSystemsFromExperiencesRequest(c.Server, projectID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveSystem(ctx context.Context, projectID ProjectID, systemID SystemID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveSystemRequest(c.Server, projectID, systemID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystem(ctx context.Context, projectID ProjectID, systemID SystemID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemRequest(c.Server, projectID, systemID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSystemWithBody(ctx context.Context, projectID ProjectID, systemID SystemID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSystemRequestWithBody(c.Server, projectID, systemID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSystem(ctx context.Context, projectID ProjectID, systemID SystemID, body UpdateSystemJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSystemRequest(c.Server, projectID, systemID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBuildsForSystem(ctx context.Context, projectID ProjectID, systemID SystemID, params *ListBuildsForSystemParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBuildsForSystemRequest(c.Server, projectID, systemID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBuildForSystemWithBody(ctx context.Context, projectID ProjectID, systemID SystemID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBuildForSystemRequestWithBody(c.Server, projectID, systemID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBuildForSystem(ctx context.Context, projectID ProjectID, systemID SystemID, body CreateBuildForSystemJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBuildForSystemRequest(c.Server, projectID, systemID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBuildForSystem(ctx context.Context, projectID ProjectID, systemID SystemID, buildID BuildID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBuildForSystemRequest(c.Server, projectID, systemID, buildID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListExperiencesForSystem(ctx context.Context, projectID ProjectID, systemID SystemID, params *ListExperiencesForSystemParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListExperiencesForSystemRequest(c.Server, projectID, systemID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveSystemFromExperience(ctx context.Context, projectID ProjectID, systemID SystemID, experienceID ExperienceID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveSystemFromExperienceRequest(c.Server, projectID, systemID, experienceID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddSystemToExperience(ctx context.Context, projectID ProjectID, systemID SystemID, experienceID ExperienceID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddSystemToExperienceRequest(c.Server, projectID, systemID, experienceID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveSystemFromMetricsBuild(ctx context.Context, projectID ProjectID, systemID SystemID, metricsBuildID MetricsBuildID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveSystemFromMetricsBuildRequest(c.Server, projectID, systemID, metricsBuildID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddSystemToMetricsBuild(ctx context.Context, projectID ProjectID, systemID SystemID, metricsBuildID MetricsBuildID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddSystemToMetricsBuildRequest(c.Server, projectID, systemID, metricsBuildID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetQuota(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetQuotaRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ValidateExperienceLocationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewValidateExperienceLocationRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ValidateExperienceLocation(ctx context.Context, body ValidateExperienceLocationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewValidateExperienceLocationRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListViewSessions(ctx context.Context, params *ListViewSessionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListViewSessionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateViewSession(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateViewSessionRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetViewSession(ctx context.Context, viewSessionID ViewSessionID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetViewSessionRequest(c.Server, viewSessionID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateViewUpdateWithBody(ctx context.Context, viewSessionID ViewSessionID, viewUpdateID ViewUpdateID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateViewUpdateRequestWithBody(c.Server, viewSessionID, viewUpdateID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewHealthRequest generates requests for Health
func NewHealthRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/health")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListProjectsRequest generates requests for ListProjects
func NewListProjectsRequest(server string, params *ListProjectsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateProjectRequest calls the generic CreateProject builder with application/json body
func NewCreateProjectRequest(server string, body CreateProjectJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateProjectRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateProjectRequestWithBody generates requests for CreateProject with any type of body
func NewCreateProjectRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewArchiveProjectRequest generates requests for ArchiveProject
func NewArchiveProjectRequest(server string, projectID ProjectID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProjectRequest generates requests for GetProject
func NewGetProjectRequest(server string, projectID ProjectID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateProjectRequest calls the generic UpdateProject builder with application/json body
func NewUpdateProjectRequest(server string, projectID ProjectID, body UpdateProjectJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateProjectRequestWithBody(server, projectID, "application/json", bodyReader)
}

// NewUpdateProjectRequestWithBody generates requests for UpdateProject with any type of body
func NewUpdateProjectRequestWithBody(server string, projectID ProjectID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListBatchesRequest generates requests for ListBatches
func NewListBatchesRequest(server string, projectID ProjectID, params *ListBatchesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/batches", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Text != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "text", runtime.ParamLocationQuery, *params.Text); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateBatchRequest calls the generic CreateBatch builder with application/json body
func NewCreateBatchRequest(server string, projectID ProjectID, body CreateBatchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateBatchRequestWithBody(server, projectID, "application/json", bodyReader)
}

// NewCreateBatchRequestWithBody generates requests for CreateBatch with any type of body
func NewCreateBatchRequestWithBody(server string, projectID ProjectID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/batches", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllJobsRequest generates requests for ListAllJobs
func NewListAllJobsRequest(server string, projectID ProjectID, params *ListAllJobsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/batches/-/jobs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListBatchAccountsRequest generates requests for ListBatchAccounts
func NewListBatchAccountsRequest(server string, projectID ProjectID, params *ListBatchAccountsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/batches/accounts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBatchRequest generates requests for GetBatch
func NewGetBatchRequest(server string, projectID ProjectID, batchID BatchID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "batchID", runtime.ParamLocationPath, batchID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/batches/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateBatchRequest calls the generic UpdateBatch builder with application/json body
func NewUpdateBatchRequest(server string, projectID ProjectID, batchID BatchID, body UpdateBatchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateBatchRequestWithBody(server, projectID, batchID, "application/json", bodyReader)
}

// NewUpdateBatchRequestWithBody generates requests for UpdateBatch with any type of body
func NewUpdateBatchRequestWithBody(server string, projectID ProjectID, batchID BatchID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "batchID", runtime.ParamLocationPath, batchID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/batches/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCancelBatchRequest generates requests for CancelBatch
func NewCancelBatchRequest(server string, projectID ProjectID, batchID BatchID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "batchID", runtime.ParamLocationPath, batchID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/batches/%s/:cancel", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCompareBatchesRequest generates requests for CompareBatches
func NewCompareBatchesRequest(server string, projectID ProjectID, batchID BatchID, otherBatchID BatchID, params *CompareBatchesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "batchID", runtime.ParamLocationPath, batchID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "otherBatchID", runtime.ParamLocationPath, otherBatchID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/batches/%s/compare/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListBatchErrorsRequest generates requests for ListBatchErrors
func NewListBatchErrorsRequest(server string, projectID ProjectID, batchID BatchID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "batchID", runtime.ParamLocationPath, batchID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/batches/%s/errors", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListJobsRequest generates requests for ListJobs
func NewListJobsRequest(server string, projectID ProjectID, batchID BatchID, params *ListJobsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "batchID", runtime.ParamLocationPath, batchID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/batches/%s/jobs", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ConflatedStatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "conflatedStatus", runtime.ParamLocationQuery, *params.ConflatedStatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Text != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "text", runtime.ParamLocationQuery, *params.Text); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExperienceTagIDs != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "experienceTagIDs", runtime.ParamLocationQuery, *params.ExperienceTagIDs); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetJobRequest generates requests for GetJob
func NewGetJobRequest(server string, projectID ProjectID, batchID BatchID, jobID JobID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "batchID", runtime.ParamLocationPath, batchID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "jobID", runtime.ParamLocationPath, jobID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/batches/%s/jobs/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateJobRequest calls the generic UpdateJob builder with application/json body
func NewUpdateJobRequest(server string, projectID ProjectID, batchID BatchID, jobID JobID, body UpdateJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateJobRequestWithBody(server, projectID, batchID, jobID, "application/json", bodyReader)
}

// NewUpdateJobRequestWithBody generates requests for UpdateJob with any type of body
func NewUpdateJobRequestWithBody(server string, projectID ProjectID, batchID BatchID, jobID JobID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "batchID", runtime.ParamLocationPath, batchID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "jobID", runtime.ParamLocationPath, jobID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/batches/%s/jobs/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListEventTagsForJobRequest generates requests for ListEventTagsForJob
func NewListEventTagsForJobRequest(server string, projectID ProjectID, batchID BatchID, jobID JobID, params *ListEventTagsForJobParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "batchID", runtime.ParamLocationPath, batchID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "jobID", runtime.ParamLocationPath, jobID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/batches/%s/jobs/%s/eventTags", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListEventsForJobRequest generates requests for ListEventsForJob
func NewListEventsForJobRequest(server string, projectID ProjectID, batchID BatchID, jobID JobID, params *ListEventsForJobParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "batchID", runtime.ParamLocationPath, batchID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "jobID", runtime.ParamLocationPath, jobID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/batches/%s/jobs/%s/events", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.EventTags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "eventTags", runtime.ParamLocationQuery, *params.EventTags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEventForJobRequest generates requests for GetEventForJob
func NewGetEventForJobRequest(server string, projectID ProjectID, batchID BatchID, jobID JobID, eventID EventID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "batchID", runtime.ParamLocationPath, batchID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "jobID", runtime.ParamLocationPath, jobID)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "eventID", runtime.ParamLocationPath, eventID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/batches/%s/jobs/%s/events/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateEventRequest calls the generic UpdateEvent builder with application/json body
func NewUpdateEventRequest(server string, projectID ProjectID, batchID BatchID, jobID JobID, eventID EventID, body UpdateEventJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateEventRequestWithBody(server, projectID, batchID, jobID, eventID, "application/json", bodyReader)
}

// NewUpdateEventRequestWithBody generates requests for UpdateEvent with any type of body
func NewUpdateEventRequestWithBody(server string, projectID ProjectID, batchID BatchID, jobID JobID, eventID EventID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "batchID", runtime.ParamLocationPath, batchID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "jobID", runtime.ParamLocationPath, jobID)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "eventID", runtime.ParamLocationPath, eventID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/batches/%s/jobs/%s/events/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListJobLogsForJobRequest generates requests for ListJobLogsForJob
func NewListJobLogsForJobRequest(server string, projectID ProjectID, batchID BatchID, jobID JobID, params *ListJobLogsForJobParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "batchID", runtime.ParamLocationPath, batchID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "jobID", runtime.ParamLocationPath, jobID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/batches/%s/jobs/%s/logs", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteJobLogRequest generates requests for DeleteJobLog
func NewDeleteJobLogRequest(server string, projectID ProjectID, batchID BatchID, jobID JobID, logID LogID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "batchID", runtime.ParamLocationPath, batchID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "jobID", runtime.ParamLocationPath, jobID)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "logID", runtime.ParamLocationPath, logID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/batches/%s/jobs/%s/logs/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetJobLogRequest generates requests for GetJobLog
func NewGetJobLogRequest(server string, projectID ProjectID, batchID BatchID, jobID JobID, logID LogID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "batchID", runtime.ParamLocationPath, batchID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "jobID", runtime.ParamLocationPath, jobID)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "logID", runtime.ParamLocationPath, logID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/batches/%s/jobs/%s/logs/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListMetricsForJobRequest generates requests for ListMetricsForJob
func NewListMetricsForJobRequest(server string, projectID ProjectID, batchID BatchID, jobID JobID, params *ListMetricsForJobParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "batchID", runtime.ParamLocationPath, batchID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "jobID", runtime.ParamLocationPath, jobID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/batches/%s/jobs/%s/metrics", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListMetricsForMetricIDsRequest generates requests for ListMetricsForMetricIDs
func NewListMetricsForMetricIDsRequest(server string, projectID ProjectID, batchID BatchID, jobID JobID, metricID []MetricID, params *ListMetricsForMetricIDsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "batchID", runtime.ParamLocationPath, batchID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "jobID", runtime.ParamLocationPath, jobID)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "metricID", runtime.ParamLocationPath, metricID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/batches/%s/jobs/%s/metrics/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListMetricsDataForMetricIDsRequest generates requests for ListMetricsDataForMetricIDs
func NewListMetricsDataForMetricIDsRequest(server string, projectID ProjectID, batchID BatchID, jobID JobID, metricID []MetricID, params *ListMetricsDataForMetricIDsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "batchID", runtime.ParamLocationPath, batchID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "jobID", runtime.ParamLocationPath, jobID)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "metricID", runtime.ParamLocationPath, metricID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/batches/%s/jobs/%s/metrics/%s/metricsData", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListTagsForJobMetricsRequest generates requests for ListTagsForJobMetrics
func NewListTagsForJobMetricsRequest(server string, projectID ProjectID, batchID BatchID, jobID JobID, metricID []MetricID, params *ListTagsForJobMetricsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "batchID", runtime.ParamLocationPath, batchID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "jobID", runtime.ParamLocationPath, jobID)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "metricID", runtime.ParamLocationPath, metricID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/batches/%s/jobs/%s/metrics/%s/tags", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListMetricsDataForJobRequest generates requests for ListMetricsDataForJob
func NewListMetricsDataForJobRequest(server string, projectID ProjectID, batchID BatchID, jobID JobID, params *ListMetricsDataForJobParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "batchID", runtime.ParamLocationPath, batchID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "jobID", runtime.ParamLocationPath, jobID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/batches/%s/jobs/%s/metricsData", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListMetricsDataForMetricsDataIDsRequest generates requests for ListMetricsDataForMetricsDataIDs
func NewListMetricsDataForMetricsDataIDsRequest(server string, projectID ProjectID, batchID BatchID, jobID JobID, metricsDataID []MetricsDataID, params *ListMetricsDataForMetricsDataIDsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "batchID", runtime.ParamLocationPath, batchID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "jobID", runtime.ParamLocationPath, jobID)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "metricsDataID", runtime.ParamLocationPath, metricsDataID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/batches/%s/jobs/%s/metricsData/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListBatchLogsForBatchRequest generates requests for ListBatchLogsForBatch
func NewListBatchLogsForBatchRequest(server string, projectID ProjectID, batchID BatchID, params *ListBatchLogsForBatchParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "batchID", runtime.ParamLocationPath, batchID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/batches/%s/logs", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteBatchLogRequest generates requests for DeleteBatchLog
func NewDeleteBatchLogRequest(server string, projectID ProjectID, batchID BatchID, logID LogID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "batchID", runtime.ParamLocationPath, batchID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "logID", runtime.ParamLocationPath, logID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/batches/%s/logs/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBatchLogRequest generates requests for GetBatchLog
func NewGetBatchLogRequest(server string, projectID ProjectID, batchID BatchID, logID LogID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "batchID", runtime.ParamLocationPath, batchID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "logID", runtime.ParamLocationPath, logID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/batches/%s/logs/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListBatchMetricsRequest generates requests for ListBatchMetrics
func NewListBatchMetricsRequest(server string, projectID ProjectID, batchID BatchID, params *ListBatchMetricsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "batchID", runtime.ParamLocationPath, batchID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/batches/%s/metrics", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListBatchMetricsForBatchMetricIDsRequest generates requests for ListBatchMetricsForBatchMetricIDs
func NewListBatchMetricsForBatchMetricIDsRequest(server string, projectID ProjectID, batchID BatchID, metricID []MetricID, params *ListBatchMetricsForBatchMetricIDsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "batchID", runtime.ParamLocationPath, batchID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "metricID", runtime.ParamLocationPath, metricID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/batches/%s/metrics/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListBatchMetricsDataForBatchMetricIDsRequest generates requests for ListBatchMetricsDataForBatchMetricIDs
func NewListBatchMetricsDataForBatchMetricIDsRequest(server string, projectID ProjectID, batchID BatchID, metricID []MetricID, params *ListBatchMetricsDataForBatchMetricIDsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "batchID", runtime.ParamLocationPath, batchID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "metricID", runtime.ParamLocationPath, metricID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/batches/%s/metrics/%s/metricsData", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListTagsForBatchMetricsRequest generates requests for ListTagsForBatchMetrics
func NewListTagsForBatchMetricsRequest(server string, projectID ProjectID, batchID BatchID, metricID []MetricID, params *ListTagsForBatchMetricsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "batchID", runtime.ParamLocationPath, batchID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "metricID", runtime.ParamLocationPath, metricID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/batches/%s/metrics/%s/tags", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListBatchMetricsDataRequest generates requests for ListBatchMetricsData
func NewListBatchMetricsDataRequest(server string, projectID ProjectID, batchID BatchID, params *ListBatchMetricsDataParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "batchID", runtime.ParamLocationPath, batchID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/batches/%s/metricsData", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListBatchMetricsDataForBatchMetricsDataIDsRequest generates requests for ListBatchMetricsDataForBatchMetricsDataIDs
func NewListBatchMetricsDataForBatchMetricsDataIDsRequest(server string, projectID ProjectID, batchID BatchID, metricsDataID []MetricsDataID, params *ListBatchMetricsDataForBatchMetricsDataIDsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "batchID", runtime.ParamLocationPath, batchID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "metricsDataID", runtime.ParamLocationPath, metricsDataID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/batches/%s/metricsData/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRerunBatchRequest calls the generic RerunBatch builder with application/json body
func NewRerunBatchRequest(server string, projectID ProjectID, batchID BatchID, body RerunBatchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRerunBatchRequestWithBody(server, projectID, batchID, "application/json", bodyReader)
}

// NewRerunBatchRequestWithBody generates requests for RerunBatch with any type of body
func NewRerunBatchRequestWithBody(server string, projectID ProjectID, batchID BatchID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "batchID", runtime.ParamLocationPath, batchID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/batches/%s/rerun", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetBatchSuggestionsRequest generates requests for GetBatchSuggestions
func NewGetBatchSuggestionsRequest(server string, projectID ProjectID, batchID BatchID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "batchID", runtime.ParamLocationPath, batchID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/batches/%s/suggestions", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListBranchesForProjectRequest generates requests for ListBranchesForProject
func NewListBranchesForProjectRequest(server string, projectID ProjectID, params *ListBranchesForProjectParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/branches", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BranchType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "branchType", runtime.ParamLocationQuery, *params.BranchType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateBranchForProjectRequest calls the generic CreateBranchForProject builder with application/json body
func NewCreateBranchForProjectRequest(server string, projectID ProjectID, body CreateBranchForProjectJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateBranchForProjectRequestWithBody(server, projectID, "application/json", bodyReader)
}

// NewCreateBranchForProjectRequestWithBody generates requests for CreateBranchForProject with any type of body
func NewCreateBranchForProjectRequestWithBody(server string, projectID ProjectID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/branches", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteBranchForProjectRequest generates requests for DeleteBranchForProject
func NewDeleteBranchForProjectRequest(server string, projectID ProjectID, branchID BranchID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branchID", runtime.ParamLocationPath, branchID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/branches/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBranchForProjectRequest generates requests for GetBranchForProject
func NewGetBranchForProjectRequest(server string, projectID ProjectID, branchID BranchID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branchID", runtime.ParamLocationPath, branchID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/branches/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListBuildsForBranchesRequest generates requests for ListBuildsForBranches
func NewListBuildsForBranchesRequest(server string, projectID ProjectID, branchID []BranchID, params *ListBuildsForBranchesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branchID", runtime.ParamLocationPath, branchID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/branches/%s/builds", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateBuildForBranchRequest calls the generic CreateBuildForBranch builder with application/json body
func NewCreateBuildForBranchRequest(server string, projectID ProjectID, branchID BranchID, body CreateBuildForBranchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateBuildForBranchRequestWithBody(server, projectID, branchID, "application/json", bodyReader)
}

// NewCreateBuildForBranchRequestWithBody generates requests for CreateBuildForBranch with any type of body
func NewCreateBuildForBranchRequestWithBody(server string, projectID ProjectID, branchID BranchID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branchID", runtime.ParamLocationPath, branchID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/branches/%s/builds", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteBuildForBranchRequest generates requests for DeleteBuildForBranch
func NewDeleteBuildForBranchRequest(server string, projectID ProjectID, branchID BranchID, buildID BuildID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branchID", runtime.ParamLocationPath, branchID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "buildID", runtime.ParamLocationPath, buildID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/branches/%s/builds/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBuildForBranchRequest generates requests for GetBuildForBranch
func NewGetBuildForBranchRequest(server string, projectID ProjectID, branchID BranchID, buildID BuildID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branchID", runtime.ParamLocationPath, branchID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "buildID", runtime.ParamLocationPath, buildID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/branches/%s/builds/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListBatchesForBuildsRequest generates requests for ListBatchesForBuilds
func NewListBatchesForBuildsRequest(server string, projectID ProjectID, branchID BranchID, buildID []BuildID, params *ListBatchesForBuildsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branchID", runtime.ParamLocationPath, branchID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "buildID", runtime.ParamLocationPath, buildID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/branches/%s/builds/%s/batches", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListBuildsRequest generates requests for ListBuilds
func NewListBuildsRequest(server string, projectID ProjectID, params *ListBuildsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/builds", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Text != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "text", runtime.ParamLocationQuery, *params.Text); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListBuildAccountsRequest generates requests for ListBuildAccounts
func NewListBuildAccountsRequest(server string, projectID ProjectID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/builds/accounts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBuildRequest generates requests for GetBuild
func NewGetBuildRequest(server string, projectID ProjectID, buildID BuildID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "buildID", runtime.ParamLocationPath, buildID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/builds/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateBuildRequest calls the generic UpdateBuild builder with application/json body
func NewUpdateBuildRequest(server string, projectID ProjectID, buildID BuildID, body UpdateBuildJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateBuildRequestWithBody(server, projectID, buildID, "application/json", bodyReader)
}

// NewUpdateBuildRequestWithBody generates requests for UpdateBuild with any type of body
func NewUpdateBuildRequestWithBody(server string, projectID ProjectID, buildID BuildID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "buildID", runtime.ParamLocationPath, buildID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/builds/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListExperienceTagsRequest generates requests for ListExperienceTags
func NewListExperienceTagsRequest(server string, projectID ProjectID, params *ListExperienceTagsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/experienceTags", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateExperienceTagRequest calls the generic CreateExperienceTag builder with application/json body
func NewCreateExperienceTagRequest(server string, projectID ProjectID, body CreateExperienceTagJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateExperienceTagRequestWithBody(server, projectID, "application/json", bodyReader)
}

// NewCreateExperienceTagRequestWithBody generates requests for CreateExperienceTag with any type of body
func NewCreateExperienceTagRequestWithBody(server string, projectID ProjectID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/experienceTags", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAddTagsToExperiencesRequest calls the generic AddTagsToExperiences builder with application/json body
func NewAddTagsToExperiencesRequest(server string, projectID ProjectID, body AddTagsToExperiencesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddTagsToExperiencesRequestWithBody(server, projectID, "application/json", bodyReader)
}

// NewAddTagsToExperiencesRequestWithBody generates requests for AddTagsToExperiences with any type of body
func NewAddTagsToExperiencesRequestWithBody(server string, projectID ProjectID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/experienceTags/addExperiences", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteExperienceTagRequest generates requests for DeleteExperienceTag
func NewDeleteExperienceTagRequest(server string, projectID ProjectID, experienceTagID ExperienceTagID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "experienceTagID", runtime.ParamLocationPath, experienceTagID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/experienceTags/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetExperienceTagRequest generates requests for GetExperienceTag
func NewGetExperienceTagRequest(server string, projectID ProjectID, experienceTagID ExperienceTagID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "experienceTagID", runtime.ParamLocationPath, experienceTagID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/experienceTags/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateExperienceTagRequest calls the generic UpdateExperienceTag builder with application/json body
func NewUpdateExperienceTagRequest(server string, projectID ProjectID, experienceTagID ExperienceTagID, body UpdateExperienceTagJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateExperienceTagRequestWithBody(server, projectID, experienceTagID, "application/json", bodyReader)
}

// NewUpdateExperienceTagRequestWithBody generates requests for UpdateExperienceTag with any type of body
func NewUpdateExperienceTagRequestWithBody(server string, projectID ProjectID, experienceTagID ExperienceTagID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "experienceTagID", runtime.ParamLocationPath, experienceTagID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/experienceTags/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListExperiencesWithExperienceTagRequest generates requests for ListExperiencesWithExperienceTag
func NewListExperiencesWithExperienceTagRequest(server string, projectID ProjectID, experienceTagID ExperienceTagID, params *ListExperiencesWithExperienceTagParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "experienceTagID", runtime.ParamLocationPath, experienceTagID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/experienceTags/%s/experiences", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Archived != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "archived", runtime.ParamLocationQuery, *params.Archived); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveExperienceTagFromExperienceRequest generates requests for RemoveExperienceTagFromExperience
func NewRemoveExperienceTagFromExperienceRequest(server string, projectID ProjectID, experienceTagID ExperienceTagID, experienceID ExperienceID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "experienceTagID", runtime.ParamLocationPath, experienceTagID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "experienceID", runtime.ParamLocationPath, experienceID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/experienceTags/%s/experiences/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddExperienceTagToExperienceRequest generates requests for AddExperienceTagToExperience
func NewAddExperienceTagToExperienceRequest(server string, projectID ProjectID, experienceTagID ExperienceTagID, experienceID ExperienceID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "experienceTagID", runtime.ParamLocationPath, experienceTagID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "experienceID", runtime.ParamLocationPath, experienceID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/experienceTags/%s/experiences/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListExperiencesRequest generates requests for ListExperiences
func NewListExperiencesRequest(server string, projectID ProjectID, params *ListExperiencesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/experiences", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Text != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "text", runtime.ParamLocationQuery, *params.Text); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Archived != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "archived", runtime.ParamLocationQuery, *params.Archived); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateExperienceRequest calls the generic CreateExperience builder with application/json body
func NewCreateExperienceRequest(server string, projectID ProjectID, body CreateExperienceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateExperienceRequestWithBody(server, projectID, "application/json", bodyReader)
}

// NewCreateExperienceRequestWithBody generates requests for CreateExperience with any type of body
func NewCreateExperienceRequestWithBody(server string, projectID ProjectID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/experiences", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewArchiveExperienceRequest generates requests for ArchiveExperience
func NewArchiveExperienceRequest(server string, projectID ProjectID, experienceID ExperienceID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "experienceID", runtime.ParamLocationPath, experienceID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/experiences/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetExperienceRequest generates requests for GetExperience
func NewGetExperienceRequest(server string, projectID ProjectID, experienceID ExperienceID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "experienceID", runtime.ParamLocationPath, experienceID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/experiences/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateExperienceRequest calls the generic UpdateExperience builder with application/json body
func NewUpdateExperienceRequest(server string, projectID ProjectID, experienceID ExperienceID, body UpdateExperienceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateExperienceRequestWithBody(server, projectID, experienceID, "application/json", bodyReader)
}

// NewUpdateExperienceRequestWithBody generates requests for UpdateExperience with any type of body
func NewUpdateExperienceRequestWithBody(server string, projectID ProjectID, experienceID ExperienceID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "experienceID", runtime.ParamLocationPath, experienceID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/experiences/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDebugExperienceRequest calls the generic DebugExperience builder with application/json body
func NewDebugExperienceRequest(server string, projectID ProjectID, experienceID ExperienceID, body DebugExperienceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDebugExperienceRequestWithBody(server, projectID, experienceID, "application/json", bodyReader)
}

// NewDebugExperienceRequestWithBody generates requests for DebugExperience with any type of body
func NewDebugExperienceRequestWithBody(server string, projectID ProjectID, experienceID ExperienceID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "experienceID", runtime.ParamLocationPath, experienceID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/experiences/%s/debug", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListExperienceTagsForExperienceRequest generates requests for ListExperienceTagsForExperience
func NewListExperienceTagsForExperienceRequest(server string, projectID ProjectID, experienceID ExperienceID, params *ListExperienceTagsForExperienceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "experienceID", runtime.ParamLocationPath, experienceID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/experiences/%s/experienceTags", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRestoreExperienceRequest generates requests for RestoreExperience
func NewRestoreExperienceRequest(server string, projectID ProjectID, experienceID ExperienceID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "experienceID", runtime.ParamLocationPath, experienceID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/experiences/%s/restore", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSystemsForExperienceRequest generates requests for GetSystemsForExperience
func NewGetSystemsForExperienceRequest(server string, projectID ProjectID, experienceID ExperienceID, params *GetSystemsForExperienceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "experienceID", runtime.ParamLocationPath, experienceID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/experiences/%s/systems", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListMetricsBuildsRequest generates requests for ListMetricsBuilds
func NewListMetricsBuildsRequest(server string, projectID ProjectID, params *ListMetricsBuildsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/metricsBuilds", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SystemID != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "systemID", runtime.ParamLocationQuery, *params.SystemID); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Text != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "text", runtime.ParamLocationQuery, *params.Text); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateMetricsBuildRequest calls the generic CreateMetricsBuild builder with application/json body
func NewCreateMetricsBuildRequest(server string, projectID ProjectID, body CreateMetricsBuildJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateMetricsBuildRequestWithBody(server, projectID, "application/json", bodyReader)
}

// NewCreateMetricsBuildRequestWithBody generates requests for CreateMetricsBuild with any type of body
func NewCreateMetricsBuildRequestWithBody(server string, projectID ProjectID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/metricsBuilds", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetMetricsBuildRequest generates requests for GetMetricsBuild
func NewGetMetricsBuildRequest(server string, projectID ProjectID, metricsBuildID MetricsBuildID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "metricsBuildID", runtime.ParamLocationPath, metricsBuildID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/metricsBuilds/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSystemsForMetricsBuildRequest generates requests for GetSystemsForMetricsBuild
func NewGetSystemsForMetricsBuildRequest(server string, projectID ProjectID, metricsBuildID MetricsBuildID, params *GetSystemsForMetricsBuildParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "metricsBuildID", runtime.ParamLocationPath, metricsBuildID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/metricsBuilds/%s/systems", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListServiceProfilesRequest generates requests for ListServiceProfiles
func NewListServiceProfilesRequest(server string, projectID ProjectID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/profiles", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListReportsRequest generates requests for ListReports
func NewListReportsRequest(server string, projectID ProjectID, params *ListReportsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/reports", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Text != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "text", runtime.ParamLocationQuery, *params.Text); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateReportRequest calls the generic CreateReport builder with application/json body
func NewCreateReportRequest(server string, projectID ProjectID, body CreateReportJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateReportRequestWithBody(server, projectID, "application/json", bodyReader)
}

// NewCreateReportRequestWithBody generates requests for CreateReport with any type of body
func NewCreateReportRequestWithBody(server string, projectID ProjectID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/reports", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListReportAccountsRequest generates requests for ListReportAccounts
func NewListReportAccountsRequest(server string, projectID ProjectID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/reports/accounts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetReportRequest generates requests for GetReport
func NewGetReportRequest(server string, projectID ProjectID, reportID ReportID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "reportID", runtime.ParamLocationPath, reportID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/reports/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListLogsForReportRequest generates requests for ListLogsForReport
func NewListLogsForReportRequest(server string, projectID ProjectID, reportID ReportID, params *ListLogsForReportParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "reportID", runtime.ParamLocationPath, reportID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/reports/%s/logs", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetReportLogRequest generates requests for GetReportLog
func NewGetReportLogRequest(server string, projectID ProjectID, reportID ReportID, logID LogID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "reportID", runtime.ParamLocationPath, reportID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "logID", runtime.ParamLocationPath, logID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/reports/%s/logs/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListReportMetricsRequest generates requests for ListReportMetrics
func NewListReportMetricsRequest(server string, projectID ProjectID, reportID ReportID, params *ListReportMetricsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "reportID", runtime.ParamLocationPath, reportID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/reports/%s/metrics", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListReportMetricsForReportMetricIDsRequest generates requests for ListReportMetricsForReportMetricIDs
func NewListReportMetricsForReportMetricIDsRequest(server string, projectID ProjectID, reportID ReportID, metricID []MetricID, params *ListReportMetricsForReportMetricIDsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "reportID", runtime.ParamLocationPath, reportID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "metricID", runtime.ParamLocationPath, metricID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/reports/%s/metrics/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListReportMetricsDataForReportMetricIDsRequest generates requests for ListReportMetricsDataForReportMetricIDs
func NewListReportMetricsDataForReportMetricIDsRequest(server string, projectID ProjectID, reportID ReportID, metricID []MetricID, params *ListReportMetricsDataForReportMetricIDsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "reportID", runtime.ParamLocationPath, reportID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "metricID", runtime.ParamLocationPath, metricID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/reports/%s/metrics/%s/metricsData", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListTagsForReportMetricsRequest generates requests for ListTagsForReportMetrics
func NewListTagsForReportMetricsRequest(server string, projectID ProjectID, reportID ReportID, metricID []MetricID, params *ListTagsForReportMetricsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "reportID", runtime.ParamLocationPath, reportID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "metricID", runtime.ParamLocationPath, metricID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/reports/%s/metrics/%s/tags", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListReportMetricsDataRequest generates requests for ListReportMetricsData
func NewListReportMetricsDataRequest(server string, projectID ProjectID, reportID ReportID, params *ListReportMetricsDataParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "reportID", runtime.ParamLocationPath, reportID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/reports/%s/metricsData", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListReportMetricsDataForReportMetricsDataIDsRequest generates requests for ListReportMetricsDataForReportMetricsDataIDs
func NewListReportMetricsDataForReportMetricsDataIDsRequest(server string, projectID ProjectID, reportID ReportID, metricsDataID []MetricsDataID, params *ListReportMetricsDataForReportMetricsDataIDsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "reportID", runtime.ParamLocationPath, reportID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "metricsDataID", runtime.ParamLocationPath, metricsDataID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/reports/%s/metricsData/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListTestSuitesRequest generates requests for ListTestSuites
func NewListTestSuitesRequest(server string, projectID ProjectID, params *ListTestSuitesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/suites", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ExperienceIDs != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "experienceIDs", runtime.ParamLocationQuery, *params.ExperienceIDs); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SystemID != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "systemID", runtime.ParamLocationQuery, *params.SystemID); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Archived != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "archived", runtime.ParamLocationQuery, *params.Archived); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Text != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "text", runtime.ParamLocationQuery, *params.Text); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateTestSuiteRequest calls the generic CreateTestSuite builder with application/json body
func NewCreateTestSuiteRequest(server string, projectID ProjectID, body CreateTestSuiteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTestSuiteRequestWithBody(server, projectID, "application/json", bodyReader)
}

// NewCreateTestSuiteRequestWithBody generates requests for CreateTestSuite with any type of body
func NewCreateTestSuiteRequestWithBody(server string, projectID ProjectID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/suites", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAddTestSuitesToExperiencesRequest calls the generic AddTestSuitesToExperiences builder with application/json body
func NewAddTestSuitesToExperiencesRequest(server string, projectID ProjectID, body AddTestSuitesToExperiencesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddTestSuitesToExperiencesRequestWithBody(server, projectID, "application/json", bodyReader)
}

// NewAddTestSuitesToExperiencesRequestWithBody generates requests for AddTestSuitesToExperiences with any type of body
func NewAddTestSuitesToExperiencesRequestWithBody(server string, projectID ProjectID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/suites/addExperiences", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetTestSuiteSummaryRequest generates requests for GetTestSuiteSummary
func NewGetTestSuiteSummaryRequest(server string, projectID ProjectID, params *GetTestSuiteSummaryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/suites/summary", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewArchiveTestSuiteRequest generates requests for ArchiveTestSuite
func NewArchiveTestSuiteRequest(server string, projectID ProjectID, testSuiteID TestSuiteID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "testSuiteID", runtime.ParamLocationPath, testSuiteID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/suites/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTestSuiteRequest generates requests for GetTestSuite
func NewGetTestSuiteRequest(server string, projectID ProjectID, testSuiteID TestSuiteID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "testSuiteID", runtime.ParamLocationPath, testSuiteID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/suites/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReviseTestSuiteRequest calls the generic ReviseTestSuite builder with application/json body
func NewReviseTestSuiteRequest(server string, projectID ProjectID, testSuiteID TestSuiteID, body ReviseTestSuiteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReviseTestSuiteRequestWithBody(server, projectID, testSuiteID, "application/json", bodyReader)
}

// NewReviseTestSuiteRequestWithBody generates requests for ReviseTestSuite with any type of body
func NewReviseTestSuiteRequestWithBody(server string, projectID ProjectID, testSuiteID TestSuiteID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "testSuiteID", runtime.ParamLocationPath, testSuiteID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/suites/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAddExperiencesToTestSuiteRequest calls the generic AddExperiencesToTestSuite builder with application/json body
func NewAddExperiencesToTestSuiteRequest(server string, projectID ProjectID, testSuiteID TestSuiteID, body AddExperiencesToTestSuiteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddExperiencesToTestSuiteRequestWithBody(server, projectID, testSuiteID, "application/json", bodyReader)
}

// NewAddExperiencesToTestSuiteRequestWithBody generates requests for AddExperiencesToTestSuite with any type of body
func NewAddExperiencesToTestSuiteRequestWithBody(server string, projectID ProjectID, testSuiteID TestSuiteID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "testSuiteID", runtime.ParamLocationPath, testSuiteID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/suites/%s/addExperiences", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListBatchesForTestSuiteRequest generates requests for ListBatchesForTestSuite
func NewListBatchesForTestSuiteRequest(server string, projectID ProjectID, testSuiteID TestSuiteID, params *ListBatchesForTestSuiteParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "testSuiteID", runtime.ParamLocationPath, testSuiteID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/suites/%s/batches", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateBatchForTestSuiteRequest calls the generic CreateBatchForTestSuite builder with application/json body
func NewCreateBatchForTestSuiteRequest(server string, projectID ProjectID, testSuiteID TestSuiteID, body CreateBatchForTestSuiteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateBatchForTestSuiteRequestWithBody(server, projectID, testSuiteID, "application/json", bodyReader)
}

// NewCreateBatchForTestSuiteRequestWithBody generates requests for CreateBatchForTestSuite with any type of body
func NewCreateBatchForTestSuiteRequestWithBody(server string, projectID ProjectID, testSuiteID TestSuiteID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "testSuiteID", runtime.ParamLocationPath, testSuiteID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/suites/%s/batches", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveExperiencesFromTestSuiteRequest calls the generic RemoveExperiencesFromTestSuite builder with application/json body
func NewRemoveExperiencesFromTestSuiteRequest(server string, projectID ProjectID, testSuiteID TestSuiteID, body RemoveExperiencesFromTestSuiteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRemoveExperiencesFromTestSuiteRequestWithBody(server, projectID, testSuiteID, "application/json", bodyReader)
}

// NewRemoveExperiencesFromTestSuiteRequestWithBody generates requests for RemoveExperiencesFromTestSuite with any type of body
func NewRemoveExperiencesFromTestSuiteRequestWithBody(server string, projectID ProjectID, testSuiteID TestSuiteID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "testSuiteID", runtime.ParamLocationPath, testSuiteID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/suites/%s/removeExperiences", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRestoreTestSuiteRequest generates requests for RestoreTestSuite
func NewRestoreTestSuiteRequest(server string, projectID ProjectID, testSuiteID TestSuiteID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "testSuiteID", runtime.ParamLocationPath, testSuiteID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/suites/%s/restore", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListTestSuiteRevisionsRequest generates requests for ListTestSuiteRevisions
func NewListTestSuiteRevisionsRequest(server string, projectID ProjectID, testSuiteID TestSuiteID, params *ListTestSuiteRevisionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "testSuiteID", runtime.ParamLocationPath, testSuiteID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/suites/%s/revisions", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTestSuiteRevisionRequest generates requests for GetTestSuiteRevision
func NewGetTestSuiteRevisionRequest(server string, projectID ProjectID, testSuiteID TestSuiteID, revision TestSuiteRevision) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "testSuiteID", runtime.ParamLocationPath, testSuiteID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "revision", runtime.ParamLocationPath, revision)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/suites/%s/revisions/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListBatchesForTestSuiteRevisionRequest generates requests for ListBatchesForTestSuiteRevision
func NewListBatchesForTestSuiteRevisionRequest(server string, projectID ProjectID, testSuiteID TestSuiteID, revision TestSuiteRevision, params *ListBatchesForTestSuiteRevisionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "testSuiteID", runtime.ParamLocationPath, testSuiteID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "revision", runtime.ParamLocationPath, revision)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/suites/%s/revisions/%s/batches", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateBatchForTestSuiteRevisionRequest calls the generic CreateBatchForTestSuiteRevision builder with application/json body
func NewCreateBatchForTestSuiteRevisionRequest(server string, projectID ProjectID, testSuiteID TestSuiteID, revision TestSuiteRevision, body CreateBatchForTestSuiteRevisionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateBatchForTestSuiteRevisionRequestWithBody(server, projectID, testSuiteID, revision, "application/json", bodyReader)
}

// NewCreateBatchForTestSuiteRevisionRequestWithBody generates requests for CreateBatchForTestSuiteRevision with any type of body
func NewCreateBatchForTestSuiteRevisionRequestWithBody(server string, projectID ProjectID, testSuiteID TestSuiteID, revision TestSuiteRevision, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "testSuiteID", runtime.ParamLocationPath, testSuiteID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "revision", runtime.ParamLocationPath, revision)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/suites/%s/revisions/%s/batches", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListParameterSweepsRequest generates requests for ListParameterSweeps
func NewListParameterSweepsRequest(server string, projectID ProjectID, params *ListParameterSweepsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/sweeps", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateParameterSweepRequest calls the generic CreateParameterSweep builder with application/json body
func NewCreateParameterSweepRequest(server string, projectID ProjectID, body CreateParameterSweepJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateParameterSweepRequestWithBody(server, projectID, "application/json", bodyReader)
}

// NewCreateParameterSweepRequestWithBody generates requests for CreateParameterSweep with any type of body
func NewCreateParameterSweepRequestWithBody(server string, projectID ProjectID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/sweeps", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListSweepAccountsRequest generates requests for ListSweepAccounts
func NewListSweepAccountsRequest(server string, projectID ProjectID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/sweeps/accounts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetParameterSweepRequest generates requests for GetParameterSweep
func NewGetParameterSweepRequest(server string, projectID ProjectID, sweepID ParameterSweepID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "sweepID", runtime.ParamLocationPath, sweepID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/sweeps/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCancelParameterSweepRequest generates requests for CancelParameterSweep
func NewCancelParameterSweepRequest(server string, projectID ProjectID, sweepID ParameterSweepID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "sweepID", runtime.ParamLocationPath, sweepID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/sweeps/%s/:cancel", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListSystemsRequest generates requests for ListSystems
func NewListSystemsRequest(server string, projectID ProjectID, params *ListSystemsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/systems", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSystemRequest calls the generic CreateSystem builder with application/json body
func NewCreateSystemRequest(server string, projectID ProjectID, body CreateSystemJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSystemRequestWithBody(server, projectID, "application/json", bodyReader)
}

// NewCreateSystemRequestWithBody generates requests for CreateSystem with any type of body
func NewCreateSystemRequestWithBody(server string, projectID ProjectID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/systems", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAddSystemsToExperiencesRequest calls the generic AddSystemsToExperiences builder with application/json body
func NewAddSystemsToExperiencesRequest(server string, projectID ProjectID, body AddSystemsToExperiencesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddSystemsToExperiencesRequestWithBody(server, projectID, "application/json", bodyReader)
}

// NewAddSystemsToExperiencesRequestWithBody generates requests for AddSystemsToExperiences with any type of body
func NewAddSystemsToExperiencesRequestWithBody(server string, projectID ProjectID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/systems/addExperiences", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveSystemsFromExperiencesRequest calls the generic RemoveSystemsFromExperiences builder with application/json body
func NewRemoveSystemsFromExperiencesRequest(server string, projectID ProjectID, body RemoveSystemsFromExperiencesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRemoveSystemsFromExperiencesRequestWithBody(server, projectID, "application/json", bodyReader)
}

// NewRemoveSystemsFromExperiencesRequestWithBody generates requests for RemoveSystemsFromExperiences with any type of body
func NewRemoveSystemsFromExperiencesRequestWithBody(server string, projectID ProjectID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/systems/removeExperiences", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewArchiveSystemRequest generates requests for ArchiveSystem
func NewArchiveSystemRequest(server string, projectID ProjectID, systemID SystemID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "systemID", runtime.ParamLocationPath, systemID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/systems/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSystemRequest generates requests for GetSystem
func NewGetSystemRequest(server string, projectID ProjectID, systemID SystemID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "systemID", runtime.ParamLocationPath, systemID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/systems/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateSystemRequest calls the generic UpdateSystem builder with application/json body
func NewUpdateSystemRequest(server string, projectID ProjectID, systemID SystemID, body UpdateSystemJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSystemRequestWithBody(server, projectID, systemID, "application/json", bodyReader)
}

// NewUpdateSystemRequestWithBody generates requests for UpdateSystem with any type of body
func NewUpdateSystemRequestWithBody(server string, projectID ProjectID, systemID SystemID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "systemID", runtime.ParamLocationPath, systemID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/systems/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListBuildsForSystemRequest generates requests for ListBuildsForSystem
func NewListBuildsForSystemRequest(server string, projectID ProjectID, systemID SystemID, params *ListBuildsForSystemParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "systemID", runtime.ParamLocationPath, systemID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/systems/%s/builds", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateBuildForSystemRequest calls the generic CreateBuildForSystem builder with application/json body
func NewCreateBuildForSystemRequest(server string, projectID ProjectID, systemID SystemID, body CreateBuildForSystemJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateBuildForSystemRequestWithBody(server, projectID, systemID, "application/json", bodyReader)
}

// NewCreateBuildForSystemRequestWithBody generates requests for CreateBuildForSystem with any type of body
func NewCreateBuildForSystemRequestWithBody(server string, projectID ProjectID, systemID SystemID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "systemID", runtime.ParamLocationPath, systemID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/systems/%s/builds", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetBuildForSystemRequest generates requests for GetBuildForSystem
func NewGetBuildForSystemRequest(server string, projectID ProjectID, systemID SystemID, buildID BuildID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "systemID", runtime.ParamLocationPath, systemID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "buildID", runtime.ParamLocationPath, buildID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/systems/%s/builds/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListExperiencesForSystemRequest generates requests for ListExperiencesForSystem
func NewListExperiencesForSystemRequest(server string, projectID ProjectID, systemID SystemID, params *ListExperiencesForSystemParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "systemID", runtime.ParamLocationPath, systemID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/systems/%s/experiences", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Archived != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "archived", runtime.ParamLocationQuery, *params.Archived); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveSystemFromExperienceRequest generates requests for RemoveSystemFromExperience
func NewRemoveSystemFromExperienceRequest(server string, projectID ProjectID, systemID SystemID, experienceID ExperienceID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "systemID", runtime.ParamLocationPath, systemID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "experienceID", runtime.ParamLocationPath, experienceID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/systems/%s/experiences/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddSystemToExperienceRequest generates requests for AddSystemToExperience
func NewAddSystemToExperienceRequest(server string, projectID ProjectID, systemID SystemID, experienceID ExperienceID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "systemID", runtime.ParamLocationPath, systemID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "experienceID", runtime.ParamLocationPath, experienceID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/systems/%s/experiences/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveSystemFromMetricsBuildRequest generates requests for RemoveSystemFromMetricsBuild
func NewRemoveSystemFromMetricsBuildRequest(server string, projectID ProjectID, systemID SystemID, metricsBuildID MetricsBuildID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "systemID", runtime.ParamLocationPath, systemID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "metricsBuildID", runtime.ParamLocationPath, metricsBuildID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/systems/%s/metricsBuilds/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddSystemToMetricsBuildRequest generates requests for AddSystemToMetricsBuild
func NewAddSystemToMetricsBuildRequest(server string, projectID ProjectID, systemID SystemID, metricsBuildID MetricsBuildID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "systemID", runtime.ParamLocationPath, systemID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "metricsBuildID", runtime.ParamLocationPath, metricsBuildID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/systems/%s/metricsBuilds/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetQuotaRequest generates requests for GetQuota
func NewGetQuotaRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/quota")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewValidateExperienceLocationRequest calls the generic ValidateExperienceLocation builder with application/json body
func NewValidateExperienceLocationRequest(server string, body ValidateExperienceLocationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewValidateExperienceLocationRequestWithBody(server, "application/json", bodyReader)
}

// NewValidateExperienceLocationRequestWithBody generates requests for ValidateExperienceLocation with any type of body
func NewValidateExperienceLocationRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/validateExperienceLocation")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListViewSessionsRequest generates requests for ListViewSessions
func NewListViewSessionsRequest(server string, params *ListViewSessionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/view/sessions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateViewSessionRequest generates requests for CreateViewSession
func NewCreateViewSessionRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/view/sessions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetViewSessionRequest generates requests for GetViewSession
func NewGetViewSessionRequest(server string, viewSessionID ViewSessionID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "viewSessionID", runtime.ParamLocationPath, viewSessionID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/view/sessions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateViewUpdateRequestWithBody generates requests for CreateViewUpdate with any type of body
func NewCreateViewUpdateRequestWithBody(server string, viewSessionID ViewSessionID, viewUpdateID ViewUpdateID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "viewSessionID", runtime.ParamLocationPath, viewSessionID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "viewUpdateID", runtime.ParamLocationPath, viewUpdateID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/view/sessions/%s/updates/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// HealthWithResponse request
	HealthWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*HealthResponse, error)

	// ListProjectsWithResponse request
	ListProjectsWithResponse(ctx context.Context, params *ListProjectsParams, reqEditors ...RequestEditorFn) (*ListProjectsResponse, error)

	// CreateProjectWithBodyWithResponse request with any body
	CreateProjectWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProjectResponse, error)

	CreateProjectWithResponse(ctx context.Context, body CreateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProjectResponse, error)

	// ArchiveProjectWithResponse request
	ArchiveProjectWithResponse(ctx context.Context, projectID ProjectID, reqEditors ...RequestEditorFn) (*ArchiveProjectResponse, error)

	// GetProjectWithResponse request
	GetProjectWithResponse(ctx context.Context, projectID ProjectID, reqEditors ...RequestEditorFn) (*GetProjectResponse, error)

	// UpdateProjectWithBodyWithResponse request with any body
	UpdateProjectWithBodyWithResponse(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProjectResponse, error)

	UpdateProjectWithResponse(ctx context.Context, projectID ProjectID, body UpdateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProjectResponse, error)

	// ListBatchesWithResponse request
	ListBatchesWithResponse(ctx context.Context, projectID ProjectID, params *ListBatchesParams, reqEditors ...RequestEditorFn) (*ListBatchesResponse, error)

	// CreateBatchWithBodyWithResponse request with any body
	CreateBatchWithBodyWithResponse(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBatchResponse, error)

	CreateBatchWithResponse(ctx context.Context, projectID ProjectID, body CreateBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBatchResponse, error)

	// ListAllJobsWithResponse request
	ListAllJobsWithResponse(ctx context.Context, projectID ProjectID, params *ListAllJobsParams, reqEditors ...RequestEditorFn) (*ListAllJobsResponse, error)

	// ListBatchAccountsWithResponse request
	ListBatchAccountsWithResponse(ctx context.Context, projectID ProjectID, params *ListBatchAccountsParams, reqEditors ...RequestEditorFn) (*ListBatchAccountsResponse, error)

	// GetBatchWithResponse request
	GetBatchWithResponse(ctx context.Context, projectID ProjectID, batchID BatchID, reqEditors ...RequestEditorFn) (*GetBatchResponse, error)

	// UpdateBatchWithBodyWithResponse request with any body
	UpdateBatchWithBodyWithResponse(ctx context.Context, projectID ProjectID, batchID BatchID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateBatchResponse, error)

	UpdateBatchWithResponse(ctx context.Context, projectID ProjectID, batchID BatchID, body UpdateBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateBatchResponse, error)

	// CancelBatchWithResponse request
	CancelBatchWithResponse(ctx context.Context, projectID ProjectID, batchID BatchID, reqEditors ...RequestEditorFn) (*CancelBatchResponse, error)

	// CompareBatchesWithResponse request
	CompareBatchesWithResponse(ctx context.Context, projectID ProjectID, batchID BatchID, otherBatchID BatchID, params *CompareBatchesParams, reqEditors ...RequestEditorFn) (*CompareBatchesResponse, error)

	// ListBatchErrorsWithResponse request
	ListBatchErrorsWithResponse(ctx context.Context, projectID ProjectID, batchID BatchID, reqEditors ...RequestEditorFn) (*ListBatchErrorsResponse, error)

	// ListJobsWithResponse request
	ListJobsWithResponse(ctx context.Context, projectID ProjectID, batchID BatchID, params *ListJobsParams, reqEditors ...RequestEditorFn) (*ListJobsResponse, error)

	// GetJobWithResponse request
	GetJobWithResponse(ctx context.Context, projectID ProjectID, batchID BatchID, jobID JobID, reqEditors ...RequestEditorFn) (*GetJobResponse, error)

	// UpdateJobWithBodyWithResponse request with any body
	UpdateJobWithBodyWithResponse(ctx context.Context, projectID ProjectID, batchID BatchID, jobID JobID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateJobResponse, error)

	UpdateJobWithResponse(ctx context.Context, projectID ProjectID, batchID BatchID, jobID JobID, body UpdateJobJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateJobResponse, error)

	// ListEventTagsForJobWithResponse request
	ListEventTagsForJobWithResponse(ctx context.Context, projectID ProjectID, batchID BatchID, jobID JobID, params *ListEventTagsForJobParams, reqEditors ...RequestEditorFn) (*ListEventTagsForJobResponse, error)

	// ListEventsForJobWithResponse request
	ListEventsForJobWithResponse(ctx context.Context, projectID ProjectID, batchID BatchID, jobID JobID, params *ListEventsForJobParams, reqEditors ...RequestEditorFn) (*ListEventsForJobResponse, error)

	// GetEventForJobWithResponse request
	GetEventForJobWithResponse(ctx context.Context, projectID ProjectID, batchID BatchID, jobID JobID, eventID EventID, reqEditors ...RequestEditorFn) (*GetEventForJobResponse, error)

	// UpdateEventWithBodyWithResponse request with any body
	UpdateEventWithBodyWithResponse(ctx context.Context, projectID ProjectID, batchID BatchID, jobID JobID, eventID EventID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateEventResponse, error)

	UpdateEventWithResponse(ctx context.Context, projectID ProjectID, batchID BatchID, jobID JobID, eventID EventID, body UpdateEventJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateEventResponse, error)

	// ListJobLogsForJobWithResponse request
	ListJobLogsForJobWithResponse(ctx context.Context, projectID ProjectID, batchID BatchID, jobID JobID, params *ListJobLogsForJobParams, reqEditors ...RequestEditorFn) (*ListJobLogsForJobResponse, error)

	// DeleteJobLogWithResponse request
	DeleteJobLogWithResponse(ctx context.Context, projectID ProjectID, batchID BatchID, jobID JobID, logID LogID, reqEditors ...RequestEditorFn) (*DeleteJobLogResponse, error)

	// GetJobLogWithResponse request
	GetJobLogWithResponse(ctx context.Context, projectID ProjectID, batchID BatchID, jobID JobID, logID LogID, reqEditors ...RequestEditorFn) (*GetJobLogResponse, error)

	// ListMetricsForJobWithResponse request
	ListMetricsForJobWithResponse(ctx context.Context, projectID ProjectID, batchID BatchID, jobID JobID, params *ListMetricsForJobParams, reqEditors ...RequestEditorFn) (*ListMetricsForJobResponse, error)

	// ListMetricsForMetricIDsWithResponse request
	ListMetricsForMetricIDsWithResponse(ctx context.Context, projectID ProjectID, batchID BatchID, jobID JobID, metricID []MetricID, params *ListMetricsForMetricIDsParams, reqEditors ...RequestEditorFn) (*ListMetricsForMetricIDsResponse, error)

	// ListMetricsDataForMetricIDsWithResponse request
	ListMetricsDataForMetricIDsWithResponse(ctx context.Context, projectID ProjectID, batchID BatchID, jobID JobID, metricID []MetricID, params *ListMetricsDataForMetricIDsParams, reqEditors ...RequestEditorFn) (*ListMetricsDataForMetricIDsResponse, error)

	// ListTagsForJobMetricsWithResponse request
	ListTagsForJobMetricsWithResponse(ctx context.Context, projectID ProjectID, batchID BatchID, jobID JobID, metricID []MetricID, params *ListTagsForJobMetricsParams, reqEditors ...RequestEditorFn) (*ListTagsForJobMetricsResponse, error)

	// ListMetricsDataForJobWithResponse request
	ListMetricsDataForJobWithResponse(ctx context.Context, projectID ProjectID, batchID BatchID, jobID JobID, params *ListMetricsDataForJobParams, reqEditors ...RequestEditorFn) (*ListMetricsDataForJobResponse, error)

	// ListMetricsDataForMetricsDataIDsWithResponse request
	ListMetricsDataForMetricsDataIDsWithResponse(ctx context.Context, projectID ProjectID, batchID BatchID, jobID JobID, metricsDataID []MetricsDataID, params *ListMetricsDataForMetricsDataIDsParams, reqEditors ...RequestEditorFn) (*ListMetricsDataForMetricsDataIDsResponse, error)

	// ListBatchLogsForBatchWithResponse request
	ListBatchLogsForBatchWithResponse(ctx context.Context, projectID ProjectID, batchID BatchID, params *ListBatchLogsForBatchParams, reqEditors ...RequestEditorFn) (*ListBatchLogsForBatchResponse, error)

	// DeleteBatchLogWithResponse request
	DeleteBatchLogWithResponse(ctx context.Context, projectID ProjectID, batchID BatchID, logID LogID, reqEditors ...RequestEditorFn) (*DeleteBatchLogResponse, error)

	// GetBatchLogWithResponse request
	GetBatchLogWithResponse(ctx context.Context, projectID ProjectID, batchID BatchID, logID LogID, reqEditors ...RequestEditorFn) (*GetBatchLogResponse, error)

	// ListBatchMetricsWithResponse request
	ListBatchMetricsWithResponse(ctx context.Context, projectID ProjectID, batchID BatchID, params *ListBatchMetricsParams, reqEditors ...RequestEditorFn) (*ListBatchMetricsResponse, error)

	// ListBatchMetricsForBatchMetricIDsWithResponse request
	ListBatchMetricsForBatchMetricIDsWithResponse(ctx context.Context, projectID ProjectID, batchID BatchID, metricID []MetricID, params *ListBatchMetricsForBatchMetricIDsParams, reqEditors ...RequestEditorFn) (*ListBatchMetricsForBatchMetricIDsResponse, error)

	// ListBatchMetricsDataForBatchMetricIDsWithResponse request
	ListBatchMetricsDataForBatchMetricIDsWithResponse(ctx context.Context, projectID ProjectID, batchID BatchID, metricID []MetricID, params *ListBatchMetricsDataForBatchMetricIDsParams, reqEditors ...RequestEditorFn) (*ListBatchMetricsDataForBatchMetricIDsResponse, error)

	// ListTagsForBatchMetricsWithResponse request
	ListTagsForBatchMetricsWithResponse(ctx context.Context, projectID ProjectID, batchID BatchID, metricID []MetricID, params *ListTagsForBatchMetricsParams, reqEditors ...RequestEditorFn) (*ListTagsForBatchMetricsResponse, error)

	// ListBatchMetricsDataWithResponse request
	ListBatchMetricsDataWithResponse(ctx context.Context, projectID ProjectID, batchID BatchID, params *ListBatchMetricsDataParams, reqEditors ...RequestEditorFn) (*ListBatchMetricsDataResponse, error)

	// ListBatchMetricsDataForBatchMetricsDataIDsWithResponse request
	ListBatchMetricsDataForBatchMetricsDataIDsWithResponse(ctx context.Context, projectID ProjectID, batchID BatchID, metricsDataID []MetricsDataID, params *ListBatchMetricsDataForBatchMetricsDataIDsParams, reqEditors ...RequestEditorFn) (*ListBatchMetricsDataForBatchMetricsDataIDsResponse, error)

	// RerunBatchWithBodyWithResponse request with any body
	RerunBatchWithBodyWithResponse(ctx context.Context, projectID ProjectID, batchID BatchID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RerunBatchResponse, error)

	RerunBatchWithResponse(ctx context.Context, projectID ProjectID, batchID BatchID, body RerunBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*RerunBatchResponse, error)

	// GetBatchSuggestionsWithResponse request
	GetBatchSuggestionsWithResponse(ctx context.Context, projectID ProjectID, batchID BatchID, reqEditors ...RequestEditorFn) (*GetBatchSuggestionsResponse, error)

	// ListBranchesForProjectWithResponse request
	ListBranchesForProjectWithResponse(ctx context.Context, projectID ProjectID, params *ListBranchesForProjectParams, reqEditors ...RequestEditorFn) (*ListBranchesForProjectResponse, error)

	// CreateBranchForProjectWithBodyWithResponse request with any body
	CreateBranchForProjectWithBodyWithResponse(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBranchForProjectResponse, error)

	CreateBranchForProjectWithResponse(ctx context.Context, projectID ProjectID, body CreateBranchForProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBranchForProjectResponse, error)

	// DeleteBranchForProjectWithResponse request
	DeleteBranchForProjectWithResponse(ctx context.Context, projectID ProjectID, branchID BranchID, reqEditors ...RequestEditorFn) (*DeleteBranchForProjectResponse, error)

	// GetBranchForProjectWithResponse request
	GetBranchForProjectWithResponse(ctx context.Context, projectID ProjectID, branchID BranchID, reqEditors ...RequestEditorFn) (*GetBranchForProjectResponse, error)

	// ListBuildsForBranchesWithResponse request
	ListBuildsForBranchesWithResponse(ctx context.Context, projectID ProjectID, branchID []BranchID, params *ListBuildsForBranchesParams, reqEditors ...RequestEditorFn) (*ListBuildsForBranchesResponse, error)

	// CreateBuildForBranchWithBodyWithResponse request with any body
	CreateBuildForBranchWithBodyWithResponse(ctx context.Context, projectID ProjectID, branchID BranchID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBuildForBranchResponse, error)

	CreateBuildForBranchWithResponse(ctx context.Context, projectID ProjectID, branchID BranchID, body CreateBuildForBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBuildForBranchResponse, error)

	// DeleteBuildForBranchWithResponse request
	DeleteBuildForBranchWithResponse(ctx context.Context, projectID ProjectID, branchID BranchID, buildID BuildID, reqEditors ...RequestEditorFn) (*DeleteBuildForBranchResponse, error)

	// GetBuildForBranchWithResponse request
	GetBuildForBranchWithResponse(ctx context.Context, projectID ProjectID, branchID BranchID, buildID BuildID, reqEditors ...RequestEditorFn) (*GetBuildForBranchResponse, error)

	// ListBatchesForBuildsWithResponse request
	ListBatchesForBuildsWithResponse(ctx context.Context, projectID ProjectID, branchID BranchID, buildID []BuildID, params *ListBatchesForBuildsParams, reqEditors ...RequestEditorFn) (*ListBatchesForBuildsResponse, error)

	// ListBuildsWithResponse request
	ListBuildsWithResponse(ctx context.Context, projectID ProjectID, params *ListBuildsParams, reqEditors ...RequestEditorFn) (*ListBuildsResponse, error)

	// ListBuildAccountsWithResponse request
	ListBuildAccountsWithResponse(ctx context.Context, projectID ProjectID, reqEditors ...RequestEditorFn) (*ListBuildAccountsResponse, error)

	// GetBuildWithResponse request
	GetBuildWithResponse(ctx context.Context, projectID ProjectID, buildID BuildID, reqEditors ...RequestEditorFn) (*GetBuildResponse, error)

	// UpdateBuildWithBodyWithResponse request with any body
	UpdateBuildWithBodyWithResponse(ctx context.Context, projectID ProjectID, buildID BuildID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateBuildResponse, error)

	UpdateBuildWithResponse(ctx context.Context, projectID ProjectID, buildID BuildID, body UpdateBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateBuildResponse, error)

	// ListExperienceTagsWithResponse request
	ListExperienceTagsWithResponse(ctx context.Context, projectID ProjectID, params *ListExperienceTagsParams, reqEditors ...RequestEditorFn) (*ListExperienceTagsResponse, error)

	// CreateExperienceTagWithBodyWithResponse request with any body
	CreateExperienceTagWithBodyWithResponse(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateExperienceTagResponse, error)

	CreateExperienceTagWithResponse(ctx context.Context, projectID ProjectID, body CreateExperienceTagJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateExperienceTagResponse, error)

	// AddTagsToExperiencesWithBodyWithResponse request with any body
	AddTagsToExperiencesWithBodyWithResponse(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddTagsToExperiencesResponse, error)

	AddTagsToExperiencesWithResponse(ctx context.Context, projectID ProjectID, body AddTagsToExperiencesJSONRequestBody, reqEditors ...RequestEditorFn) (*AddTagsToExperiencesResponse, error)

	// DeleteExperienceTagWithResponse request
	DeleteExperienceTagWithResponse(ctx context.Context, projectID ProjectID, experienceTagID ExperienceTagID, reqEditors ...RequestEditorFn) (*DeleteExperienceTagResponse, error)

	// GetExperienceTagWithResponse request
	GetExperienceTagWithResponse(ctx context.Context, projectID ProjectID, experienceTagID ExperienceTagID, reqEditors ...RequestEditorFn) (*GetExperienceTagResponse, error)

	// UpdateExperienceTagWithBodyWithResponse request with any body
	UpdateExperienceTagWithBodyWithResponse(ctx context.Context, projectID ProjectID, experienceTagID ExperienceTagID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateExperienceTagResponse, error)

	UpdateExperienceTagWithResponse(ctx context.Context, projectID ProjectID, experienceTagID ExperienceTagID, body UpdateExperienceTagJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateExperienceTagResponse, error)

	// ListExperiencesWithExperienceTagWithResponse request
	ListExperiencesWithExperienceTagWithResponse(ctx context.Context, projectID ProjectID, experienceTagID ExperienceTagID, params *ListExperiencesWithExperienceTagParams, reqEditors ...RequestEditorFn) (*ListExperiencesWithExperienceTagResponse, error)

	// RemoveExperienceTagFromExperienceWithResponse request
	RemoveExperienceTagFromExperienceWithResponse(ctx context.Context, projectID ProjectID, experienceTagID ExperienceTagID, experienceID ExperienceID, reqEditors ...RequestEditorFn) (*RemoveExperienceTagFromExperienceResponse, error)

	// AddExperienceTagToExperienceWithResponse request
	AddExperienceTagToExperienceWithResponse(ctx context.Context, projectID ProjectID, experienceTagID ExperienceTagID, experienceID ExperienceID, reqEditors ...RequestEditorFn) (*AddExperienceTagToExperienceResponse, error)

	// ListExperiencesWithResponse request
	ListExperiencesWithResponse(ctx context.Context, projectID ProjectID, params *ListExperiencesParams, reqEditors ...RequestEditorFn) (*ListExperiencesResponse, error)

	// CreateExperienceWithBodyWithResponse request with any body
	CreateExperienceWithBodyWithResponse(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateExperienceResponse, error)

	CreateExperienceWithResponse(ctx context.Context, projectID ProjectID, body CreateExperienceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateExperienceResponse, error)

	// ArchiveExperienceWithResponse request
	ArchiveExperienceWithResponse(ctx context.Context, projectID ProjectID, experienceID ExperienceID, reqEditors ...RequestEditorFn) (*ArchiveExperienceResponse, error)

	// GetExperienceWithResponse request
	GetExperienceWithResponse(ctx context.Context, projectID ProjectID, experienceID ExperienceID, reqEditors ...RequestEditorFn) (*GetExperienceResponse, error)

	// UpdateExperienceWithBodyWithResponse request with any body
	UpdateExperienceWithBodyWithResponse(ctx context.Context, projectID ProjectID, experienceID ExperienceID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateExperienceResponse, error)

	UpdateExperienceWithResponse(ctx context.Context, projectID ProjectID, experienceID ExperienceID, body UpdateExperienceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateExperienceResponse, error)

	// DebugExperienceWithBodyWithResponse request with any body
	DebugExperienceWithBodyWithResponse(ctx context.Context, projectID ProjectID, experienceID ExperienceID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DebugExperienceResponse, error)

	DebugExperienceWithResponse(ctx context.Context, projectID ProjectID, experienceID ExperienceID, body DebugExperienceJSONRequestBody, reqEditors ...RequestEditorFn) (*DebugExperienceResponse, error)

	// ListExperienceTagsForExperienceWithResponse request
	ListExperienceTagsForExperienceWithResponse(ctx context.Context, projectID ProjectID, experienceID ExperienceID, params *ListExperienceTagsForExperienceParams, reqEditors ...RequestEditorFn) (*ListExperienceTagsForExperienceResponse, error)

	// RestoreExperienceWithResponse request
	RestoreExperienceWithResponse(ctx context.Context, projectID ProjectID, experienceID ExperienceID, reqEditors ...RequestEditorFn) (*RestoreExperienceResponse, error)

	// GetSystemsForExperienceWithResponse request
	GetSystemsForExperienceWithResponse(ctx context.Context, projectID ProjectID, experienceID ExperienceID, params *GetSystemsForExperienceParams, reqEditors ...RequestEditorFn) (*GetSystemsForExperienceResponse, error)

	// ListMetricsBuildsWithResponse request
	ListMetricsBuildsWithResponse(ctx context.Context, projectID ProjectID, params *ListMetricsBuildsParams, reqEditors ...RequestEditorFn) (*ListMetricsBuildsResponse, error)

	// CreateMetricsBuildWithBodyWithResponse request with any body
	CreateMetricsBuildWithBodyWithResponse(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateMetricsBuildResponse, error)

	CreateMetricsBuildWithResponse(ctx context.Context, projectID ProjectID, body CreateMetricsBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateMetricsBuildResponse, error)

	// GetMetricsBuildWithResponse request
	GetMetricsBuildWithResponse(ctx context.Context, projectID ProjectID, metricsBuildID MetricsBuildID, reqEditors ...RequestEditorFn) (*GetMetricsBuildResponse, error)

	// GetSystemsForMetricsBuildWithResponse request
	GetSystemsForMetricsBuildWithResponse(ctx context.Context, projectID ProjectID, metricsBuildID MetricsBuildID, params *GetSystemsForMetricsBuildParams, reqEditors ...RequestEditorFn) (*GetSystemsForMetricsBuildResponse, error)

	// ListServiceProfilesWithResponse request
	ListServiceProfilesWithResponse(ctx context.Context, projectID ProjectID, reqEditors ...RequestEditorFn) (*ListServiceProfilesResponse, error)

	// ListReportsWithResponse request
	ListReportsWithResponse(ctx context.Context, projectID ProjectID, params *ListReportsParams, reqEditors ...RequestEditorFn) (*ListReportsResponse, error)

	// CreateReportWithBodyWithResponse request with any body
	CreateReportWithBodyWithResponse(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateReportResponse, error)

	CreateReportWithResponse(ctx context.Context, projectID ProjectID, body CreateReportJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateReportResponse, error)

	// ListReportAccountsWithResponse request
	ListReportAccountsWithResponse(ctx context.Context, projectID ProjectID, reqEditors ...RequestEditorFn) (*ListReportAccountsResponse, error)

	// GetReportWithResponse request
	GetReportWithResponse(ctx context.Context, projectID ProjectID, reportID ReportID, reqEditors ...RequestEditorFn) (*GetReportResponse, error)

	// ListLogsForReportWithResponse request
	ListLogsForReportWithResponse(ctx context.Context, projectID ProjectID, reportID ReportID, params *ListLogsForReportParams, reqEditors ...RequestEditorFn) (*ListLogsForReportResponse, error)

	// GetReportLogWithResponse request
	GetReportLogWithResponse(ctx context.Context, projectID ProjectID, reportID ReportID, logID LogID, reqEditors ...RequestEditorFn) (*GetReportLogResponse, error)

	// ListReportMetricsWithResponse request
	ListReportMetricsWithResponse(ctx context.Context, projectID ProjectID, reportID ReportID, params *ListReportMetricsParams, reqEditors ...RequestEditorFn) (*ListReportMetricsResponse, error)

	// ListReportMetricsForReportMetricIDsWithResponse request
	ListReportMetricsForReportMetricIDsWithResponse(ctx context.Context, projectID ProjectID, reportID ReportID, metricID []MetricID, params *ListReportMetricsForReportMetricIDsParams, reqEditors ...RequestEditorFn) (*ListReportMetricsForReportMetricIDsResponse, error)

	// ListReportMetricsDataForReportMetricIDsWithResponse request
	ListReportMetricsDataForReportMetricIDsWithResponse(ctx context.Context, projectID ProjectID, reportID ReportID, metricID []MetricID, params *ListReportMetricsDataForReportMetricIDsParams, reqEditors ...RequestEditorFn) (*ListReportMetricsDataForReportMetricIDsResponse, error)

	// ListTagsForReportMetricsWithResponse request
	ListTagsForReportMetricsWithResponse(ctx context.Context, projectID ProjectID, reportID ReportID, metricID []MetricID, params *ListTagsForReportMetricsParams, reqEditors ...RequestEditorFn) (*ListTagsForReportMetricsResponse, error)

	// ListReportMetricsDataWithResponse request
	ListReportMetricsDataWithResponse(ctx context.Context, projectID ProjectID, reportID ReportID, params *ListReportMetricsDataParams, reqEditors ...RequestEditorFn) (*ListReportMetricsDataResponse, error)

	// ListReportMetricsDataForReportMetricsDataIDsWithResponse request
	ListReportMetricsDataForReportMetricsDataIDsWithResponse(ctx context.Context, projectID ProjectID, reportID ReportID, metricsDataID []MetricsDataID, params *ListReportMetricsDataForReportMetricsDataIDsParams, reqEditors ...RequestEditorFn) (*ListReportMetricsDataForReportMetricsDataIDsResponse, error)

	// ListTestSuitesWithResponse request
	ListTestSuitesWithResponse(ctx context.Context, projectID ProjectID, params *ListTestSuitesParams, reqEditors ...RequestEditorFn) (*ListTestSuitesResponse, error)

	// CreateTestSuiteWithBodyWithResponse request with any body
	CreateTestSuiteWithBodyWithResponse(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTestSuiteResponse, error)

	CreateTestSuiteWithResponse(ctx context.Context, projectID ProjectID, body CreateTestSuiteJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTestSuiteResponse, error)

	// AddTestSuitesToExperiencesWithBodyWithResponse request with any body
	AddTestSuitesToExperiencesWithBodyWithResponse(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddTestSuitesToExperiencesResponse, error)

	AddTestSuitesToExperiencesWithResponse(ctx context.Context, projectID ProjectID, body AddTestSuitesToExperiencesJSONRequestBody, reqEditors ...RequestEditorFn) (*AddTestSuitesToExperiencesResponse, error)

	// GetTestSuiteSummaryWithResponse request
	GetTestSuiteSummaryWithResponse(ctx context.Context, projectID ProjectID, params *GetTestSuiteSummaryParams, reqEditors ...RequestEditorFn) (*GetTestSuiteSummaryResponse, error)

	// ArchiveTestSuiteWithResponse request
	ArchiveTestSuiteWithResponse(ctx context.Context, projectID ProjectID, testSuiteID TestSuiteID, reqEditors ...RequestEditorFn) (*ArchiveTestSuiteResponse, error)

	// GetTestSuiteWithResponse request
	GetTestSuiteWithResponse(ctx context.Context, projectID ProjectID, testSuiteID TestSuiteID, reqEditors ...RequestEditorFn) (*GetTestSuiteResponse, error)

	// ReviseTestSuiteWithBodyWithResponse request with any body
	ReviseTestSuiteWithBodyWithResponse(ctx context.Context, projectID ProjectID, testSuiteID TestSuiteID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReviseTestSuiteResponse, error)

	ReviseTestSuiteWithResponse(ctx context.Context, projectID ProjectID, testSuiteID TestSuiteID, body ReviseTestSuiteJSONRequestBody, reqEditors ...RequestEditorFn) (*ReviseTestSuiteResponse, error)

	// AddExperiencesToTestSuiteWithBodyWithResponse request with any body
	AddExperiencesToTestSuiteWithBodyWithResponse(ctx context.Context, projectID ProjectID, testSuiteID TestSuiteID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddExperiencesToTestSuiteResponse, error)

	AddExperiencesToTestSuiteWithResponse(ctx context.Context, projectID ProjectID, testSuiteID TestSuiteID, body AddExperiencesToTestSuiteJSONRequestBody, reqEditors ...RequestEditorFn) (*AddExperiencesToTestSuiteResponse, error)

	// ListBatchesForTestSuiteWithResponse request
	ListBatchesForTestSuiteWithResponse(ctx context.Context, projectID ProjectID, testSuiteID TestSuiteID, params *ListBatchesForTestSuiteParams, reqEditors ...RequestEditorFn) (*ListBatchesForTestSuiteResponse, error)

	// CreateBatchForTestSuiteWithBodyWithResponse request with any body
	CreateBatchForTestSuiteWithBodyWithResponse(ctx context.Context, projectID ProjectID, testSuiteID TestSuiteID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBatchForTestSuiteResponse, error)

	CreateBatchForTestSuiteWithResponse(ctx context.Context, projectID ProjectID, testSuiteID TestSuiteID, body CreateBatchForTestSuiteJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBatchForTestSuiteResponse, error)

	// RemoveExperiencesFromTestSuiteWithBodyWithResponse request with any body
	RemoveExperiencesFromTestSuiteWithBodyWithResponse(ctx context.Context, projectID ProjectID, testSuiteID TestSuiteID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveExperiencesFromTestSuiteResponse, error)

	RemoveExperiencesFromTestSuiteWithResponse(ctx context.Context, projectID ProjectID, testSuiteID TestSuiteID, body RemoveExperiencesFromTestSuiteJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveExperiencesFromTestSuiteResponse, error)

	// RestoreTestSuiteWithResponse request
	RestoreTestSuiteWithResponse(ctx context.Context, projectID ProjectID, testSuiteID TestSuiteID, reqEditors ...RequestEditorFn) (*RestoreTestSuiteResponse, error)

	// ListTestSuiteRevisionsWithResponse request
	ListTestSuiteRevisionsWithResponse(ctx context.Context, projectID ProjectID, testSuiteID TestSuiteID, params *ListTestSuiteRevisionsParams, reqEditors ...RequestEditorFn) (*ListTestSuiteRevisionsResponse, error)

	// GetTestSuiteRevisionWithResponse request
	GetTestSuiteRevisionWithResponse(ctx context.Context, projectID ProjectID, testSuiteID TestSuiteID, revision TestSuiteRevision, reqEditors ...RequestEditorFn) (*GetTestSuiteRevisionResponse, error)

	// ListBatchesForTestSuiteRevisionWithResponse request
	ListBatchesForTestSuiteRevisionWithResponse(ctx context.Context, projectID ProjectID, testSuiteID TestSuiteID, revision TestSuiteRevision, params *ListBatchesForTestSuiteRevisionParams, reqEditors ...RequestEditorFn) (*ListBatchesForTestSuiteRevisionResponse, error)

	// CreateBatchForTestSuiteRevisionWithBodyWithResponse request with any body
	CreateBatchForTestSuiteRevisionWithBodyWithResponse(ctx context.Context, projectID ProjectID, testSuiteID TestSuiteID, revision TestSuiteRevision, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBatchForTestSuiteRevisionResponse, error)

	CreateBatchForTestSuiteRevisionWithResponse(ctx context.Context, projectID ProjectID, testSuiteID TestSuiteID, revision TestSuiteRevision, body CreateBatchForTestSuiteRevisionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBatchForTestSuiteRevisionResponse, error)

	// ListParameterSweepsWithResponse request
	ListParameterSweepsWithResponse(ctx context.Context, projectID ProjectID, params *ListParameterSweepsParams, reqEditors ...RequestEditorFn) (*ListParameterSweepsResponse, error)

	// CreateParameterSweepWithBodyWithResponse request with any body
	CreateParameterSweepWithBodyWithResponse(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateParameterSweepResponse, error)

	CreateParameterSweepWithResponse(ctx context.Context, projectID ProjectID, body CreateParameterSweepJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateParameterSweepResponse, error)

	// ListSweepAccountsWithResponse request
	ListSweepAccountsWithResponse(ctx context.Context, projectID ProjectID, reqEditors ...RequestEditorFn) (*ListSweepAccountsResponse, error)

	// GetParameterSweepWithResponse request
	GetParameterSweepWithResponse(ctx context.Context, projectID ProjectID, sweepID ParameterSweepID, reqEditors ...RequestEditorFn) (*GetParameterSweepResponse, error)

	// CancelParameterSweepWithResponse request
	CancelParameterSweepWithResponse(ctx context.Context, projectID ProjectID, sweepID ParameterSweepID, reqEditors ...RequestEditorFn) (*CancelParameterSweepResponse, error)

	// ListSystemsWithResponse request
	ListSystemsWithResponse(ctx context.Context, projectID ProjectID, params *ListSystemsParams, reqEditors ...RequestEditorFn) (*ListSystemsResponse, error)

	// CreateSystemWithBodyWithResponse request with any body
	CreateSystemWithBodyWithResponse(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSystemResponse, error)

	CreateSystemWithResponse(ctx context.Context, projectID ProjectID, body CreateSystemJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSystemResponse, error)

	// AddSystemsToExperiencesWithBodyWithResponse request with any body
	AddSystemsToExperiencesWithBodyWithResponse(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddSystemsToExperiencesResponse, error)

	AddSystemsToExperiencesWithResponse(ctx context.Context, projectID ProjectID, body AddSystemsToExperiencesJSONRequestBody, reqEditors ...RequestEditorFn) (*AddSystemsToExperiencesResponse, error)

	// RemoveSystemsFromExperiencesWithBodyWithResponse request with any body
	RemoveSystemsFromExperiencesWithBodyWithResponse(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveSystemsFromExperiencesResponse, error)

	RemoveSystemsFromExperiencesWithResponse(ctx context.Context, projectID ProjectID, body RemoveSystemsFromExperiencesJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveSystemsFromExperiencesResponse, error)

	// ArchiveSystemWithResponse request
	ArchiveSystemWithResponse(ctx context.Context, projectID ProjectID, systemID SystemID, reqEditors ...RequestEditorFn) (*ArchiveSystemResponse, error)

	// GetSystemWithResponse request
	GetSystemWithResponse(ctx context.Context, projectID ProjectID, systemID SystemID, reqEditors ...RequestEditorFn) (*GetSystemResponse, error)

	// UpdateSystemWithBodyWithResponse request with any body
	UpdateSystemWithBodyWithResponse(ctx context.Context, projectID ProjectID, systemID SystemID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSystemResponse, error)

	UpdateSystemWithResponse(ctx context.Context, projectID ProjectID, systemID SystemID, body UpdateSystemJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSystemResponse, error)

	// ListBuildsForSystemWithResponse request
	ListBuildsForSystemWithResponse(ctx context.Context, projectID ProjectID, systemID SystemID, params *ListBuildsForSystemParams, reqEditors ...RequestEditorFn) (*ListBuildsForSystemResponse, error)

	// CreateBuildForSystemWithBodyWithResponse request with any body
	CreateBuildForSystemWithBodyWithResponse(ctx context.Context, projectID ProjectID, systemID SystemID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBuildForSystemResponse, error)

	CreateBuildForSystemWithResponse(ctx context.Context, projectID ProjectID, systemID SystemID, body CreateBuildForSystemJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBuildForSystemResponse, error)

	// GetBuildForSystemWithResponse request
	GetBuildForSystemWithResponse(ctx context.Context, projectID ProjectID, systemID SystemID, buildID BuildID, reqEditors ...RequestEditorFn) (*GetBuildForSystemResponse, error)

	// ListExperiencesForSystemWithResponse request
	ListExperiencesForSystemWithResponse(ctx context.Context, projectID ProjectID, systemID SystemID, params *ListExperiencesForSystemParams, reqEditors ...RequestEditorFn) (*ListExperiencesForSystemResponse, error)

	// RemoveSystemFromExperienceWithResponse request
	RemoveSystemFromExperienceWithResponse(ctx context.Context, projectID ProjectID, systemID SystemID, experienceID ExperienceID, reqEditors ...RequestEditorFn) (*RemoveSystemFromExperienceResponse, error)

	// AddSystemToExperienceWithResponse request
	AddSystemToExperienceWithResponse(ctx context.Context, projectID ProjectID, systemID SystemID, experienceID ExperienceID, reqEditors ...RequestEditorFn) (*AddSystemToExperienceResponse, error)

	// RemoveSystemFromMetricsBuildWithResponse request
	RemoveSystemFromMetricsBuildWithResponse(ctx context.Context, projectID ProjectID, systemID SystemID, metricsBuildID MetricsBuildID, reqEditors ...RequestEditorFn) (*RemoveSystemFromMetricsBuildResponse, error)

	// AddSystemToMetricsBuildWithResponse request
	AddSystemToMetricsBuildWithResponse(ctx context.Context, projectID ProjectID, systemID SystemID, metricsBuildID MetricsBuildID, reqEditors ...RequestEditorFn) (*AddSystemToMetricsBuildResponse, error)

	// GetQuotaWithResponse request
	GetQuotaWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetQuotaResponse, error)

	// ValidateExperienceLocationWithBodyWithResponse request with any body
	ValidateExperienceLocationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ValidateExperienceLocationResponse, error)

	ValidateExperienceLocationWithResponse(ctx context.Context, body ValidateExperienceLocationJSONRequestBody, reqEditors ...RequestEditorFn) (*ValidateExperienceLocationResponse, error)

	// ListViewSessionsWithResponse request
	ListViewSessionsWithResponse(ctx context.Context, params *ListViewSessionsParams, reqEditors ...RequestEditorFn) (*ListViewSessionsResponse, error)

	// CreateViewSessionWithResponse request
	CreateViewSessionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CreateViewSessionResponse, error)

	// GetViewSessionWithResponse request
	GetViewSessionWithResponse(ctx context.Context, viewSessionID ViewSessionID, reqEditors ...RequestEditorFn) (*GetViewSessionResponse, error)

	// CreateViewUpdateWithBodyWithResponse request with any body
	CreateViewUpdateWithBodyWithResponse(ctx context.Context, viewSessionID ViewSessionID, viewUpdateID ViewUpdateID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateViewUpdateResponse, error)
}

type HealthResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r HealthResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HealthResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListProjectsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListProjectsOutput
}

// Status returns HTTPResponse.Status
func (r ListProjectsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListProjectsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Project
}

// Status returns HTTPResponse.Status
func (r CreateProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArchiveProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ArchiveProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArchiveProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Project
}

// Status returns HTTPResponse.Status
func (r GetProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Project
}

// Status returns HTTPResponse.Status
func (r UpdateProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBatchesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListBatchesOutput
}

// Status returns HTTPResponse.Status
func (r ListBatchesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBatchesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBatchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Batch
}

// Status returns HTTPResponse.Status
func (r CreateBatchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBatchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAllJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListAllJobsOutput
}

// Status returns HTTPResponse.Status
func (r ListAllJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAllJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBatchAccountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListUsersOutput
}

// Status returns HTTPResponse.Status
func (r ListBatchAccountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBatchAccountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBatchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Batch
}

// Status returns HTTPResponse.Status
func (r GetBatchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBatchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateBatchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Batch
}

// Status returns HTTPResponse.Status
func (r UpdateBatchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateBatchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CancelBatchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CancelBatchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CancelBatchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CompareBatchesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CompareBatchesOutput
}

// Status returns HTTPResponse.Status
func (r CompareBatchesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CompareBatchesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBatchErrorsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListBatchErrorsOutput
}

// Status returns HTTPResponse.Status
func (r ListBatchErrorsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBatchErrorsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListJobsOutput
}

// Status returns HTTPResponse.Status
func (r ListJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Job
}

// Status returns HTTPResponse.Status
func (r GetJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Job
}

// Status returns HTTPResponse.Status
func (r UpdateJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListEventTagsForJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListJobEventTagsOutput
}

// Status returns HTTPResponse.Status
func (r ListEventTagsForJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListEventTagsForJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListEventsForJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListJobEventsOutput
}

// Status returns HTTPResponse.Status
func (r ListEventsForJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListEventsForJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEventForJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Event
}

// Status returns HTTPResponse.Status
func (r GetEventForJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEventForJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateEventResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Event
}

// Status returns HTTPResponse.Status
func (r UpdateEventResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateEventResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListJobLogsForJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListJobLogsOutput
}

// Status returns HTTPResponse.Status
func (r ListJobLogsForJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListJobLogsForJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteJobLogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteJobLogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteJobLogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetJobLogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *JobLog
}

// Status returns HTTPResponse.Status
func (r GetJobLogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetJobLogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListMetricsForJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListJobMetricsOutput
}

// Status returns HTTPResponse.Status
func (r ListMetricsForJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListMetricsForJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListMetricsForMetricIDsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListJobMetricsOutput
}

// Status returns HTTPResponse.Status
func (r ListMetricsForMetricIDsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListMetricsForMetricIDsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListMetricsDataForMetricIDsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListMetricsDataAndMetricIDOutput
}

// Status returns HTTPResponse.Status
func (r ListMetricsDataForMetricIDsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListMetricsDataForMetricIDsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListTagsForJobMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListTagsForJobMetricsOutput
}

// Status returns HTTPResponse.Status
func (r ListTagsForJobMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTagsForJobMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListMetricsDataForJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListJobMetricsDataOutput
}

// Status returns HTTPResponse.Status
func (r ListMetricsDataForJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListMetricsDataForJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListMetricsDataForMetricsDataIDsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListJobMetricsDataOutput
}

// Status returns HTTPResponse.Status
func (r ListMetricsDataForMetricsDataIDsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListMetricsDataForMetricsDataIDsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBatchLogsForBatchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListBatchLogsOutput
}

// Status returns HTTPResponse.Status
func (r ListBatchLogsForBatchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBatchLogsForBatchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteBatchLogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteBatchLogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteBatchLogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBatchLogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BatchLog
}

// Status returns HTTPResponse.Status
func (r GetBatchLogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBatchLogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBatchMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListBatchMetricsOutput
}

// Status returns HTTPResponse.Status
func (r ListBatchMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBatchMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBatchMetricsForBatchMetricIDsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListBatchMetricsOutput
}

// Status returns HTTPResponse.Status
func (r ListBatchMetricsForBatchMetricIDsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBatchMetricsForBatchMetricIDsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBatchMetricsDataForBatchMetricIDsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListBatchMetricsDataForBatchMetricIDsOutput
}

// Status returns HTTPResponse.Status
func (r ListBatchMetricsDataForBatchMetricIDsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBatchMetricsDataForBatchMetricIDsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListTagsForBatchMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListTagsForBatchMetricsOutput
}

// Status returns HTTPResponse.Status
func (r ListTagsForBatchMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTagsForBatchMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBatchMetricsDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListBatchMetricsDataOutput
}

// Status returns HTTPResponse.Status
func (r ListBatchMetricsDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBatchMetricsDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBatchMetricsDataForBatchMetricsDataIDsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListBatchMetricsDataOutput
}

// Status returns HTTPResponse.Status
func (r ListBatchMetricsDataForBatchMetricsDataIDsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBatchMetricsDataForBatchMetricsDataIDsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RerunBatchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RerunBatchOutput
}

// Status returns HTTPResponse.Status
func (r RerunBatchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RerunBatchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBatchSuggestionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BatchSuggestionsOutput
}

// Status returns HTTPResponse.Status
func (r GetBatchSuggestionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBatchSuggestionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBranchesForProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListBranchesOutput
}

// Status returns HTTPResponse.Status
func (r ListBranchesForProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBranchesForProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBranchForProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Branch
}

// Status returns HTTPResponse.Status
func (r CreateBranchForProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBranchForProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteBranchForProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteBranchForProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteBranchForProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBranchForProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Branch
}

// Status returns HTTPResponse.Status
func (r GetBranchForProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBranchForProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBuildsForBranchesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListBuildsOutput
}

// Status returns HTTPResponse.Status
func (r ListBuildsForBranchesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBuildsForBranchesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBuildForBranchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Build
}

// Status returns HTTPResponse.Status
func (r CreateBuildForBranchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBuildForBranchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteBuildForBranchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteBuildForBranchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteBuildForBranchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBuildForBranchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Build
}

// Status returns HTTPResponse.Status
func (r GetBuildForBranchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBuildForBranchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBatchesForBuildsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListBatchesOutput
}

// Status returns HTTPResponse.Status
func (r ListBatchesForBuildsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBatchesForBuildsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBuildsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListBuildsOutput
}

// Status returns HTTPResponse.Status
func (r ListBuildsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBuildsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBuildAccountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListUsersOutput
}

// Status returns HTTPResponse.Status
func (r ListBuildAccountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBuildAccountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBuildResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Build
}

// Status returns HTTPResponse.Status
func (r GetBuildResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBuildResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateBuildResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Build
}

// Status returns HTTPResponse.Status
func (r UpdateBuildResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateBuildResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListExperienceTagsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListExperienceTagsOutput
}

// Status returns HTTPResponse.Status
func (r ListExperienceTagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListExperienceTagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateExperienceTagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ExperienceTag
}

// Status returns HTTPResponse.Status
func (r CreateExperienceTagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateExperienceTagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddTagsToExperiencesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AddTagsToExperiencesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddTagsToExperiencesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteExperienceTagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteExperienceTagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteExperienceTagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetExperienceTagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ExperienceTag
}

// Status returns HTTPResponse.Status
func (r GetExperienceTagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetExperienceTagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateExperienceTagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ExperienceTag
}

// Status returns HTTPResponse.Status
func (r UpdateExperienceTagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateExperienceTagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListExperiencesWithExperienceTagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListExperiencesOutput
}

// Status returns HTTPResponse.Status
func (r ListExperiencesWithExperienceTagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListExperiencesWithExperienceTagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveExperienceTagFromExperienceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveExperienceTagFromExperienceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveExperienceTagFromExperienceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddExperienceTagToExperienceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AddExperienceTagToExperienceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddExperienceTagToExperienceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListExperiencesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListExperiencesOutput
}

// Status returns HTTPResponse.Status
func (r ListExperiencesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListExperiencesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateExperienceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Experience
}

// Status returns HTTPResponse.Status
func (r CreateExperienceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateExperienceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArchiveExperienceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ArchiveExperienceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArchiveExperienceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetExperienceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Experience
}

// Status returns HTTPResponse.Status
func (r GetExperienceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetExperienceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateExperienceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Experience
}

// Status returns HTTPResponse.Status
func (r UpdateExperienceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateExperienceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DebugExperienceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *DebugExperienceOutput
}

// Status returns HTTPResponse.Status
func (r DebugExperienceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DebugExperienceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListExperienceTagsForExperienceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListExperienceTagsOutput
}

// Status returns HTTPResponse.Status
func (r ListExperienceTagsForExperienceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListExperienceTagsForExperienceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreExperienceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RestoreExperienceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreExperienceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemsForExperienceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListSystemsOutput
}

// Status returns HTTPResponse.Status
func (r GetSystemsForExperienceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemsForExperienceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListMetricsBuildsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListMetricsBuildOutput
}

// Status returns HTTPResponse.Status
func (r ListMetricsBuildsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListMetricsBuildsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateMetricsBuildResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *MetricsBuild
}

// Status returns HTTPResponse.Status
func (r CreateMetricsBuildResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateMetricsBuildResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMetricsBuildResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MetricsBuild
}

// Status returns HTTPResponse.Status
func (r GetMetricsBuildResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMetricsBuildResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemsForMetricsBuildResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListSystemsOutput
}

// Status returns HTTPResponse.Status
func (r GetSystemsForMetricsBuildResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemsForMetricsBuildResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListServiceProfilesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r ListServiceProfilesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListServiceProfilesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListReportsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListReportsOutput
}

// Status returns HTTPResponse.Status
func (r ListReportsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListReportsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateReportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Report
}

// Status returns HTTPResponse.Status
func (r CreateReportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateReportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListReportAccountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListUsersOutput
}

// Status returns HTTPResponse.Status
func (r ListReportAccountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListReportAccountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Report
}

// Status returns HTTPResponse.Status
func (r GetReportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListLogsForReportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListReportLogsOutput
}

// Status returns HTTPResponse.Status
func (r ListLogsForReportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListLogsForReportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReportLogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ReportLog
}

// Status returns HTTPResponse.Status
func (r GetReportLogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReportLogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListReportMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListReportMetricsOutput
}

// Status returns HTTPResponse.Status
func (r ListReportMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListReportMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListReportMetricsForReportMetricIDsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListReportMetricsOutput
}

// Status returns HTTPResponse.Status
func (r ListReportMetricsForReportMetricIDsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListReportMetricsForReportMetricIDsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListReportMetricsDataForReportMetricIDsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListReportMetricsDataForReportMetricIDsOutput
}

// Status returns HTTPResponse.Status
func (r ListReportMetricsDataForReportMetricIDsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListReportMetricsDataForReportMetricIDsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListTagsForReportMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListTagsForReportMetricsOutput
}

// Status returns HTTPResponse.Status
func (r ListTagsForReportMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTagsForReportMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListReportMetricsDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListReportMetricsDataOutput
}

// Status returns HTTPResponse.Status
func (r ListReportMetricsDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListReportMetricsDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListReportMetricsDataForReportMetricsDataIDsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListReportMetricsDataOutput
}

// Status returns HTTPResponse.Status
func (r ListReportMetricsDataForReportMetricsDataIDsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListReportMetricsDataForReportMetricsDataIDsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListTestSuitesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListTestSuiteOutput
}

// Status returns HTTPResponse.Status
func (r ListTestSuitesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTestSuitesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTestSuiteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *TestSuite
}

// Status returns HTTPResponse.Status
func (r CreateTestSuiteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTestSuiteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddTestSuitesToExperiencesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AddTestSuitesToExperiencesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddTestSuitesToExperiencesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTestSuiteSummaryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TestSuiteSummaryOutput
}

// Status returns HTTPResponse.Status
func (r GetTestSuiteSummaryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTestSuiteSummaryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArchiveTestSuiteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ArchiveTestSuiteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArchiveTestSuiteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTestSuiteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TestSuite
}

// Status returns HTTPResponse.Status
func (r GetTestSuiteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTestSuiteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReviseTestSuiteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TestSuite
}

// Status returns HTTPResponse.Status
func (r ReviseTestSuiteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReviseTestSuiteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddExperiencesToTestSuiteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TestSuite
}

// Status returns HTTPResponse.Status
func (r AddExperiencesToTestSuiteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddExperiencesToTestSuiteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBatchesForTestSuiteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListBatchesOutput
}

// Status returns HTTPResponse.Status
func (r ListBatchesForTestSuiteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBatchesForTestSuiteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBatchForTestSuiteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Batch
}

// Status returns HTTPResponse.Status
func (r CreateBatchForTestSuiteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBatchForTestSuiteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveExperiencesFromTestSuiteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TestSuite
}

// Status returns HTTPResponse.Status
func (r RemoveExperiencesFromTestSuiteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveExperiencesFromTestSuiteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreTestSuiteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RestoreTestSuiteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreTestSuiteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListTestSuiteRevisionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListTestSuiteRevisionsOutput
}

// Status returns HTTPResponse.Status
func (r ListTestSuiteRevisionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTestSuiteRevisionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTestSuiteRevisionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TestSuite
}

// Status returns HTTPResponse.Status
func (r GetTestSuiteRevisionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTestSuiteRevisionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBatchesForTestSuiteRevisionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListBatchesOutput
}

// Status returns HTTPResponse.Status
func (r ListBatchesForTestSuiteRevisionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBatchesForTestSuiteRevisionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBatchForTestSuiteRevisionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Batch
}

// Status returns HTTPResponse.Status
func (r CreateBatchForTestSuiteRevisionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBatchForTestSuiteRevisionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListParameterSweepsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListParameterSweepsOutput
}

// Status returns HTTPResponse.Status
func (r ListParameterSweepsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListParameterSweepsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateParameterSweepResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ParameterSweep
}

// Status returns HTTPResponse.Status
func (r CreateParameterSweepResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateParameterSweepResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSweepAccountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListUsersOutput
}

// Status returns HTTPResponse.Status
func (r ListSweepAccountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSweepAccountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetParameterSweepResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ParameterSweep
}

// Status returns HTTPResponse.Status
func (r GetParameterSweepResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetParameterSweepResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CancelParameterSweepResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CancelParameterSweepResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CancelParameterSweepResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSystemsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListSystemsOutput
}

// Status returns HTTPResponse.Status
func (r ListSystemsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSystemsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSystemResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *System
}

// Status returns HTTPResponse.Status
func (r CreateSystemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSystemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddSystemsToExperiencesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AddSystemsToExperiencesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddSystemsToExperiencesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveSystemsFromExperiencesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveSystemsFromExperiencesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveSystemsFromExperiencesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArchiveSystemResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ArchiveSystemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArchiveSystemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *System
}

// Status returns HTTPResponse.Status
func (r GetSystemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSystemResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *System
}

// Status returns HTTPResponse.Status
func (r UpdateSystemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSystemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBuildsForSystemResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListBuildsOutput
}

// Status returns HTTPResponse.Status
func (r ListBuildsForSystemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBuildsForSystemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBuildForSystemResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Build
}

// Status returns HTTPResponse.Status
func (r CreateBuildForSystemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBuildForSystemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBuildForSystemResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Build
}

// Status returns HTTPResponse.Status
func (r GetBuildForSystemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBuildForSystemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListExperiencesForSystemResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListExperiencesOutput
}

// Status returns HTTPResponse.Status
func (r ListExperiencesForSystemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListExperiencesForSystemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveSystemFromExperienceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveSystemFromExperienceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveSystemFromExperienceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddSystemToExperienceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AddSystemToExperienceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddSystemToExperienceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveSystemFromMetricsBuildResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveSystemFromMetricsBuildResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveSystemFromMetricsBuildResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddSystemToMetricsBuildResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AddSystemToMetricsBuildResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddSystemToMetricsBuildResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetQuotaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetQuotaOutput
}

// Status returns HTTPResponse.Status
func (r GetQuotaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetQuotaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ValidateExperienceLocationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ExperienceLocationContents
}

// Status returns HTTPResponse.Status
func (r ValidateExperienceLocationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ValidateExperienceLocationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListViewSessionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListViewObjectsOutput
}

// Status returns HTTPResponse.Status
func (r ListViewSessionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListViewSessionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateViewSessionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ViewSessionID
}

// Status returns HTTPResponse.Status
func (r CreateViewSessionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateViewSessionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetViewSessionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ViewObjectAndMetadata
}

// Status returns HTTPResponse.Status
func (r GetViewSessionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetViewSessionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateViewUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ViewSessionUpdate
}

// Status returns HTTPResponse.Status
func (r CreateViewUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateViewUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// HealthWithResponse request returning *HealthResponse
func (c *ClientWithResponses) HealthWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*HealthResponse, error) {
	rsp, err := c.Health(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHealthResponse(rsp)
}

// ListProjectsWithResponse request returning *ListProjectsResponse
func (c *ClientWithResponses) ListProjectsWithResponse(ctx context.Context, params *ListProjectsParams, reqEditors ...RequestEditorFn) (*ListProjectsResponse, error) {
	rsp, err := c.ListProjects(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListProjectsResponse(rsp)
}

// CreateProjectWithBodyWithResponse request with arbitrary body returning *CreateProjectResponse
func (c *ClientWithResponses) CreateProjectWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProjectResponse, error) {
	rsp, err := c.CreateProjectWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProjectResponse(rsp)
}

func (c *ClientWithResponses) CreateProjectWithResponse(ctx context.Context, body CreateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProjectResponse, error) {
	rsp, err := c.CreateProject(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProjectResponse(rsp)
}

// ArchiveProjectWithResponse request returning *ArchiveProjectResponse
func (c *ClientWithResponses) ArchiveProjectWithResponse(ctx context.Context, projectID ProjectID, reqEditors ...RequestEditorFn) (*ArchiveProjectResponse, error) {
	rsp, err := c.ArchiveProject(ctx, projectID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveProjectResponse(rsp)
}

// GetProjectWithResponse request returning *GetProjectResponse
func (c *ClientWithResponses) GetProjectWithResponse(ctx context.Context, projectID ProjectID, reqEditors ...RequestEditorFn) (*GetProjectResponse, error) {
	rsp, err := c.GetProject(ctx, projectID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProjectResponse(rsp)
}

// UpdateProjectWithBodyWithResponse request with arbitrary body returning *UpdateProjectResponse
func (c *ClientWithResponses) UpdateProjectWithBodyWithResponse(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProjectResponse, error) {
	rsp, err := c.UpdateProjectWithBody(ctx, projectID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProjectResponse(rsp)
}

func (c *ClientWithResponses) UpdateProjectWithResponse(ctx context.Context, projectID ProjectID, body UpdateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProjectResponse, error) {
	rsp, err := c.UpdateProject(ctx, projectID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProjectResponse(rsp)
}

// ListBatchesWithResponse request returning *ListBatchesResponse
func (c *ClientWithResponses) ListBatchesWithResponse(ctx context.Context, projectID ProjectID, params *ListBatchesParams, reqEditors ...RequestEditorFn) (*ListBatchesResponse, error) {
	rsp, err := c.ListBatches(ctx, projectID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBatchesResponse(rsp)
}

// CreateBatchWithBodyWithResponse request with arbitrary body returning *CreateBatchResponse
func (c *ClientWithResponses) CreateBatchWithBodyWithResponse(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBatchResponse, error) {
	rsp, err := c.CreateBatchWithBody(ctx, projectID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBatchResponse(rsp)
}

func (c *ClientWithResponses) CreateBatchWithResponse(ctx context.Context, projectID ProjectID, body CreateBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBatchResponse, error) {
	rsp, err := c.CreateBatch(ctx, projectID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBatchResponse(rsp)
}

// ListAllJobsWithResponse request returning *ListAllJobsResponse
func (c *ClientWithResponses) ListAllJobsWithResponse(ctx context.Context, projectID ProjectID, params *ListAllJobsParams, reqEditors ...RequestEditorFn) (*ListAllJobsResponse, error) {
	rsp, err := c.ListAllJobs(ctx, projectID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAllJobsResponse(rsp)
}

// ListBatchAccountsWithResponse request returning *ListBatchAccountsResponse
func (c *ClientWithResponses) ListBatchAccountsWithResponse(ctx context.Context, projectID ProjectID, params *ListBatchAccountsParams, reqEditors ...RequestEditorFn) (*ListBatchAccountsResponse, error) {
	rsp, err := c.ListBatchAccounts(ctx, projectID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBatchAccountsResponse(rsp)
}

// GetBatchWithResponse request returning *GetBatchResponse
func (c *ClientWithResponses) GetBatchWithResponse(ctx context.Context, projectID ProjectID, batchID BatchID, reqEditors ...RequestEditorFn) (*GetBatchResponse, error) {
	rsp, err := c.GetBatch(ctx, projectID, batchID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBatchResponse(rsp)
}

// UpdateBatchWithBodyWithResponse request with arbitrary body returning *UpdateBatchResponse
func (c *ClientWithResponses) UpdateBatchWithBodyWithResponse(ctx context.Context, projectID ProjectID, batchID BatchID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateBatchResponse, error) {
	rsp, err := c.UpdateBatchWithBody(ctx, projectID, batchID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateBatchResponse(rsp)
}

func (c *ClientWithResponses) UpdateBatchWithResponse(ctx context.Context, projectID ProjectID, batchID BatchID, body UpdateBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateBatchResponse, error) {
	rsp, err := c.UpdateBatch(ctx, projectID, batchID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateBatchResponse(rsp)
}

// CancelBatchWithResponse request returning *CancelBatchResponse
func (c *ClientWithResponses) CancelBatchWithResponse(ctx context.Context, projectID ProjectID, batchID BatchID, reqEditors ...RequestEditorFn) (*CancelBatchResponse, error) {
	rsp, err := c.CancelBatch(ctx, projectID, batchID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelBatchResponse(rsp)
}

// CompareBatchesWithResponse request returning *CompareBatchesResponse
func (c *ClientWithResponses) CompareBatchesWithResponse(ctx context.Context, projectID ProjectID, batchID BatchID, otherBatchID BatchID, params *CompareBatchesParams, reqEditors ...RequestEditorFn) (*CompareBatchesResponse, error) {
	rsp, err := c.CompareBatches(ctx, projectID, batchID, otherBatchID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCompareBatchesResponse(rsp)
}

// ListBatchErrorsWithResponse request returning *ListBatchErrorsResponse
func (c *ClientWithResponses) ListBatchErrorsWithResponse(ctx context.Context, projectID ProjectID, batchID BatchID, reqEditors ...RequestEditorFn) (*ListBatchErrorsResponse, error) {
	rsp, err := c.ListBatchErrors(ctx, projectID, batchID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBatchErrorsResponse(rsp)
}

// ListJobsWithResponse request returning *ListJobsResponse
func (c *ClientWithResponses) ListJobsWithResponse(ctx context.Context, projectID ProjectID, batchID BatchID, params *ListJobsParams, reqEditors ...RequestEditorFn) (*ListJobsResponse, error) {
	rsp, err := c.ListJobs(ctx, projectID, batchID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListJobsResponse(rsp)
}

// GetJobWithResponse request returning *GetJobResponse
func (c *ClientWithResponses) GetJobWithResponse(ctx context.Context, projectID ProjectID, batchID BatchID, jobID JobID, reqEditors ...RequestEditorFn) (*GetJobResponse, error) {
	rsp, err := c.GetJob(ctx, projectID, batchID, jobID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetJobResponse(rsp)
}

// UpdateJobWithBodyWithResponse request with arbitrary body returning *UpdateJobResponse
func (c *ClientWithResponses) UpdateJobWithBodyWithResponse(ctx context.Context, projectID ProjectID, batchID BatchID, jobID JobID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateJobResponse, error) {
	rsp, err := c.UpdateJobWithBody(ctx, projectID, batchID, jobID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateJobResponse(rsp)
}

func (c *ClientWithResponses) UpdateJobWithResponse(ctx context.Context, projectID ProjectID, batchID BatchID, jobID JobID, body UpdateJobJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateJobResponse, error) {
	rsp, err := c.UpdateJob(ctx, projectID, batchID, jobID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateJobResponse(rsp)
}

// ListEventTagsForJobWithResponse request returning *ListEventTagsForJobResponse
func (c *ClientWithResponses) ListEventTagsForJobWithResponse(ctx context.Context, projectID ProjectID, batchID BatchID, jobID JobID, params *ListEventTagsForJobParams, reqEditors ...RequestEditorFn) (*ListEventTagsForJobResponse, error) {
	rsp, err := c.ListEventTagsForJob(ctx, projectID, batchID, jobID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListEventTagsForJobResponse(rsp)
}

// ListEventsForJobWithResponse request returning *ListEventsForJobResponse
func (c *ClientWithResponses) ListEventsForJobWithResponse(ctx context.Context, projectID ProjectID, batchID BatchID, jobID JobID, params *ListEventsForJobParams, reqEditors ...RequestEditorFn) (*ListEventsForJobResponse, error) {
	rsp, err := c.ListEventsForJob(ctx, projectID, batchID, jobID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListEventsForJobResponse(rsp)
}

// GetEventForJobWithResponse request returning *GetEventForJobResponse
func (c *ClientWithResponses) GetEventForJobWithResponse(ctx context.Context, projectID ProjectID, batchID BatchID, jobID JobID, eventID EventID, reqEditors ...RequestEditorFn) (*GetEventForJobResponse, error) {
	rsp, err := c.GetEventForJob(ctx, projectID, batchID, jobID, eventID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEventForJobResponse(rsp)
}

// UpdateEventWithBodyWithResponse request with arbitrary body returning *UpdateEventResponse
func (c *ClientWithResponses) UpdateEventWithBodyWithResponse(ctx context.Context, projectID ProjectID, batchID BatchID, jobID JobID, eventID EventID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateEventResponse, error) {
	rsp, err := c.UpdateEventWithBody(ctx, projectID, batchID, jobID, eventID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateEventResponse(rsp)
}

func (c *ClientWithResponses) UpdateEventWithResponse(ctx context.Context, projectID ProjectID, batchID BatchID, jobID JobID, eventID EventID, body UpdateEventJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateEventResponse, error) {
	rsp, err := c.UpdateEvent(ctx, projectID, batchID, jobID, eventID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateEventResponse(rsp)
}

// ListJobLogsForJobWithResponse request returning *ListJobLogsForJobResponse
func (c *ClientWithResponses) ListJobLogsForJobWithResponse(ctx context.Context, projectID ProjectID, batchID BatchID, jobID JobID, params *ListJobLogsForJobParams, reqEditors ...RequestEditorFn) (*ListJobLogsForJobResponse, error) {
	rsp, err := c.ListJobLogsForJob(ctx, projectID, batchID, jobID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListJobLogsForJobResponse(rsp)
}

// DeleteJobLogWithResponse request returning *DeleteJobLogResponse
func (c *ClientWithResponses) DeleteJobLogWithResponse(ctx context.Context, projectID ProjectID, batchID BatchID, jobID JobID, logID LogID, reqEditors ...RequestEditorFn) (*DeleteJobLogResponse, error) {
	rsp, err := c.DeleteJobLog(ctx, projectID, batchID, jobID, logID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteJobLogResponse(rsp)
}

// GetJobLogWithResponse request returning *GetJobLogResponse
func (c *ClientWithResponses) GetJobLogWithResponse(ctx context.Context, projectID ProjectID, batchID BatchID, jobID JobID, logID LogID, reqEditors ...RequestEditorFn) (*GetJobLogResponse, error) {
	rsp, err := c.GetJobLog(ctx, projectID, batchID, jobID, logID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetJobLogResponse(rsp)
}

// ListMetricsForJobWithResponse request returning *ListMetricsForJobResponse
func (c *ClientWithResponses) ListMetricsForJobWithResponse(ctx context.Context, projectID ProjectID, batchID BatchID, jobID JobID, params *ListMetricsForJobParams, reqEditors ...RequestEditorFn) (*ListMetricsForJobResponse, error) {
	rsp, err := c.ListMetricsForJob(ctx, projectID, batchID, jobID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListMetricsForJobResponse(rsp)
}

// ListMetricsForMetricIDsWithResponse request returning *ListMetricsForMetricIDsResponse
func (c *ClientWithResponses) ListMetricsForMetricIDsWithResponse(ctx context.Context, projectID ProjectID, batchID BatchID, jobID JobID, metricID []MetricID, params *ListMetricsForMetricIDsParams, reqEditors ...RequestEditorFn) (*ListMetricsForMetricIDsResponse, error) {
	rsp, err := c.ListMetricsForMetricIDs(ctx, projectID, batchID, jobID, metricID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListMetricsForMetricIDsResponse(rsp)
}

// ListMetricsDataForMetricIDsWithResponse request returning *ListMetricsDataForMetricIDsResponse
func (c *ClientWithResponses) ListMetricsDataForMetricIDsWithResponse(ctx context.Context, projectID ProjectID, batchID BatchID, jobID JobID, metricID []MetricID, params *ListMetricsDataForMetricIDsParams, reqEditors ...RequestEditorFn) (*ListMetricsDataForMetricIDsResponse, error) {
	rsp, err := c.ListMetricsDataForMetricIDs(ctx, projectID, batchID, jobID, metricID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListMetricsDataForMetricIDsResponse(rsp)
}

// ListTagsForJobMetricsWithResponse request returning *ListTagsForJobMetricsResponse
func (c *ClientWithResponses) ListTagsForJobMetricsWithResponse(ctx context.Context, projectID ProjectID, batchID BatchID, jobID JobID, metricID []MetricID, params *ListTagsForJobMetricsParams, reqEditors ...RequestEditorFn) (*ListTagsForJobMetricsResponse, error) {
	rsp, err := c.ListTagsForJobMetrics(ctx, projectID, batchID, jobID, metricID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListTagsForJobMetricsResponse(rsp)
}

// ListMetricsDataForJobWithResponse request returning *ListMetricsDataForJobResponse
func (c *ClientWithResponses) ListMetricsDataForJobWithResponse(ctx context.Context, projectID ProjectID, batchID BatchID, jobID JobID, params *ListMetricsDataForJobParams, reqEditors ...RequestEditorFn) (*ListMetricsDataForJobResponse, error) {
	rsp, err := c.ListMetricsDataForJob(ctx, projectID, batchID, jobID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListMetricsDataForJobResponse(rsp)
}

// ListMetricsDataForMetricsDataIDsWithResponse request returning *ListMetricsDataForMetricsDataIDsResponse
func (c *ClientWithResponses) ListMetricsDataForMetricsDataIDsWithResponse(ctx context.Context, projectID ProjectID, batchID BatchID, jobID JobID, metricsDataID []MetricsDataID, params *ListMetricsDataForMetricsDataIDsParams, reqEditors ...RequestEditorFn) (*ListMetricsDataForMetricsDataIDsResponse, error) {
	rsp, err := c.ListMetricsDataForMetricsDataIDs(ctx, projectID, batchID, jobID, metricsDataID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListMetricsDataForMetricsDataIDsResponse(rsp)
}

// ListBatchLogsForBatchWithResponse request returning *ListBatchLogsForBatchResponse
func (c *ClientWithResponses) ListBatchLogsForBatchWithResponse(ctx context.Context, projectID ProjectID, batchID BatchID, params *ListBatchLogsForBatchParams, reqEditors ...RequestEditorFn) (*ListBatchLogsForBatchResponse, error) {
	rsp, err := c.ListBatchLogsForBatch(ctx, projectID, batchID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBatchLogsForBatchResponse(rsp)
}

// DeleteBatchLogWithResponse request returning *DeleteBatchLogResponse
func (c *ClientWithResponses) DeleteBatchLogWithResponse(ctx context.Context, projectID ProjectID, batchID BatchID, logID LogID, reqEditors ...RequestEditorFn) (*DeleteBatchLogResponse, error) {
	rsp, err := c.DeleteBatchLog(ctx, projectID, batchID, logID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteBatchLogResponse(rsp)
}

// GetBatchLogWithResponse request returning *GetBatchLogResponse
func (c *ClientWithResponses) GetBatchLogWithResponse(ctx context.Context, projectID ProjectID, batchID BatchID, logID LogID, reqEditors ...RequestEditorFn) (*GetBatchLogResponse, error) {
	rsp, err := c.GetBatchLog(ctx, projectID, batchID, logID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBatchLogResponse(rsp)
}

// ListBatchMetricsWithResponse request returning *ListBatchMetricsResponse
func (c *ClientWithResponses) ListBatchMetricsWithResponse(ctx context.Context, projectID ProjectID, batchID BatchID, params *ListBatchMetricsParams, reqEditors ...RequestEditorFn) (*ListBatchMetricsResponse, error) {
	rsp, err := c.ListBatchMetrics(ctx, projectID, batchID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBatchMetricsResponse(rsp)
}

// ListBatchMetricsForBatchMetricIDsWithResponse request returning *ListBatchMetricsForBatchMetricIDsResponse
func (c *ClientWithResponses) ListBatchMetricsForBatchMetricIDsWithResponse(ctx context.Context, projectID ProjectID, batchID BatchID, metricID []MetricID, params *ListBatchMetricsForBatchMetricIDsParams, reqEditors ...RequestEditorFn) (*ListBatchMetricsForBatchMetricIDsResponse, error) {
	rsp, err := c.ListBatchMetricsForBatchMetricIDs(ctx, projectID, batchID, metricID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBatchMetricsForBatchMetricIDsResponse(rsp)
}

// ListBatchMetricsDataForBatchMetricIDsWithResponse request returning *ListBatchMetricsDataForBatchMetricIDsResponse
func (c *ClientWithResponses) ListBatchMetricsDataForBatchMetricIDsWithResponse(ctx context.Context, projectID ProjectID, batchID BatchID, metricID []MetricID, params *ListBatchMetricsDataForBatchMetricIDsParams, reqEditors ...RequestEditorFn) (*ListBatchMetricsDataForBatchMetricIDsResponse, error) {
	rsp, err := c.ListBatchMetricsDataForBatchMetricIDs(ctx, projectID, batchID, metricID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBatchMetricsDataForBatchMetricIDsResponse(rsp)
}

// ListTagsForBatchMetricsWithResponse request returning *ListTagsForBatchMetricsResponse
func (c *ClientWithResponses) ListTagsForBatchMetricsWithResponse(ctx context.Context, projectID ProjectID, batchID BatchID, metricID []MetricID, params *ListTagsForBatchMetricsParams, reqEditors ...RequestEditorFn) (*ListTagsForBatchMetricsResponse, error) {
	rsp, err := c.ListTagsForBatchMetrics(ctx, projectID, batchID, metricID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListTagsForBatchMetricsResponse(rsp)
}

// ListBatchMetricsDataWithResponse request returning *ListBatchMetricsDataResponse
func (c *ClientWithResponses) ListBatchMetricsDataWithResponse(ctx context.Context, projectID ProjectID, batchID BatchID, params *ListBatchMetricsDataParams, reqEditors ...RequestEditorFn) (*ListBatchMetricsDataResponse, error) {
	rsp, err := c.ListBatchMetricsData(ctx, projectID, batchID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBatchMetricsDataResponse(rsp)
}

// ListBatchMetricsDataForBatchMetricsDataIDsWithResponse request returning *ListBatchMetricsDataForBatchMetricsDataIDsResponse
func (c *ClientWithResponses) ListBatchMetricsDataForBatchMetricsDataIDsWithResponse(ctx context.Context, projectID ProjectID, batchID BatchID, metricsDataID []MetricsDataID, params *ListBatchMetricsDataForBatchMetricsDataIDsParams, reqEditors ...RequestEditorFn) (*ListBatchMetricsDataForBatchMetricsDataIDsResponse, error) {
	rsp, err := c.ListBatchMetricsDataForBatchMetricsDataIDs(ctx, projectID, batchID, metricsDataID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBatchMetricsDataForBatchMetricsDataIDsResponse(rsp)
}

// RerunBatchWithBodyWithResponse request with arbitrary body returning *RerunBatchResponse
func (c *ClientWithResponses) RerunBatchWithBodyWithResponse(ctx context.Context, projectID ProjectID, batchID BatchID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RerunBatchResponse, error) {
	rsp, err := c.RerunBatchWithBody(ctx, projectID, batchID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRerunBatchResponse(rsp)
}

func (c *ClientWithResponses) RerunBatchWithResponse(ctx context.Context, projectID ProjectID, batchID BatchID, body RerunBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*RerunBatchResponse, error) {
	rsp, err := c.RerunBatch(ctx, projectID, batchID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRerunBatchResponse(rsp)
}

// GetBatchSuggestionsWithResponse request returning *GetBatchSuggestionsResponse
func (c *ClientWithResponses) GetBatchSuggestionsWithResponse(ctx context.Context, projectID ProjectID, batchID BatchID, reqEditors ...RequestEditorFn) (*GetBatchSuggestionsResponse, error) {
	rsp, err := c.GetBatchSuggestions(ctx, projectID, batchID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBatchSuggestionsResponse(rsp)
}

// ListBranchesForProjectWithResponse request returning *ListBranchesForProjectResponse
func (c *ClientWithResponses) ListBranchesForProjectWithResponse(ctx context.Context, projectID ProjectID, params *ListBranchesForProjectParams, reqEditors ...RequestEditorFn) (*ListBranchesForProjectResponse, error) {
	rsp, err := c.ListBranchesForProject(ctx, projectID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBranchesForProjectResponse(rsp)
}

// CreateBranchForProjectWithBodyWithResponse request with arbitrary body returning *CreateBranchForProjectResponse
func (c *ClientWithResponses) CreateBranchForProjectWithBodyWithResponse(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBranchForProjectResponse, error) {
	rsp, err := c.CreateBranchForProjectWithBody(ctx, projectID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBranchForProjectResponse(rsp)
}

func (c *ClientWithResponses) CreateBranchForProjectWithResponse(ctx context.Context, projectID ProjectID, body CreateBranchForProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBranchForProjectResponse, error) {
	rsp, err := c.CreateBranchForProject(ctx, projectID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBranchForProjectResponse(rsp)
}

// DeleteBranchForProjectWithResponse request returning *DeleteBranchForProjectResponse
func (c *ClientWithResponses) DeleteBranchForProjectWithResponse(ctx context.Context, projectID ProjectID, branchID BranchID, reqEditors ...RequestEditorFn) (*DeleteBranchForProjectResponse, error) {
	rsp, err := c.DeleteBranchForProject(ctx, projectID, branchID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteBranchForProjectResponse(rsp)
}

// GetBranchForProjectWithResponse request returning *GetBranchForProjectResponse
func (c *ClientWithResponses) GetBranchForProjectWithResponse(ctx context.Context, projectID ProjectID, branchID BranchID, reqEditors ...RequestEditorFn) (*GetBranchForProjectResponse, error) {
	rsp, err := c.GetBranchForProject(ctx, projectID, branchID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBranchForProjectResponse(rsp)
}

// ListBuildsForBranchesWithResponse request returning *ListBuildsForBranchesResponse
func (c *ClientWithResponses) ListBuildsForBranchesWithResponse(ctx context.Context, projectID ProjectID, branchID []BranchID, params *ListBuildsForBranchesParams, reqEditors ...RequestEditorFn) (*ListBuildsForBranchesResponse, error) {
	rsp, err := c.ListBuildsForBranches(ctx, projectID, branchID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBuildsForBranchesResponse(rsp)
}

// CreateBuildForBranchWithBodyWithResponse request with arbitrary body returning *CreateBuildForBranchResponse
func (c *ClientWithResponses) CreateBuildForBranchWithBodyWithResponse(ctx context.Context, projectID ProjectID, branchID BranchID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBuildForBranchResponse, error) {
	rsp, err := c.CreateBuildForBranchWithBody(ctx, projectID, branchID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBuildForBranchResponse(rsp)
}

func (c *ClientWithResponses) CreateBuildForBranchWithResponse(ctx context.Context, projectID ProjectID, branchID BranchID, body CreateBuildForBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBuildForBranchResponse, error) {
	rsp, err := c.CreateBuildForBranch(ctx, projectID, branchID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBuildForBranchResponse(rsp)
}

// DeleteBuildForBranchWithResponse request returning *DeleteBuildForBranchResponse
func (c *ClientWithResponses) DeleteBuildForBranchWithResponse(ctx context.Context, projectID ProjectID, branchID BranchID, buildID BuildID, reqEditors ...RequestEditorFn) (*DeleteBuildForBranchResponse, error) {
	rsp, err := c.DeleteBuildForBranch(ctx, projectID, branchID, buildID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteBuildForBranchResponse(rsp)
}

// GetBuildForBranchWithResponse request returning *GetBuildForBranchResponse
func (c *ClientWithResponses) GetBuildForBranchWithResponse(ctx context.Context, projectID ProjectID, branchID BranchID, buildID BuildID, reqEditors ...RequestEditorFn) (*GetBuildForBranchResponse, error) {
	rsp, err := c.GetBuildForBranch(ctx, projectID, branchID, buildID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBuildForBranchResponse(rsp)
}

// ListBatchesForBuildsWithResponse request returning *ListBatchesForBuildsResponse
func (c *ClientWithResponses) ListBatchesForBuildsWithResponse(ctx context.Context, projectID ProjectID, branchID BranchID, buildID []BuildID, params *ListBatchesForBuildsParams, reqEditors ...RequestEditorFn) (*ListBatchesForBuildsResponse, error) {
	rsp, err := c.ListBatchesForBuilds(ctx, projectID, branchID, buildID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBatchesForBuildsResponse(rsp)
}

// ListBuildsWithResponse request returning *ListBuildsResponse
func (c *ClientWithResponses) ListBuildsWithResponse(ctx context.Context, projectID ProjectID, params *ListBuildsParams, reqEditors ...RequestEditorFn) (*ListBuildsResponse, error) {
	rsp, err := c.ListBuilds(ctx, projectID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBuildsResponse(rsp)
}

// ListBuildAccountsWithResponse request returning *ListBuildAccountsResponse
func (c *ClientWithResponses) ListBuildAccountsWithResponse(ctx context.Context, projectID ProjectID, reqEditors ...RequestEditorFn) (*ListBuildAccountsResponse, error) {
	rsp, err := c.ListBuildAccounts(ctx, projectID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBuildAccountsResponse(rsp)
}

// GetBuildWithResponse request returning *GetBuildResponse
func (c *ClientWithResponses) GetBuildWithResponse(ctx context.Context, projectID ProjectID, buildID BuildID, reqEditors ...RequestEditorFn) (*GetBuildResponse, error) {
	rsp, err := c.GetBuild(ctx, projectID, buildID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBuildResponse(rsp)
}

// UpdateBuildWithBodyWithResponse request with arbitrary body returning *UpdateBuildResponse
func (c *ClientWithResponses) UpdateBuildWithBodyWithResponse(ctx context.Context, projectID ProjectID, buildID BuildID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateBuildResponse, error) {
	rsp, err := c.UpdateBuildWithBody(ctx, projectID, buildID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateBuildResponse(rsp)
}

func (c *ClientWithResponses) UpdateBuildWithResponse(ctx context.Context, projectID ProjectID, buildID BuildID, body UpdateBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateBuildResponse, error) {
	rsp, err := c.UpdateBuild(ctx, projectID, buildID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateBuildResponse(rsp)
}

// ListExperienceTagsWithResponse request returning *ListExperienceTagsResponse
func (c *ClientWithResponses) ListExperienceTagsWithResponse(ctx context.Context, projectID ProjectID, params *ListExperienceTagsParams, reqEditors ...RequestEditorFn) (*ListExperienceTagsResponse, error) {
	rsp, err := c.ListExperienceTags(ctx, projectID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListExperienceTagsResponse(rsp)
}

// CreateExperienceTagWithBodyWithResponse request with arbitrary body returning *CreateExperienceTagResponse
func (c *ClientWithResponses) CreateExperienceTagWithBodyWithResponse(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateExperienceTagResponse, error) {
	rsp, err := c.CreateExperienceTagWithBody(ctx, projectID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateExperienceTagResponse(rsp)
}

func (c *ClientWithResponses) CreateExperienceTagWithResponse(ctx context.Context, projectID ProjectID, body CreateExperienceTagJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateExperienceTagResponse, error) {
	rsp, err := c.CreateExperienceTag(ctx, projectID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateExperienceTagResponse(rsp)
}

// AddTagsToExperiencesWithBodyWithResponse request with arbitrary body returning *AddTagsToExperiencesResponse
func (c *ClientWithResponses) AddTagsToExperiencesWithBodyWithResponse(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddTagsToExperiencesResponse, error) {
	rsp, err := c.AddTagsToExperiencesWithBody(ctx, projectID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddTagsToExperiencesResponse(rsp)
}

func (c *ClientWithResponses) AddTagsToExperiencesWithResponse(ctx context.Context, projectID ProjectID, body AddTagsToExperiencesJSONRequestBody, reqEditors ...RequestEditorFn) (*AddTagsToExperiencesResponse, error) {
	rsp, err := c.AddTagsToExperiences(ctx, projectID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddTagsToExperiencesResponse(rsp)
}

// DeleteExperienceTagWithResponse request returning *DeleteExperienceTagResponse
func (c *ClientWithResponses) DeleteExperienceTagWithResponse(ctx context.Context, projectID ProjectID, experienceTagID ExperienceTagID, reqEditors ...RequestEditorFn) (*DeleteExperienceTagResponse, error) {
	rsp, err := c.DeleteExperienceTag(ctx, projectID, experienceTagID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteExperienceTagResponse(rsp)
}

// GetExperienceTagWithResponse request returning *GetExperienceTagResponse
func (c *ClientWithResponses) GetExperienceTagWithResponse(ctx context.Context, projectID ProjectID, experienceTagID ExperienceTagID, reqEditors ...RequestEditorFn) (*GetExperienceTagResponse, error) {
	rsp, err := c.GetExperienceTag(ctx, projectID, experienceTagID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetExperienceTagResponse(rsp)
}

// UpdateExperienceTagWithBodyWithResponse request with arbitrary body returning *UpdateExperienceTagResponse
func (c *ClientWithResponses) UpdateExperienceTagWithBodyWithResponse(ctx context.Context, projectID ProjectID, experienceTagID ExperienceTagID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateExperienceTagResponse, error) {
	rsp, err := c.UpdateExperienceTagWithBody(ctx, projectID, experienceTagID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateExperienceTagResponse(rsp)
}

func (c *ClientWithResponses) UpdateExperienceTagWithResponse(ctx context.Context, projectID ProjectID, experienceTagID ExperienceTagID, body UpdateExperienceTagJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateExperienceTagResponse, error) {
	rsp, err := c.UpdateExperienceTag(ctx, projectID, experienceTagID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateExperienceTagResponse(rsp)
}

// ListExperiencesWithExperienceTagWithResponse request returning *ListExperiencesWithExperienceTagResponse
func (c *ClientWithResponses) ListExperiencesWithExperienceTagWithResponse(ctx context.Context, projectID ProjectID, experienceTagID ExperienceTagID, params *ListExperiencesWithExperienceTagParams, reqEditors ...RequestEditorFn) (*ListExperiencesWithExperienceTagResponse, error) {
	rsp, err := c.ListExperiencesWithExperienceTag(ctx, projectID, experienceTagID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListExperiencesWithExperienceTagResponse(rsp)
}

// RemoveExperienceTagFromExperienceWithResponse request returning *RemoveExperienceTagFromExperienceResponse
func (c *ClientWithResponses) RemoveExperienceTagFromExperienceWithResponse(ctx context.Context, projectID ProjectID, experienceTagID ExperienceTagID, experienceID ExperienceID, reqEditors ...RequestEditorFn) (*RemoveExperienceTagFromExperienceResponse, error) {
	rsp, err := c.RemoveExperienceTagFromExperience(ctx, projectID, experienceTagID, experienceID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveExperienceTagFromExperienceResponse(rsp)
}

// AddExperienceTagToExperienceWithResponse request returning *AddExperienceTagToExperienceResponse
func (c *ClientWithResponses) AddExperienceTagToExperienceWithResponse(ctx context.Context, projectID ProjectID, experienceTagID ExperienceTagID, experienceID ExperienceID, reqEditors ...RequestEditorFn) (*AddExperienceTagToExperienceResponse, error) {
	rsp, err := c.AddExperienceTagToExperience(ctx, projectID, experienceTagID, experienceID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddExperienceTagToExperienceResponse(rsp)
}

// ListExperiencesWithResponse request returning *ListExperiencesResponse
func (c *ClientWithResponses) ListExperiencesWithResponse(ctx context.Context, projectID ProjectID, params *ListExperiencesParams, reqEditors ...RequestEditorFn) (*ListExperiencesResponse, error) {
	rsp, err := c.ListExperiences(ctx, projectID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListExperiencesResponse(rsp)
}

// CreateExperienceWithBodyWithResponse request with arbitrary body returning *CreateExperienceResponse
func (c *ClientWithResponses) CreateExperienceWithBodyWithResponse(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateExperienceResponse, error) {
	rsp, err := c.CreateExperienceWithBody(ctx, projectID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateExperienceResponse(rsp)
}

func (c *ClientWithResponses) CreateExperienceWithResponse(ctx context.Context, projectID ProjectID, body CreateExperienceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateExperienceResponse, error) {
	rsp, err := c.CreateExperience(ctx, projectID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateExperienceResponse(rsp)
}

// ArchiveExperienceWithResponse request returning *ArchiveExperienceResponse
func (c *ClientWithResponses) ArchiveExperienceWithResponse(ctx context.Context, projectID ProjectID, experienceID ExperienceID, reqEditors ...RequestEditorFn) (*ArchiveExperienceResponse, error) {
	rsp, err := c.ArchiveExperience(ctx, projectID, experienceID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveExperienceResponse(rsp)
}

// GetExperienceWithResponse request returning *GetExperienceResponse
func (c *ClientWithResponses) GetExperienceWithResponse(ctx context.Context, projectID ProjectID, experienceID ExperienceID, reqEditors ...RequestEditorFn) (*GetExperienceResponse, error) {
	rsp, err := c.GetExperience(ctx, projectID, experienceID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetExperienceResponse(rsp)
}

// UpdateExperienceWithBodyWithResponse request with arbitrary body returning *UpdateExperienceResponse
func (c *ClientWithResponses) UpdateExperienceWithBodyWithResponse(ctx context.Context, projectID ProjectID, experienceID ExperienceID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateExperienceResponse, error) {
	rsp, err := c.UpdateExperienceWithBody(ctx, projectID, experienceID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateExperienceResponse(rsp)
}

func (c *ClientWithResponses) UpdateExperienceWithResponse(ctx context.Context, projectID ProjectID, experienceID ExperienceID, body UpdateExperienceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateExperienceResponse, error) {
	rsp, err := c.UpdateExperience(ctx, projectID, experienceID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateExperienceResponse(rsp)
}

// DebugExperienceWithBodyWithResponse request with arbitrary body returning *DebugExperienceResponse
func (c *ClientWithResponses) DebugExperienceWithBodyWithResponse(ctx context.Context, projectID ProjectID, experienceID ExperienceID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DebugExperienceResponse, error) {
	rsp, err := c.DebugExperienceWithBody(ctx, projectID, experienceID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDebugExperienceResponse(rsp)
}

func (c *ClientWithResponses) DebugExperienceWithResponse(ctx context.Context, projectID ProjectID, experienceID ExperienceID, body DebugExperienceJSONRequestBody, reqEditors ...RequestEditorFn) (*DebugExperienceResponse, error) {
	rsp, err := c.DebugExperience(ctx, projectID, experienceID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDebugExperienceResponse(rsp)
}

// ListExperienceTagsForExperienceWithResponse request returning *ListExperienceTagsForExperienceResponse
func (c *ClientWithResponses) ListExperienceTagsForExperienceWithResponse(ctx context.Context, projectID ProjectID, experienceID ExperienceID, params *ListExperienceTagsForExperienceParams, reqEditors ...RequestEditorFn) (*ListExperienceTagsForExperienceResponse, error) {
	rsp, err := c.ListExperienceTagsForExperience(ctx, projectID, experienceID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListExperienceTagsForExperienceResponse(rsp)
}

// RestoreExperienceWithResponse request returning *RestoreExperienceResponse
func (c *ClientWithResponses) RestoreExperienceWithResponse(ctx context.Context, projectID ProjectID, experienceID ExperienceID, reqEditors ...RequestEditorFn) (*RestoreExperienceResponse, error) {
	rsp, err := c.RestoreExperience(ctx, projectID, experienceID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreExperienceResponse(rsp)
}

// GetSystemsForExperienceWithResponse request returning *GetSystemsForExperienceResponse
func (c *ClientWithResponses) GetSystemsForExperienceWithResponse(ctx context.Context, projectID ProjectID, experienceID ExperienceID, params *GetSystemsForExperienceParams, reqEditors ...RequestEditorFn) (*GetSystemsForExperienceResponse, error) {
	rsp, err := c.GetSystemsForExperience(ctx, projectID, experienceID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemsForExperienceResponse(rsp)
}

// ListMetricsBuildsWithResponse request returning *ListMetricsBuildsResponse
func (c *ClientWithResponses) ListMetricsBuildsWithResponse(ctx context.Context, projectID ProjectID, params *ListMetricsBuildsParams, reqEditors ...RequestEditorFn) (*ListMetricsBuildsResponse, error) {
	rsp, err := c.ListMetricsBuilds(ctx, projectID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListMetricsBuildsResponse(rsp)
}

// CreateMetricsBuildWithBodyWithResponse request with arbitrary body returning *CreateMetricsBuildResponse
func (c *ClientWithResponses) CreateMetricsBuildWithBodyWithResponse(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateMetricsBuildResponse, error) {
	rsp, err := c.CreateMetricsBuildWithBody(ctx, projectID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateMetricsBuildResponse(rsp)
}

func (c *ClientWithResponses) CreateMetricsBuildWithResponse(ctx context.Context, projectID ProjectID, body CreateMetricsBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateMetricsBuildResponse, error) {
	rsp, err := c.CreateMetricsBuild(ctx, projectID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateMetricsBuildResponse(rsp)
}

// GetMetricsBuildWithResponse request returning *GetMetricsBuildResponse
func (c *ClientWithResponses) GetMetricsBuildWithResponse(ctx context.Context, projectID ProjectID, metricsBuildID MetricsBuildID, reqEditors ...RequestEditorFn) (*GetMetricsBuildResponse, error) {
	rsp, err := c.GetMetricsBuild(ctx, projectID, metricsBuildID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMetricsBuildResponse(rsp)
}

// GetSystemsForMetricsBuildWithResponse request returning *GetSystemsForMetricsBuildResponse
func (c *ClientWithResponses) GetSystemsForMetricsBuildWithResponse(ctx context.Context, projectID ProjectID, metricsBuildID MetricsBuildID, params *GetSystemsForMetricsBuildParams, reqEditors ...RequestEditorFn) (*GetSystemsForMetricsBuildResponse, error) {
	rsp, err := c.GetSystemsForMetricsBuild(ctx, projectID, metricsBuildID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemsForMetricsBuildResponse(rsp)
}

// ListServiceProfilesWithResponse request returning *ListServiceProfilesResponse
func (c *ClientWithResponses) ListServiceProfilesWithResponse(ctx context.Context, projectID ProjectID, reqEditors ...RequestEditorFn) (*ListServiceProfilesResponse, error) {
	rsp, err := c.ListServiceProfiles(ctx, projectID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListServiceProfilesResponse(rsp)
}

// ListReportsWithResponse request returning *ListReportsResponse
func (c *ClientWithResponses) ListReportsWithResponse(ctx context.Context, projectID ProjectID, params *ListReportsParams, reqEditors ...RequestEditorFn) (*ListReportsResponse, error) {
	rsp, err := c.ListReports(ctx, projectID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListReportsResponse(rsp)
}

// CreateReportWithBodyWithResponse request with arbitrary body returning *CreateReportResponse
func (c *ClientWithResponses) CreateReportWithBodyWithResponse(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateReportResponse, error) {
	rsp, err := c.CreateReportWithBody(ctx, projectID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateReportResponse(rsp)
}

func (c *ClientWithResponses) CreateReportWithResponse(ctx context.Context, projectID ProjectID, body CreateReportJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateReportResponse, error) {
	rsp, err := c.CreateReport(ctx, projectID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateReportResponse(rsp)
}

// ListReportAccountsWithResponse request returning *ListReportAccountsResponse
func (c *ClientWithResponses) ListReportAccountsWithResponse(ctx context.Context, projectID ProjectID, reqEditors ...RequestEditorFn) (*ListReportAccountsResponse, error) {
	rsp, err := c.ListReportAccounts(ctx, projectID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListReportAccountsResponse(rsp)
}

// GetReportWithResponse request returning *GetReportResponse
func (c *ClientWithResponses) GetReportWithResponse(ctx context.Context, projectID ProjectID, reportID ReportID, reqEditors ...RequestEditorFn) (*GetReportResponse, error) {
	rsp, err := c.GetReport(ctx, projectID, reportID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReportResponse(rsp)
}

// ListLogsForReportWithResponse request returning *ListLogsForReportResponse
func (c *ClientWithResponses) ListLogsForReportWithResponse(ctx context.Context, projectID ProjectID, reportID ReportID, params *ListLogsForReportParams, reqEditors ...RequestEditorFn) (*ListLogsForReportResponse, error) {
	rsp, err := c.ListLogsForReport(ctx, projectID, reportID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListLogsForReportResponse(rsp)
}

// GetReportLogWithResponse request returning *GetReportLogResponse
func (c *ClientWithResponses) GetReportLogWithResponse(ctx context.Context, projectID ProjectID, reportID ReportID, logID LogID, reqEditors ...RequestEditorFn) (*GetReportLogResponse, error) {
	rsp, err := c.GetReportLog(ctx, projectID, reportID, logID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReportLogResponse(rsp)
}

// ListReportMetricsWithResponse request returning *ListReportMetricsResponse
func (c *ClientWithResponses) ListReportMetricsWithResponse(ctx context.Context, projectID ProjectID, reportID ReportID, params *ListReportMetricsParams, reqEditors ...RequestEditorFn) (*ListReportMetricsResponse, error) {
	rsp, err := c.ListReportMetrics(ctx, projectID, reportID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListReportMetricsResponse(rsp)
}

// ListReportMetricsForReportMetricIDsWithResponse request returning *ListReportMetricsForReportMetricIDsResponse
func (c *ClientWithResponses) ListReportMetricsForReportMetricIDsWithResponse(ctx context.Context, projectID ProjectID, reportID ReportID, metricID []MetricID, params *ListReportMetricsForReportMetricIDsParams, reqEditors ...RequestEditorFn) (*ListReportMetricsForReportMetricIDsResponse, error) {
	rsp, err := c.ListReportMetricsForReportMetricIDs(ctx, projectID, reportID, metricID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListReportMetricsForReportMetricIDsResponse(rsp)
}

// ListReportMetricsDataForReportMetricIDsWithResponse request returning *ListReportMetricsDataForReportMetricIDsResponse
func (c *ClientWithResponses) ListReportMetricsDataForReportMetricIDsWithResponse(ctx context.Context, projectID ProjectID, reportID ReportID, metricID []MetricID, params *ListReportMetricsDataForReportMetricIDsParams, reqEditors ...RequestEditorFn) (*ListReportMetricsDataForReportMetricIDsResponse, error) {
	rsp, err := c.ListReportMetricsDataForReportMetricIDs(ctx, projectID, reportID, metricID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListReportMetricsDataForReportMetricIDsResponse(rsp)
}

// ListTagsForReportMetricsWithResponse request returning *ListTagsForReportMetricsResponse
func (c *ClientWithResponses) ListTagsForReportMetricsWithResponse(ctx context.Context, projectID ProjectID, reportID ReportID, metricID []MetricID, params *ListTagsForReportMetricsParams, reqEditors ...RequestEditorFn) (*ListTagsForReportMetricsResponse, error) {
	rsp, err := c.ListTagsForReportMetrics(ctx, projectID, reportID, metricID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListTagsForReportMetricsResponse(rsp)
}

// ListReportMetricsDataWithResponse request returning *ListReportMetricsDataResponse
func (c *ClientWithResponses) ListReportMetricsDataWithResponse(ctx context.Context, projectID ProjectID, reportID ReportID, params *ListReportMetricsDataParams, reqEditors ...RequestEditorFn) (*ListReportMetricsDataResponse, error) {
	rsp, err := c.ListReportMetricsData(ctx, projectID, reportID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListReportMetricsDataResponse(rsp)
}

// ListReportMetricsDataForReportMetricsDataIDsWithResponse request returning *ListReportMetricsDataForReportMetricsDataIDsResponse
func (c *ClientWithResponses) ListReportMetricsDataForReportMetricsDataIDsWithResponse(ctx context.Context, projectID ProjectID, reportID ReportID, metricsDataID []MetricsDataID, params *ListReportMetricsDataForReportMetricsDataIDsParams, reqEditors ...RequestEditorFn) (*ListReportMetricsDataForReportMetricsDataIDsResponse, error) {
	rsp, err := c.ListReportMetricsDataForReportMetricsDataIDs(ctx, projectID, reportID, metricsDataID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListReportMetricsDataForReportMetricsDataIDsResponse(rsp)
}

// ListTestSuitesWithResponse request returning *ListTestSuitesResponse
func (c *ClientWithResponses) ListTestSuitesWithResponse(ctx context.Context, projectID ProjectID, params *ListTestSuitesParams, reqEditors ...RequestEditorFn) (*ListTestSuitesResponse, error) {
	rsp, err := c.ListTestSuites(ctx, projectID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListTestSuitesResponse(rsp)
}

// CreateTestSuiteWithBodyWithResponse request with arbitrary body returning *CreateTestSuiteResponse
func (c *ClientWithResponses) CreateTestSuiteWithBodyWithResponse(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTestSuiteResponse, error) {
	rsp, err := c.CreateTestSuiteWithBody(ctx, projectID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTestSuiteResponse(rsp)
}

func (c *ClientWithResponses) CreateTestSuiteWithResponse(ctx context.Context, projectID ProjectID, body CreateTestSuiteJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTestSuiteResponse, error) {
	rsp, err := c.CreateTestSuite(ctx, projectID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTestSuiteResponse(rsp)
}

// AddTestSuitesToExperiencesWithBodyWithResponse request with arbitrary body returning *AddTestSuitesToExperiencesResponse
func (c *ClientWithResponses) AddTestSuitesToExperiencesWithBodyWithResponse(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddTestSuitesToExperiencesResponse, error) {
	rsp, err := c.AddTestSuitesToExperiencesWithBody(ctx, projectID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddTestSuitesToExperiencesResponse(rsp)
}

func (c *ClientWithResponses) AddTestSuitesToExperiencesWithResponse(ctx context.Context, projectID ProjectID, body AddTestSuitesToExperiencesJSONRequestBody, reqEditors ...RequestEditorFn) (*AddTestSuitesToExperiencesResponse, error) {
	rsp, err := c.AddTestSuitesToExperiences(ctx, projectID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddTestSuitesToExperiencesResponse(rsp)
}

// GetTestSuiteSummaryWithResponse request returning *GetTestSuiteSummaryResponse
func (c *ClientWithResponses) GetTestSuiteSummaryWithResponse(ctx context.Context, projectID ProjectID, params *GetTestSuiteSummaryParams, reqEditors ...RequestEditorFn) (*GetTestSuiteSummaryResponse, error) {
	rsp, err := c.GetTestSuiteSummary(ctx, projectID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTestSuiteSummaryResponse(rsp)
}

// ArchiveTestSuiteWithResponse request returning *ArchiveTestSuiteResponse
func (c *ClientWithResponses) ArchiveTestSuiteWithResponse(ctx context.Context, projectID ProjectID, testSuiteID TestSuiteID, reqEditors ...RequestEditorFn) (*ArchiveTestSuiteResponse, error) {
	rsp, err := c.ArchiveTestSuite(ctx, projectID, testSuiteID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveTestSuiteResponse(rsp)
}

// GetTestSuiteWithResponse request returning *GetTestSuiteResponse
func (c *ClientWithResponses) GetTestSuiteWithResponse(ctx context.Context, projectID ProjectID, testSuiteID TestSuiteID, reqEditors ...RequestEditorFn) (*GetTestSuiteResponse, error) {
	rsp, err := c.GetTestSuite(ctx, projectID, testSuiteID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTestSuiteResponse(rsp)
}

// ReviseTestSuiteWithBodyWithResponse request with arbitrary body returning *ReviseTestSuiteResponse
func (c *ClientWithResponses) ReviseTestSuiteWithBodyWithResponse(ctx context.Context, projectID ProjectID, testSuiteID TestSuiteID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReviseTestSuiteResponse, error) {
	rsp, err := c.ReviseTestSuiteWithBody(ctx, projectID, testSuiteID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReviseTestSuiteResponse(rsp)
}

func (c *ClientWithResponses) ReviseTestSuiteWithResponse(ctx context.Context, projectID ProjectID, testSuiteID TestSuiteID, body ReviseTestSuiteJSONRequestBody, reqEditors ...RequestEditorFn) (*ReviseTestSuiteResponse, error) {
	rsp, err := c.ReviseTestSuite(ctx, projectID, testSuiteID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReviseTestSuiteResponse(rsp)
}

// AddExperiencesToTestSuiteWithBodyWithResponse request with arbitrary body returning *AddExperiencesToTestSuiteResponse
func (c *ClientWithResponses) AddExperiencesToTestSuiteWithBodyWithResponse(ctx context.Context, projectID ProjectID, testSuiteID TestSuiteID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddExperiencesToTestSuiteResponse, error) {
	rsp, err := c.AddExperiencesToTestSuiteWithBody(ctx, projectID, testSuiteID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddExperiencesToTestSuiteResponse(rsp)
}

func (c *ClientWithResponses) AddExperiencesToTestSuiteWithResponse(ctx context.Context, projectID ProjectID, testSuiteID TestSuiteID, body AddExperiencesToTestSuiteJSONRequestBody, reqEditors ...RequestEditorFn) (*AddExperiencesToTestSuiteResponse, error) {
	rsp, err := c.AddExperiencesToTestSuite(ctx, projectID, testSuiteID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddExperiencesToTestSuiteResponse(rsp)
}

// ListBatchesForTestSuiteWithResponse request returning *ListBatchesForTestSuiteResponse
func (c *ClientWithResponses) ListBatchesForTestSuiteWithResponse(ctx context.Context, projectID ProjectID, testSuiteID TestSuiteID, params *ListBatchesForTestSuiteParams, reqEditors ...RequestEditorFn) (*ListBatchesForTestSuiteResponse, error) {
	rsp, err := c.ListBatchesForTestSuite(ctx, projectID, testSuiteID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBatchesForTestSuiteResponse(rsp)
}

// CreateBatchForTestSuiteWithBodyWithResponse request with arbitrary body returning *CreateBatchForTestSuiteResponse
func (c *ClientWithResponses) CreateBatchForTestSuiteWithBodyWithResponse(ctx context.Context, projectID ProjectID, testSuiteID TestSuiteID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBatchForTestSuiteResponse, error) {
	rsp, err := c.CreateBatchForTestSuiteWithBody(ctx, projectID, testSuiteID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBatchForTestSuiteResponse(rsp)
}

func (c *ClientWithResponses) CreateBatchForTestSuiteWithResponse(ctx context.Context, projectID ProjectID, testSuiteID TestSuiteID, body CreateBatchForTestSuiteJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBatchForTestSuiteResponse, error) {
	rsp, err := c.CreateBatchForTestSuite(ctx, projectID, testSuiteID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBatchForTestSuiteResponse(rsp)
}

// RemoveExperiencesFromTestSuiteWithBodyWithResponse request with arbitrary body returning *RemoveExperiencesFromTestSuiteResponse
func (c *ClientWithResponses) RemoveExperiencesFromTestSuiteWithBodyWithResponse(ctx context.Context, projectID ProjectID, testSuiteID TestSuiteID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveExperiencesFromTestSuiteResponse, error) {
	rsp, err := c.RemoveExperiencesFromTestSuiteWithBody(ctx, projectID, testSuiteID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveExperiencesFromTestSuiteResponse(rsp)
}

func (c *ClientWithResponses) RemoveExperiencesFromTestSuiteWithResponse(ctx context.Context, projectID ProjectID, testSuiteID TestSuiteID, body RemoveExperiencesFromTestSuiteJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveExperiencesFromTestSuiteResponse, error) {
	rsp, err := c.RemoveExperiencesFromTestSuite(ctx, projectID, testSuiteID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveExperiencesFromTestSuiteResponse(rsp)
}

// RestoreTestSuiteWithResponse request returning *RestoreTestSuiteResponse
func (c *ClientWithResponses) RestoreTestSuiteWithResponse(ctx context.Context, projectID ProjectID, testSuiteID TestSuiteID, reqEditors ...RequestEditorFn) (*RestoreTestSuiteResponse, error) {
	rsp, err := c.RestoreTestSuite(ctx, projectID, testSuiteID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreTestSuiteResponse(rsp)
}

// ListTestSuiteRevisionsWithResponse request returning *ListTestSuiteRevisionsResponse
func (c *ClientWithResponses) ListTestSuiteRevisionsWithResponse(ctx context.Context, projectID ProjectID, testSuiteID TestSuiteID, params *ListTestSuiteRevisionsParams, reqEditors ...RequestEditorFn) (*ListTestSuiteRevisionsResponse, error) {
	rsp, err := c.ListTestSuiteRevisions(ctx, projectID, testSuiteID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListTestSuiteRevisionsResponse(rsp)
}

// GetTestSuiteRevisionWithResponse request returning *GetTestSuiteRevisionResponse
func (c *ClientWithResponses) GetTestSuiteRevisionWithResponse(ctx context.Context, projectID ProjectID, testSuiteID TestSuiteID, revision TestSuiteRevision, reqEditors ...RequestEditorFn) (*GetTestSuiteRevisionResponse, error) {
	rsp, err := c.GetTestSuiteRevision(ctx, projectID, testSuiteID, revision, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTestSuiteRevisionResponse(rsp)
}

// ListBatchesForTestSuiteRevisionWithResponse request returning *ListBatchesForTestSuiteRevisionResponse
func (c *ClientWithResponses) ListBatchesForTestSuiteRevisionWithResponse(ctx context.Context, projectID ProjectID, testSuiteID TestSuiteID, revision TestSuiteRevision, params *ListBatchesForTestSuiteRevisionParams, reqEditors ...RequestEditorFn) (*ListBatchesForTestSuiteRevisionResponse, error) {
	rsp, err := c.ListBatchesForTestSuiteRevision(ctx, projectID, testSuiteID, revision, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBatchesForTestSuiteRevisionResponse(rsp)
}

// CreateBatchForTestSuiteRevisionWithBodyWithResponse request with arbitrary body returning *CreateBatchForTestSuiteRevisionResponse
func (c *ClientWithResponses) CreateBatchForTestSuiteRevisionWithBodyWithResponse(ctx context.Context, projectID ProjectID, testSuiteID TestSuiteID, revision TestSuiteRevision, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBatchForTestSuiteRevisionResponse, error) {
	rsp, err := c.CreateBatchForTestSuiteRevisionWithBody(ctx, projectID, testSuiteID, revision, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBatchForTestSuiteRevisionResponse(rsp)
}

func (c *ClientWithResponses) CreateBatchForTestSuiteRevisionWithResponse(ctx context.Context, projectID ProjectID, testSuiteID TestSuiteID, revision TestSuiteRevision, body CreateBatchForTestSuiteRevisionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBatchForTestSuiteRevisionResponse, error) {
	rsp, err := c.CreateBatchForTestSuiteRevision(ctx, projectID, testSuiteID, revision, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBatchForTestSuiteRevisionResponse(rsp)
}

// ListParameterSweepsWithResponse request returning *ListParameterSweepsResponse
func (c *ClientWithResponses) ListParameterSweepsWithResponse(ctx context.Context, projectID ProjectID, params *ListParameterSweepsParams, reqEditors ...RequestEditorFn) (*ListParameterSweepsResponse, error) {
	rsp, err := c.ListParameterSweeps(ctx, projectID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListParameterSweepsResponse(rsp)
}

// CreateParameterSweepWithBodyWithResponse request with arbitrary body returning *CreateParameterSweepResponse
func (c *ClientWithResponses) CreateParameterSweepWithBodyWithResponse(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateParameterSweepResponse, error) {
	rsp, err := c.CreateParameterSweepWithBody(ctx, projectID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateParameterSweepResponse(rsp)
}

func (c *ClientWithResponses) CreateParameterSweepWithResponse(ctx context.Context, projectID ProjectID, body CreateParameterSweepJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateParameterSweepResponse, error) {
	rsp, err := c.CreateParameterSweep(ctx, projectID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateParameterSweepResponse(rsp)
}

// ListSweepAccountsWithResponse request returning *ListSweepAccountsResponse
func (c *ClientWithResponses) ListSweepAccountsWithResponse(ctx context.Context, projectID ProjectID, reqEditors ...RequestEditorFn) (*ListSweepAccountsResponse, error) {
	rsp, err := c.ListSweepAccounts(ctx, projectID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSweepAccountsResponse(rsp)
}

// GetParameterSweepWithResponse request returning *GetParameterSweepResponse
func (c *ClientWithResponses) GetParameterSweepWithResponse(ctx context.Context, projectID ProjectID, sweepID ParameterSweepID, reqEditors ...RequestEditorFn) (*GetParameterSweepResponse, error) {
	rsp, err := c.GetParameterSweep(ctx, projectID, sweepID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetParameterSweepResponse(rsp)
}

// CancelParameterSweepWithResponse request returning *CancelParameterSweepResponse
func (c *ClientWithResponses) CancelParameterSweepWithResponse(ctx context.Context, projectID ProjectID, sweepID ParameterSweepID, reqEditors ...RequestEditorFn) (*CancelParameterSweepResponse, error) {
	rsp, err := c.CancelParameterSweep(ctx, projectID, sweepID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelParameterSweepResponse(rsp)
}

// ListSystemsWithResponse request returning *ListSystemsResponse
func (c *ClientWithResponses) ListSystemsWithResponse(ctx context.Context, projectID ProjectID, params *ListSystemsParams, reqEditors ...RequestEditorFn) (*ListSystemsResponse, error) {
	rsp, err := c.ListSystems(ctx, projectID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSystemsResponse(rsp)
}

// CreateSystemWithBodyWithResponse request with arbitrary body returning *CreateSystemResponse
func (c *ClientWithResponses) CreateSystemWithBodyWithResponse(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSystemResponse, error) {
	rsp, err := c.CreateSystemWithBody(ctx, projectID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSystemResponse(rsp)
}

func (c *ClientWithResponses) CreateSystemWithResponse(ctx context.Context, projectID ProjectID, body CreateSystemJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSystemResponse, error) {
	rsp, err := c.CreateSystem(ctx, projectID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSystemResponse(rsp)
}

// AddSystemsToExperiencesWithBodyWithResponse request with arbitrary body returning *AddSystemsToExperiencesResponse
func (c *ClientWithResponses) AddSystemsToExperiencesWithBodyWithResponse(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddSystemsToExperiencesResponse, error) {
	rsp, err := c.AddSystemsToExperiencesWithBody(ctx, projectID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddSystemsToExperiencesResponse(rsp)
}

func (c *ClientWithResponses) AddSystemsToExperiencesWithResponse(ctx context.Context, projectID ProjectID, body AddSystemsToExperiencesJSONRequestBody, reqEditors ...RequestEditorFn) (*AddSystemsToExperiencesResponse, error) {
	rsp, err := c.AddSystemsToExperiences(ctx, projectID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddSystemsToExperiencesResponse(rsp)
}

// RemoveSystemsFromExperiencesWithBodyWithResponse request with arbitrary body returning *RemoveSystemsFromExperiencesResponse
func (c *ClientWithResponses) RemoveSystemsFromExperiencesWithBodyWithResponse(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveSystemsFromExperiencesResponse, error) {
	rsp, err := c.RemoveSystemsFromExperiencesWithBody(ctx, projectID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveSystemsFromExperiencesResponse(rsp)
}

func (c *ClientWithResponses) RemoveSystemsFromExperiencesWithResponse(ctx context.Context, projectID ProjectID, body RemoveSystemsFromExperiencesJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveSystemsFromExperiencesResponse, error) {
	rsp, err := c.RemoveSystemsFromExperiences(ctx, projectID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveSystemsFromExperiencesResponse(rsp)
}

// ArchiveSystemWithResponse request returning *ArchiveSystemResponse
func (c *ClientWithResponses) ArchiveSystemWithResponse(ctx context.Context, projectID ProjectID, systemID SystemID, reqEditors ...RequestEditorFn) (*ArchiveSystemResponse, error) {
	rsp, err := c.ArchiveSystem(ctx, projectID, systemID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveSystemResponse(rsp)
}

// GetSystemWithResponse request returning *GetSystemResponse
func (c *ClientWithResponses) GetSystemWithResponse(ctx context.Context, projectID ProjectID, systemID SystemID, reqEditors ...RequestEditorFn) (*GetSystemResponse, error) {
	rsp, err := c.GetSystem(ctx, projectID, systemID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemResponse(rsp)
}

// UpdateSystemWithBodyWithResponse request with arbitrary body returning *UpdateSystemResponse
func (c *ClientWithResponses) UpdateSystemWithBodyWithResponse(ctx context.Context, projectID ProjectID, systemID SystemID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSystemResponse, error) {
	rsp, err := c.UpdateSystemWithBody(ctx, projectID, systemID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSystemResponse(rsp)
}

func (c *ClientWithResponses) UpdateSystemWithResponse(ctx context.Context, projectID ProjectID, systemID SystemID, body UpdateSystemJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSystemResponse, error) {
	rsp, err := c.UpdateSystem(ctx, projectID, systemID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSystemResponse(rsp)
}

// ListBuildsForSystemWithResponse request returning *ListBuildsForSystemResponse
func (c *ClientWithResponses) ListBuildsForSystemWithResponse(ctx context.Context, projectID ProjectID, systemID SystemID, params *ListBuildsForSystemParams, reqEditors ...RequestEditorFn) (*ListBuildsForSystemResponse, error) {
	rsp, err := c.ListBuildsForSystem(ctx, projectID, systemID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBuildsForSystemResponse(rsp)
}

// CreateBuildForSystemWithBodyWithResponse request with arbitrary body returning *CreateBuildForSystemResponse
func (c *ClientWithResponses) CreateBuildForSystemWithBodyWithResponse(ctx context.Context, projectID ProjectID, systemID SystemID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBuildForSystemResponse, error) {
	rsp, err := c.CreateBuildForSystemWithBody(ctx, projectID, systemID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBuildForSystemResponse(rsp)
}

func (c *ClientWithResponses) CreateBuildForSystemWithResponse(ctx context.Context, projectID ProjectID, systemID SystemID, body CreateBuildForSystemJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBuildForSystemResponse, error) {
	rsp, err := c.CreateBuildForSystem(ctx, projectID, systemID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBuildForSystemResponse(rsp)
}

// GetBuildForSystemWithResponse request returning *GetBuildForSystemResponse
func (c *ClientWithResponses) GetBuildForSystemWithResponse(ctx context.Context, projectID ProjectID, systemID SystemID, buildID BuildID, reqEditors ...RequestEditorFn) (*GetBuildForSystemResponse, error) {
	rsp, err := c.GetBuildForSystem(ctx, projectID, systemID, buildID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBuildForSystemResponse(rsp)
}

// ListExperiencesForSystemWithResponse request returning *ListExperiencesForSystemResponse
func (c *ClientWithResponses) ListExperiencesForSystemWithResponse(ctx context.Context, projectID ProjectID, systemID SystemID, params *ListExperiencesForSystemParams, reqEditors ...RequestEditorFn) (*ListExperiencesForSystemResponse, error) {
	rsp, err := c.ListExperiencesForSystem(ctx, projectID, systemID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListExperiencesForSystemResponse(rsp)
}

// RemoveSystemFromExperienceWithResponse request returning *RemoveSystemFromExperienceResponse
func (c *ClientWithResponses) RemoveSystemFromExperienceWithResponse(ctx context.Context, projectID ProjectID, systemID SystemID, experienceID ExperienceID, reqEditors ...RequestEditorFn) (*RemoveSystemFromExperienceResponse, error) {
	rsp, err := c.RemoveSystemFromExperience(ctx, projectID, systemID, experienceID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveSystemFromExperienceResponse(rsp)
}

// AddSystemToExperienceWithResponse request returning *AddSystemToExperienceResponse
func (c *ClientWithResponses) AddSystemToExperienceWithResponse(ctx context.Context, projectID ProjectID, systemID SystemID, experienceID ExperienceID, reqEditors ...RequestEditorFn) (*AddSystemToExperienceResponse, error) {
	rsp, err := c.AddSystemToExperience(ctx, projectID, systemID, experienceID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddSystemToExperienceResponse(rsp)
}

// RemoveSystemFromMetricsBuildWithResponse request returning *RemoveSystemFromMetricsBuildResponse
func (c *ClientWithResponses) RemoveSystemFromMetricsBuildWithResponse(ctx context.Context, projectID ProjectID, systemID SystemID, metricsBuildID MetricsBuildID, reqEditors ...RequestEditorFn) (*RemoveSystemFromMetricsBuildResponse, error) {
	rsp, err := c.RemoveSystemFromMetricsBuild(ctx, projectID, systemID, metricsBuildID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveSystemFromMetricsBuildResponse(rsp)
}

// AddSystemToMetricsBuildWithResponse request returning *AddSystemToMetricsBuildResponse
func (c *ClientWithResponses) AddSystemToMetricsBuildWithResponse(ctx context.Context, projectID ProjectID, systemID SystemID, metricsBuildID MetricsBuildID, reqEditors ...RequestEditorFn) (*AddSystemToMetricsBuildResponse, error) {
	rsp, err := c.AddSystemToMetricsBuild(ctx, projectID, systemID, metricsBuildID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddSystemToMetricsBuildResponse(rsp)
}

// GetQuotaWithResponse request returning *GetQuotaResponse
func (c *ClientWithResponses) GetQuotaWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetQuotaResponse, error) {
	rsp, err := c.GetQuota(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetQuotaResponse(rsp)
}

// ValidateExperienceLocationWithBodyWithResponse request with arbitrary body returning *ValidateExperienceLocationResponse
func (c *ClientWithResponses) ValidateExperienceLocationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ValidateExperienceLocationResponse, error) {
	rsp, err := c.ValidateExperienceLocationWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseValidateExperienceLocationResponse(rsp)
}

func (c *ClientWithResponses) ValidateExperienceLocationWithResponse(ctx context.Context, body ValidateExperienceLocationJSONRequestBody, reqEditors ...RequestEditorFn) (*ValidateExperienceLocationResponse, error) {
	rsp, err := c.ValidateExperienceLocation(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseValidateExperienceLocationResponse(rsp)
}

// ListViewSessionsWithResponse request returning *ListViewSessionsResponse
func (c *ClientWithResponses) ListViewSessionsWithResponse(ctx context.Context, params *ListViewSessionsParams, reqEditors ...RequestEditorFn) (*ListViewSessionsResponse, error) {
	rsp, err := c.ListViewSessions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListViewSessionsResponse(rsp)
}

// CreateViewSessionWithResponse request returning *CreateViewSessionResponse
func (c *ClientWithResponses) CreateViewSessionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CreateViewSessionResponse, error) {
	rsp, err := c.CreateViewSession(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateViewSessionResponse(rsp)
}

// GetViewSessionWithResponse request returning *GetViewSessionResponse
func (c *ClientWithResponses) GetViewSessionWithResponse(ctx context.Context, viewSessionID ViewSessionID, reqEditors ...RequestEditorFn) (*GetViewSessionResponse, error) {
	rsp, err := c.GetViewSession(ctx, viewSessionID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetViewSessionResponse(rsp)
}

// CreateViewUpdateWithBodyWithResponse request with arbitrary body returning *CreateViewUpdateResponse
func (c *ClientWithResponses) CreateViewUpdateWithBodyWithResponse(ctx context.Context, viewSessionID ViewSessionID, viewUpdateID ViewUpdateID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateViewUpdateResponse, error) {
	rsp, err := c.CreateViewUpdateWithBody(ctx, viewSessionID, viewUpdateID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateViewUpdateResponse(rsp)
}

// ParseHealthResponse parses an HTTP response from a HealthWithResponse call
func ParseHealthResponse(rsp *http.Response) (*HealthResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HealthResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListProjectsResponse parses an HTTP response from a ListProjectsWithResponse call
func ParseListProjectsResponse(rsp *http.Response) (*ListProjectsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListProjectsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListProjectsOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateProjectResponse parses an HTTP response from a CreateProjectWithResponse call
func ParseCreateProjectResponse(rsp *http.Response) (*CreateProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Project
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseArchiveProjectResponse parses an HTTP response from a ArchiveProjectWithResponse call
func ParseArchiveProjectResponse(rsp *http.Response) (*ArchiveProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArchiveProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetProjectResponse parses an HTTP response from a GetProjectWithResponse call
func ParseGetProjectResponse(rsp *http.Response) (*GetProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Project
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateProjectResponse parses an HTTP response from a UpdateProjectWithResponse call
func ParseUpdateProjectResponse(rsp *http.Response) (*UpdateProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Project
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListBatchesResponse parses an HTTP response from a ListBatchesWithResponse call
func ParseListBatchesResponse(rsp *http.Response) (*ListBatchesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListBatchesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListBatchesOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateBatchResponse parses an HTTP response from a CreateBatchWithResponse call
func ParseCreateBatchResponse(rsp *http.Response) (*CreateBatchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBatchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Batch
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseListAllJobsResponse parses an HTTP response from a ListAllJobsWithResponse call
func ParseListAllJobsResponse(rsp *http.Response) (*ListAllJobsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAllJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListAllJobsOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListBatchAccountsResponse parses an HTTP response from a ListBatchAccountsWithResponse call
func ParseListBatchAccountsResponse(rsp *http.Response) (*ListBatchAccountsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListBatchAccountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListUsersOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetBatchResponse parses an HTTP response from a GetBatchWithResponse call
func ParseGetBatchResponse(rsp *http.Response) (*GetBatchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBatchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Batch
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateBatchResponse parses an HTTP response from a UpdateBatchWithResponse call
func ParseUpdateBatchResponse(rsp *http.Response) (*UpdateBatchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateBatchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Batch
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCancelBatchResponse parses an HTTP response from a CancelBatchWithResponse call
func ParseCancelBatchResponse(rsp *http.Response) (*CancelBatchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CancelBatchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCompareBatchesResponse parses an HTTP response from a CompareBatchesWithResponse call
func ParseCompareBatchesResponse(rsp *http.Response) (*CompareBatchesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CompareBatchesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CompareBatchesOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListBatchErrorsResponse parses an HTTP response from a ListBatchErrorsWithResponse call
func ParseListBatchErrorsResponse(rsp *http.Response) (*ListBatchErrorsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListBatchErrorsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListBatchErrorsOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListJobsResponse parses an HTTP response from a ListJobsWithResponse call
func ParseListJobsResponse(rsp *http.Response) (*ListJobsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListJobsOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetJobResponse parses an HTTP response from a GetJobWithResponse call
func ParseGetJobResponse(rsp *http.Response) (*GetJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Job
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateJobResponse parses an HTTP response from a UpdateJobWithResponse call
func ParseUpdateJobResponse(rsp *http.Response) (*UpdateJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Job
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListEventTagsForJobResponse parses an HTTP response from a ListEventTagsForJobWithResponse call
func ParseListEventTagsForJobResponse(rsp *http.Response) (*ListEventTagsForJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListEventTagsForJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListJobEventTagsOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListEventsForJobResponse parses an HTTP response from a ListEventsForJobWithResponse call
func ParseListEventsForJobResponse(rsp *http.Response) (*ListEventsForJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListEventsForJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListJobEventsOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetEventForJobResponse parses an HTTP response from a GetEventForJobWithResponse call
func ParseGetEventForJobResponse(rsp *http.Response) (*GetEventForJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEventForJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Event
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateEventResponse parses an HTTP response from a UpdateEventWithResponse call
func ParseUpdateEventResponse(rsp *http.Response) (*UpdateEventResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateEventResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Event
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListJobLogsForJobResponse parses an HTTP response from a ListJobLogsForJobWithResponse call
func ParseListJobLogsForJobResponse(rsp *http.Response) (*ListJobLogsForJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListJobLogsForJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListJobLogsOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteJobLogResponse parses an HTTP response from a DeleteJobLogWithResponse call
func ParseDeleteJobLogResponse(rsp *http.Response) (*DeleteJobLogResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteJobLogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetJobLogResponse parses an HTTP response from a GetJobLogWithResponse call
func ParseGetJobLogResponse(rsp *http.Response) (*GetJobLogResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetJobLogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest JobLog
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListMetricsForJobResponse parses an HTTP response from a ListMetricsForJobWithResponse call
func ParseListMetricsForJobResponse(rsp *http.Response) (*ListMetricsForJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListMetricsForJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListJobMetricsOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListMetricsForMetricIDsResponse parses an HTTP response from a ListMetricsForMetricIDsWithResponse call
func ParseListMetricsForMetricIDsResponse(rsp *http.Response) (*ListMetricsForMetricIDsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListMetricsForMetricIDsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListJobMetricsOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListMetricsDataForMetricIDsResponse parses an HTTP response from a ListMetricsDataForMetricIDsWithResponse call
func ParseListMetricsDataForMetricIDsResponse(rsp *http.Response) (*ListMetricsDataForMetricIDsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListMetricsDataForMetricIDsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListMetricsDataAndMetricIDOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListTagsForJobMetricsResponse parses an HTTP response from a ListTagsForJobMetricsWithResponse call
func ParseListTagsForJobMetricsResponse(rsp *http.Response) (*ListTagsForJobMetricsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListTagsForJobMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListTagsForJobMetricsOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListMetricsDataForJobResponse parses an HTTP response from a ListMetricsDataForJobWithResponse call
func ParseListMetricsDataForJobResponse(rsp *http.Response) (*ListMetricsDataForJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListMetricsDataForJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListJobMetricsDataOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListMetricsDataForMetricsDataIDsResponse parses an HTTP response from a ListMetricsDataForMetricsDataIDsWithResponse call
func ParseListMetricsDataForMetricsDataIDsResponse(rsp *http.Response) (*ListMetricsDataForMetricsDataIDsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListMetricsDataForMetricsDataIDsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListJobMetricsDataOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListBatchLogsForBatchResponse parses an HTTP response from a ListBatchLogsForBatchWithResponse call
func ParseListBatchLogsForBatchResponse(rsp *http.Response) (*ListBatchLogsForBatchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListBatchLogsForBatchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListBatchLogsOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteBatchLogResponse parses an HTTP response from a DeleteBatchLogWithResponse call
func ParseDeleteBatchLogResponse(rsp *http.Response) (*DeleteBatchLogResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteBatchLogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetBatchLogResponse parses an HTTP response from a GetBatchLogWithResponse call
func ParseGetBatchLogResponse(rsp *http.Response) (*GetBatchLogResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBatchLogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BatchLog
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListBatchMetricsResponse parses an HTTP response from a ListBatchMetricsWithResponse call
func ParseListBatchMetricsResponse(rsp *http.Response) (*ListBatchMetricsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListBatchMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListBatchMetricsOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListBatchMetricsForBatchMetricIDsResponse parses an HTTP response from a ListBatchMetricsForBatchMetricIDsWithResponse call
func ParseListBatchMetricsForBatchMetricIDsResponse(rsp *http.Response) (*ListBatchMetricsForBatchMetricIDsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListBatchMetricsForBatchMetricIDsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListBatchMetricsOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListBatchMetricsDataForBatchMetricIDsResponse parses an HTTP response from a ListBatchMetricsDataForBatchMetricIDsWithResponse call
func ParseListBatchMetricsDataForBatchMetricIDsResponse(rsp *http.Response) (*ListBatchMetricsDataForBatchMetricIDsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListBatchMetricsDataForBatchMetricIDsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListBatchMetricsDataForBatchMetricIDsOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListTagsForBatchMetricsResponse parses an HTTP response from a ListTagsForBatchMetricsWithResponse call
func ParseListTagsForBatchMetricsResponse(rsp *http.Response) (*ListTagsForBatchMetricsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListTagsForBatchMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListTagsForBatchMetricsOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListBatchMetricsDataResponse parses an HTTP response from a ListBatchMetricsDataWithResponse call
func ParseListBatchMetricsDataResponse(rsp *http.Response) (*ListBatchMetricsDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListBatchMetricsDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListBatchMetricsDataOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListBatchMetricsDataForBatchMetricsDataIDsResponse parses an HTTP response from a ListBatchMetricsDataForBatchMetricsDataIDsWithResponse call
func ParseListBatchMetricsDataForBatchMetricsDataIDsResponse(rsp *http.Response) (*ListBatchMetricsDataForBatchMetricsDataIDsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListBatchMetricsDataForBatchMetricsDataIDsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListBatchMetricsDataOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRerunBatchResponse parses an HTTP response from a RerunBatchWithResponse call
func ParseRerunBatchResponse(rsp *http.Response) (*RerunBatchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RerunBatchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RerunBatchOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetBatchSuggestionsResponse parses an HTTP response from a GetBatchSuggestionsWithResponse call
func ParseGetBatchSuggestionsResponse(rsp *http.Response) (*GetBatchSuggestionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBatchSuggestionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BatchSuggestionsOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListBranchesForProjectResponse parses an HTTP response from a ListBranchesForProjectWithResponse call
func ParseListBranchesForProjectResponse(rsp *http.Response) (*ListBranchesForProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListBranchesForProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListBranchesOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateBranchForProjectResponse parses an HTTP response from a CreateBranchForProjectWithResponse call
func ParseCreateBranchForProjectResponse(rsp *http.Response) (*CreateBranchForProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBranchForProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Branch
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseDeleteBranchForProjectResponse parses an HTTP response from a DeleteBranchForProjectWithResponse call
func ParseDeleteBranchForProjectResponse(rsp *http.Response) (*DeleteBranchForProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteBranchForProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetBranchForProjectResponse parses an HTTP response from a GetBranchForProjectWithResponse call
func ParseGetBranchForProjectResponse(rsp *http.Response) (*GetBranchForProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBranchForProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Branch
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListBuildsForBranchesResponse parses an HTTP response from a ListBuildsForBranchesWithResponse call
func ParseListBuildsForBranchesResponse(rsp *http.Response) (*ListBuildsForBranchesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListBuildsForBranchesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListBuildsOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateBuildForBranchResponse parses an HTTP response from a CreateBuildForBranchWithResponse call
func ParseCreateBuildForBranchResponse(rsp *http.Response) (*CreateBuildForBranchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBuildForBranchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Build
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseDeleteBuildForBranchResponse parses an HTTP response from a DeleteBuildForBranchWithResponse call
func ParseDeleteBuildForBranchResponse(rsp *http.Response) (*DeleteBuildForBranchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteBuildForBranchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetBuildForBranchResponse parses an HTTP response from a GetBuildForBranchWithResponse call
func ParseGetBuildForBranchResponse(rsp *http.Response) (*GetBuildForBranchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBuildForBranchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Build
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListBatchesForBuildsResponse parses an HTTP response from a ListBatchesForBuildsWithResponse call
func ParseListBatchesForBuildsResponse(rsp *http.Response) (*ListBatchesForBuildsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListBatchesForBuildsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListBatchesOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListBuildsResponse parses an HTTP response from a ListBuildsWithResponse call
func ParseListBuildsResponse(rsp *http.Response) (*ListBuildsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListBuildsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListBuildsOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListBuildAccountsResponse parses an HTTP response from a ListBuildAccountsWithResponse call
func ParseListBuildAccountsResponse(rsp *http.Response) (*ListBuildAccountsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListBuildAccountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListUsersOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetBuildResponse parses an HTTP response from a GetBuildWithResponse call
func ParseGetBuildResponse(rsp *http.Response) (*GetBuildResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBuildResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Build
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateBuildResponse parses an HTTP response from a UpdateBuildWithResponse call
func ParseUpdateBuildResponse(rsp *http.Response) (*UpdateBuildResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateBuildResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Build
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListExperienceTagsResponse parses an HTTP response from a ListExperienceTagsWithResponse call
func ParseListExperienceTagsResponse(rsp *http.Response) (*ListExperienceTagsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListExperienceTagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListExperienceTagsOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateExperienceTagResponse parses an HTTP response from a CreateExperienceTagWithResponse call
func ParseCreateExperienceTagResponse(rsp *http.Response) (*CreateExperienceTagResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateExperienceTagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ExperienceTag
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseAddTagsToExperiencesResponse parses an HTTP response from a AddTagsToExperiencesWithResponse call
func ParseAddTagsToExperiencesResponse(rsp *http.Response) (*AddTagsToExperiencesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddTagsToExperiencesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteExperienceTagResponse parses an HTTP response from a DeleteExperienceTagWithResponse call
func ParseDeleteExperienceTagResponse(rsp *http.Response) (*DeleteExperienceTagResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteExperienceTagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetExperienceTagResponse parses an HTTP response from a GetExperienceTagWithResponse call
func ParseGetExperienceTagResponse(rsp *http.Response) (*GetExperienceTagResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetExperienceTagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ExperienceTag
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateExperienceTagResponse parses an HTTP response from a UpdateExperienceTagWithResponse call
func ParseUpdateExperienceTagResponse(rsp *http.Response) (*UpdateExperienceTagResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateExperienceTagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ExperienceTag
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListExperiencesWithExperienceTagResponse parses an HTTP response from a ListExperiencesWithExperienceTagWithResponse call
func ParseListExperiencesWithExperienceTagResponse(rsp *http.Response) (*ListExperiencesWithExperienceTagResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListExperiencesWithExperienceTagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListExperiencesOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRemoveExperienceTagFromExperienceResponse parses an HTTP response from a RemoveExperienceTagFromExperienceWithResponse call
func ParseRemoveExperienceTagFromExperienceResponse(rsp *http.Response) (*RemoveExperienceTagFromExperienceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveExperienceTagFromExperienceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAddExperienceTagToExperienceResponse parses an HTTP response from a AddExperienceTagToExperienceWithResponse call
func ParseAddExperienceTagToExperienceResponse(rsp *http.Response) (*AddExperienceTagToExperienceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddExperienceTagToExperienceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListExperiencesResponse parses an HTTP response from a ListExperiencesWithResponse call
func ParseListExperiencesResponse(rsp *http.Response) (*ListExperiencesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListExperiencesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListExperiencesOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateExperienceResponse parses an HTTP response from a CreateExperienceWithResponse call
func ParseCreateExperienceResponse(rsp *http.Response) (*CreateExperienceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateExperienceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Experience
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseArchiveExperienceResponse parses an HTTP response from a ArchiveExperienceWithResponse call
func ParseArchiveExperienceResponse(rsp *http.Response) (*ArchiveExperienceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArchiveExperienceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetExperienceResponse parses an HTTP response from a GetExperienceWithResponse call
func ParseGetExperienceResponse(rsp *http.Response) (*GetExperienceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetExperienceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Experience
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateExperienceResponse parses an HTTP response from a UpdateExperienceWithResponse call
func ParseUpdateExperienceResponse(rsp *http.Response) (*UpdateExperienceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateExperienceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Experience
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDebugExperienceResponse parses an HTTP response from a DebugExperienceWithResponse call
func ParseDebugExperienceResponse(rsp *http.Response) (*DebugExperienceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DebugExperienceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest DebugExperienceOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseListExperienceTagsForExperienceResponse parses an HTTP response from a ListExperienceTagsForExperienceWithResponse call
func ParseListExperienceTagsForExperienceResponse(rsp *http.Response) (*ListExperienceTagsForExperienceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListExperienceTagsForExperienceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListExperienceTagsOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRestoreExperienceResponse parses an HTTP response from a RestoreExperienceWithResponse call
func ParseRestoreExperienceResponse(rsp *http.Response) (*RestoreExperienceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestoreExperienceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetSystemsForExperienceResponse parses an HTTP response from a GetSystemsForExperienceWithResponse call
func ParseGetSystemsForExperienceResponse(rsp *http.Response) (*GetSystemsForExperienceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemsForExperienceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListSystemsOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListMetricsBuildsResponse parses an HTTP response from a ListMetricsBuildsWithResponse call
func ParseListMetricsBuildsResponse(rsp *http.Response) (*ListMetricsBuildsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListMetricsBuildsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListMetricsBuildOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateMetricsBuildResponse parses an HTTP response from a CreateMetricsBuildWithResponse call
func ParseCreateMetricsBuildResponse(rsp *http.Response) (*CreateMetricsBuildResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateMetricsBuildResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest MetricsBuild
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseGetMetricsBuildResponse parses an HTTP response from a GetMetricsBuildWithResponse call
func ParseGetMetricsBuildResponse(rsp *http.Response) (*GetMetricsBuildResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMetricsBuildResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MetricsBuild
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSystemsForMetricsBuildResponse parses an HTTP response from a GetSystemsForMetricsBuildWithResponse call
func ParseGetSystemsForMetricsBuildResponse(rsp *http.Response) (*GetSystemsForMetricsBuildResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemsForMetricsBuildResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListSystemsOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListServiceProfilesResponse parses an HTTP response from a ListServiceProfilesWithResponse call
func ParseListServiceProfilesResponse(rsp *http.Response) (*ListServiceProfilesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListServiceProfilesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListReportsResponse parses an HTTP response from a ListReportsWithResponse call
func ParseListReportsResponse(rsp *http.Response) (*ListReportsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListReportsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListReportsOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateReportResponse parses an HTTP response from a CreateReportWithResponse call
func ParseCreateReportResponse(rsp *http.Response) (*CreateReportResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateReportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Report
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseListReportAccountsResponse parses an HTTP response from a ListReportAccountsWithResponse call
func ParseListReportAccountsResponse(rsp *http.Response) (*ListReportAccountsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListReportAccountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListUsersOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetReportResponse parses an HTTP response from a GetReportWithResponse call
func ParseGetReportResponse(rsp *http.Response) (*GetReportResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Report
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListLogsForReportResponse parses an HTTP response from a ListLogsForReportWithResponse call
func ParseListLogsForReportResponse(rsp *http.Response) (*ListLogsForReportResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListLogsForReportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListReportLogsOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetReportLogResponse parses an HTTP response from a GetReportLogWithResponse call
func ParseGetReportLogResponse(rsp *http.Response) (*GetReportLogResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReportLogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReportLog
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListReportMetricsResponse parses an HTTP response from a ListReportMetricsWithResponse call
func ParseListReportMetricsResponse(rsp *http.Response) (*ListReportMetricsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListReportMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListReportMetricsOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListReportMetricsForReportMetricIDsResponse parses an HTTP response from a ListReportMetricsForReportMetricIDsWithResponse call
func ParseListReportMetricsForReportMetricIDsResponse(rsp *http.Response) (*ListReportMetricsForReportMetricIDsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListReportMetricsForReportMetricIDsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListReportMetricsOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListReportMetricsDataForReportMetricIDsResponse parses an HTTP response from a ListReportMetricsDataForReportMetricIDsWithResponse call
func ParseListReportMetricsDataForReportMetricIDsResponse(rsp *http.Response) (*ListReportMetricsDataForReportMetricIDsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListReportMetricsDataForReportMetricIDsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListReportMetricsDataForReportMetricIDsOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListTagsForReportMetricsResponse parses an HTTP response from a ListTagsForReportMetricsWithResponse call
func ParseListTagsForReportMetricsResponse(rsp *http.Response) (*ListTagsForReportMetricsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListTagsForReportMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListTagsForReportMetricsOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListReportMetricsDataResponse parses an HTTP response from a ListReportMetricsDataWithResponse call
func ParseListReportMetricsDataResponse(rsp *http.Response) (*ListReportMetricsDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListReportMetricsDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListReportMetricsDataOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListReportMetricsDataForReportMetricsDataIDsResponse parses an HTTP response from a ListReportMetricsDataForReportMetricsDataIDsWithResponse call
func ParseListReportMetricsDataForReportMetricsDataIDsResponse(rsp *http.Response) (*ListReportMetricsDataForReportMetricsDataIDsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListReportMetricsDataForReportMetricsDataIDsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListReportMetricsDataOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListTestSuitesResponse parses an HTTP response from a ListTestSuitesWithResponse call
func ParseListTestSuitesResponse(rsp *http.Response) (*ListTestSuitesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListTestSuitesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListTestSuiteOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateTestSuiteResponse parses an HTTP response from a CreateTestSuiteWithResponse call
func ParseCreateTestSuiteResponse(rsp *http.Response) (*CreateTestSuiteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTestSuiteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TestSuite
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseAddTestSuitesToExperiencesResponse parses an HTTP response from a AddTestSuitesToExperiencesWithResponse call
func ParseAddTestSuitesToExperiencesResponse(rsp *http.Response) (*AddTestSuitesToExperiencesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddTestSuitesToExperiencesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetTestSuiteSummaryResponse parses an HTTP response from a GetTestSuiteSummaryWithResponse call
func ParseGetTestSuiteSummaryResponse(rsp *http.Response) (*GetTestSuiteSummaryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTestSuiteSummaryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TestSuiteSummaryOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseArchiveTestSuiteResponse parses an HTTP response from a ArchiveTestSuiteWithResponse call
func ParseArchiveTestSuiteResponse(rsp *http.Response) (*ArchiveTestSuiteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArchiveTestSuiteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetTestSuiteResponse parses an HTTP response from a GetTestSuiteWithResponse call
func ParseGetTestSuiteResponse(rsp *http.Response) (*GetTestSuiteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTestSuiteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TestSuite
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReviseTestSuiteResponse parses an HTTP response from a ReviseTestSuiteWithResponse call
func ParseReviseTestSuiteResponse(rsp *http.Response) (*ReviseTestSuiteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReviseTestSuiteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TestSuite
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddExperiencesToTestSuiteResponse parses an HTTP response from a AddExperiencesToTestSuiteWithResponse call
func ParseAddExperiencesToTestSuiteResponse(rsp *http.Response) (*AddExperiencesToTestSuiteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddExperiencesToTestSuiteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TestSuite
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListBatchesForTestSuiteResponse parses an HTTP response from a ListBatchesForTestSuiteWithResponse call
func ParseListBatchesForTestSuiteResponse(rsp *http.Response) (*ListBatchesForTestSuiteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListBatchesForTestSuiteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListBatchesOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateBatchForTestSuiteResponse parses an HTTP response from a CreateBatchForTestSuiteWithResponse call
func ParseCreateBatchForTestSuiteResponse(rsp *http.Response) (*CreateBatchForTestSuiteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBatchForTestSuiteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Batch
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseRemoveExperiencesFromTestSuiteResponse parses an HTTP response from a RemoveExperiencesFromTestSuiteWithResponse call
func ParseRemoveExperiencesFromTestSuiteResponse(rsp *http.Response) (*RemoveExperiencesFromTestSuiteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveExperiencesFromTestSuiteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TestSuite
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRestoreTestSuiteResponse parses an HTTP response from a RestoreTestSuiteWithResponse call
func ParseRestoreTestSuiteResponse(rsp *http.Response) (*RestoreTestSuiteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestoreTestSuiteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListTestSuiteRevisionsResponse parses an HTTP response from a ListTestSuiteRevisionsWithResponse call
func ParseListTestSuiteRevisionsResponse(rsp *http.Response) (*ListTestSuiteRevisionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListTestSuiteRevisionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListTestSuiteRevisionsOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetTestSuiteRevisionResponse parses an HTTP response from a GetTestSuiteRevisionWithResponse call
func ParseGetTestSuiteRevisionResponse(rsp *http.Response) (*GetTestSuiteRevisionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTestSuiteRevisionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TestSuite
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListBatchesForTestSuiteRevisionResponse parses an HTTP response from a ListBatchesForTestSuiteRevisionWithResponse call
func ParseListBatchesForTestSuiteRevisionResponse(rsp *http.Response) (*ListBatchesForTestSuiteRevisionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListBatchesForTestSuiteRevisionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListBatchesOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateBatchForTestSuiteRevisionResponse parses an HTTP response from a CreateBatchForTestSuiteRevisionWithResponse call
func ParseCreateBatchForTestSuiteRevisionResponse(rsp *http.Response) (*CreateBatchForTestSuiteRevisionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBatchForTestSuiteRevisionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Batch
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseListParameterSweepsResponse parses an HTTP response from a ListParameterSweepsWithResponse call
func ParseListParameterSweepsResponse(rsp *http.Response) (*ListParameterSweepsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListParameterSweepsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListParameterSweepsOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateParameterSweepResponse parses an HTTP response from a CreateParameterSweepWithResponse call
func ParseCreateParameterSweepResponse(rsp *http.Response) (*CreateParameterSweepResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateParameterSweepResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ParameterSweep
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseListSweepAccountsResponse parses an HTTP response from a ListSweepAccountsWithResponse call
func ParseListSweepAccountsResponse(rsp *http.Response) (*ListSweepAccountsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSweepAccountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListUsersOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetParameterSweepResponse parses an HTTP response from a GetParameterSweepWithResponse call
func ParseGetParameterSweepResponse(rsp *http.Response) (*GetParameterSweepResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetParameterSweepResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ParameterSweep
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCancelParameterSweepResponse parses an HTTP response from a CancelParameterSweepWithResponse call
func ParseCancelParameterSweepResponse(rsp *http.Response) (*CancelParameterSweepResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CancelParameterSweepResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListSystemsResponse parses an HTTP response from a ListSystemsWithResponse call
func ParseListSystemsResponse(rsp *http.Response) (*ListSystemsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSystemsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListSystemsOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateSystemResponse parses an HTTP response from a CreateSystemWithResponse call
func ParseCreateSystemResponse(rsp *http.Response) (*CreateSystemResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSystemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest System
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseAddSystemsToExperiencesResponse parses an HTTP response from a AddSystemsToExperiencesWithResponse call
func ParseAddSystemsToExperiencesResponse(rsp *http.Response) (*AddSystemsToExperiencesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddSystemsToExperiencesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveSystemsFromExperiencesResponse parses an HTTP response from a RemoveSystemsFromExperiencesWithResponse call
func ParseRemoveSystemsFromExperiencesResponse(rsp *http.Response) (*RemoveSystemsFromExperiencesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveSystemsFromExperiencesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseArchiveSystemResponse parses an HTTP response from a ArchiveSystemWithResponse call
func ParseArchiveSystemResponse(rsp *http.Response) (*ArchiveSystemResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArchiveSystemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetSystemResponse parses an HTTP response from a GetSystemWithResponse call
func ParseGetSystemResponse(rsp *http.Response) (*GetSystemResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest System
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateSystemResponse parses an HTTP response from a UpdateSystemWithResponse call
func ParseUpdateSystemResponse(rsp *http.Response) (*UpdateSystemResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSystemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest System
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListBuildsForSystemResponse parses an HTTP response from a ListBuildsForSystemWithResponse call
func ParseListBuildsForSystemResponse(rsp *http.Response) (*ListBuildsForSystemResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListBuildsForSystemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListBuildsOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateBuildForSystemResponse parses an HTTP response from a CreateBuildForSystemWithResponse call
func ParseCreateBuildForSystemResponse(rsp *http.Response) (*CreateBuildForSystemResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBuildForSystemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Build
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseGetBuildForSystemResponse parses an HTTP response from a GetBuildForSystemWithResponse call
func ParseGetBuildForSystemResponse(rsp *http.Response) (*GetBuildForSystemResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBuildForSystemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Build
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListExperiencesForSystemResponse parses an HTTP response from a ListExperiencesForSystemWithResponse call
func ParseListExperiencesForSystemResponse(rsp *http.Response) (*ListExperiencesForSystemResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListExperiencesForSystemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListExperiencesOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRemoveSystemFromExperienceResponse parses an HTTP response from a RemoveSystemFromExperienceWithResponse call
func ParseRemoveSystemFromExperienceResponse(rsp *http.Response) (*RemoveSystemFromExperienceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveSystemFromExperienceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAddSystemToExperienceResponse parses an HTTP response from a AddSystemToExperienceWithResponse call
func ParseAddSystemToExperienceResponse(rsp *http.Response) (*AddSystemToExperienceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddSystemToExperienceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveSystemFromMetricsBuildResponse parses an HTTP response from a RemoveSystemFromMetricsBuildWithResponse call
func ParseRemoveSystemFromMetricsBuildResponse(rsp *http.Response) (*RemoveSystemFromMetricsBuildResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveSystemFromMetricsBuildResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAddSystemToMetricsBuildResponse parses an HTTP response from a AddSystemToMetricsBuildWithResponse call
func ParseAddSystemToMetricsBuildResponse(rsp *http.Response) (*AddSystemToMetricsBuildResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddSystemToMetricsBuildResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetQuotaResponse parses an HTTP response from a GetQuotaWithResponse call
func ParseGetQuotaResponse(rsp *http.Response) (*GetQuotaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetQuotaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetQuotaOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseValidateExperienceLocationResponse parses an HTTP response from a ValidateExperienceLocationWithResponse call
func ParseValidateExperienceLocationResponse(rsp *http.Response) (*ValidateExperienceLocationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ValidateExperienceLocationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ExperienceLocationContents
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListViewSessionsResponse parses an HTTP response from a ListViewSessionsWithResponse call
func ParseListViewSessionsResponse(rsp *http.Response) (*ListViewSessionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListViewSessionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListViewObjectsOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateViewSessionResponse parses an HTTP response from a CreateViewSessionWithResponse call
func ParseCreateViewSessionResponse(rsp *http.Response) (*CreateViewSessionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateViewSessionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ViewSessionID
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseGetViewSessionResponse parses an HTTP response from a GetViewSessionWithResponse call
func ParseGetViewSessionResponse(rsp *http.Response) (*GetViewSessionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetViewSessionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ViewObjectAndMetadata
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateViewUpdateResponse parses an HTTP response from a CreateViewUpdateWithResponse call
func ParseCreateViewUpdateResponse(rsp *http.Response) (*CreateViewUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateViewUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ViewSessionUpdate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}
