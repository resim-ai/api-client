// Code generated by mockery v2.53.4. DO NOT EDIT.

package mockapiclient

import (
	context "context"

	api "github.com/resim-ai/api-client/api"

	http "net/http"

	io "io"

	mock "github.com/stretchr/testify/mock"

	uuid "github.com/google/uuid"
)

// ClientInterface is an autogenerated mock type for the ClientInterface type
type ClientInterface struct {
	mock.Mock
}

type ClientInterface_Expecter struct {
	mock *mock.Mock
}

func (_m *ClientInterface) EXPECT() *ClientInterface_Expecter {
	return &ClientInterface_Expecter{mock: &_m.Mock}
}

// AddExperienceTagToExperience provides a mock function with given fields: ctx, projectID, experienceTagID, experienceID, reqEditors
func (_m *ClientInterface) AddExperienceTagToExperience(ctx context.Context, projectID uuid.UUID, experienceTagID uuid.UUID, experienceID uuid.UUID, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, experienceTagID, experienceID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddExperienceTagToExperience")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, experienceTagID, experienceID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, experienceTagID, experienceID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, experienceTagID, experienceID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_AddExperienceTagToExperience_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddExperienceTagToExperience'
type ClientInterface_AddExperienceTagToExperience_Call struct {
	*mock.Call
}

// AddExperienceTagToExperience is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - experienceTagID uuid.UUID
//   - experienceID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) AddExperienceTagToExperience(ctx interface{}, projectID interface{}, experienceTagID interface{}, experienceID interface{}, reqEditors ...interface{}) *ClientInterface_AddExperienceTagToExperience_Call {
	return &ClientInterface_AddExperienceTagToExperience_Call{Call: _e.mock.On("AddExperienceTagToExperience",
		append([]interface{}{ctx, projectID, experienceTagID, experienceID}, reqEditors...)...)}
}

func (_c *ClientInterface_AddExperienceTagToExperience_Call) Run(run func(ctx context.Context, projectID uuid.UUID, experienceTagID uuid.UUID, experienceID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientInterface_AddExperienceTagToExperience_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_AddExperienceTagToExperience_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_AddExperienceTagToExperience_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_AddExperienceTagToExperience_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_AddExperienceTagToExperience_Call {
	_c.Call.Return(run)
	return _c
}

// AddExperiencesToTestSuite provides a mock function with given fields: ctx, projectID, testSuiteID, body, reqEditors
func (_m *ClientInterface) AddExperiencesToTestSuite(ctx context.Context, projectID uuid.UUID, testSuiteID uuid.UUID, body api.SelectExperiencesInput, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, testSuiteID, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddExperiencesToTestSuite")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, api.SelectExperiencesInput, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, testSuiteID, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, api.SelectExperiencesInput, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, testSuiteID, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, api.SelectExperiencesInput, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, testSuiteID, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_AddExperiencesToTestSuite_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddExperiencesToTestSuite'
type ClientInterface_AddExperiencesToTestSuite_Call struct {
	*mock.Call
}

// AddExperiencesToTestSuite is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - testSuiteID uuid.UUID
//   - body api.SelectExperiencesInput
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) AddExperiencesToTestSuite(ctx interface{}, projectID interface{}, testSuiteID interface{}, body interface{}, reqEditors ...interface{}) *ClientInterface_AddExperiencesToTestSuite_Call {
	return &ClientInterface_AddExperiencesToTestSuite_Call{Call: _e.mock.On("AddExperiencesToTestSuite",
		append([]interface{}{ctx, projectID, testSuiteID, body}, reqEditors...)...)}
}

func (_c *ClientInterface_AddExperiencesToTestSuite_Call) Run(run func(ctx context.Context, projectID uuid.UUID, testSuiteID uuid.UUID, body api.SelectExperiencesInput, reqEditors ...api.RequestEditorFn)) *ClientInterface_AddExperiencesToTestSuite_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(api.SelectExperiencesInput), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_AddExperiencesToTestSuite_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_AddExperiencesToTestSuite_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_AddExperiencesToTestSuite_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, api.SelectExperiencesInput, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_AddExperiencesToTestSuite_Call {
	_c.Call.Return(run)
	return _c
}

// AddExperiencesToTestSuiteWithBody provides a mock function with given fields: ctx, projectID, testSuiteID, contentType, body, reqEditors
func (_m *ClientInterface) AddExperiencesToTestSuiteWithBody(ctx context.Context, projectID uuid.UUID, testSuiteID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, testSuiteID, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddExperiencesToTestSuiteWithBody")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, testSuiteID, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, testSuiteID, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, testSuiteID, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_AddExperiencesToTestSuiteWithBody_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddExperiencesToTestSuiteWithBody'
type ClientInterface_AddExperiencesToTestSuiteWithBody_Call struct {
	*mock.Call
}

// AddExperiencesToTestSuiteWithBody is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - testSuiteID uuid.UUID
//   - contentType string
//   - body io.Reader
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) AddExperiencesToTestSuiteWithBody(ctx interface{}, projectID interface{}, testSuiteID interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *ClientInterface_AddExperiencesToTestSuiteWithBody_Call {
	return &ClientInterface_AddExperiencesToTestSuiteWithBody_Call{Call: _e.mock.On("AddExperiencesToTestSuiteWithBody",
		append([]interface{}{ctx, projectID, testSuiteID, contentType, body}, reqEditors...)...)}
}

func (_c *ClientInterface_AddExperiencesToTestSuiteWithBody_Call) Run(run func(ctx context.Context, projectID uuid.UUID, testSuiteID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn)) *ClientInterface_AddExperiencesToTestSuiteWithBody_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(string), args[4].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_AddExperiencesToTestSuiteWithBody_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_AddExperiencesToTestSuiteWithBody_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_AddExperiencesToTestSuiteWithBody_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_AddExperiencesToTestSuiteWithBody_Call {
	_c.Call.Return(run)
	return _c
}

// AddSystemToExperience provides a mock function with given fields: ctx, projectID, systemID, experienceID, reqEditors
func (_m *ClientInterface) AddSystemToExperience(ctx context.Context, projectID uuid.UUID, systemID uuid.UUID, experienceID uuid.UUID, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, systemID, experienceID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddSystemToExperience")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, systemID, experienceID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, systemID, experienceID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, systemID, experienceID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_AddSystemToExperience_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddSystemToExperience'
type ClientInterface_AddSystemToExperience_Call struct {
	*mock.Call
}

// AddSystemToExperience is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - systemID uuid.UUID
//   - experienceID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) AddSystemToExperience(ctx interface{}, projectID interface{}, systemID interface{}, experienceID interface{}, reqEditors ...interface{}) *ClientInterface_AddSystemToExperience_Call {
	return &ClientInterface_AddSystemToExperience_Call{Call: _e.mock.On("AddSystemToExperience",
		append([]interface{}{ctx, projectID, systemID, experienceID}, reqEditors...)...)}
}

func (_c *ClientInterface_AddSystemToExperience_Call) Run(run func(ctx context.Context, projectID uuid.UUID, systemID uuid.UUID, experienceID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientInterface_AddSystemToExperience_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_AddSystemToExperience_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_AddSystemToExperience_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_AddSystemToExperience_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_AddSystemToExperience_Call {
	_c.Call.Return(run)
	return _c
}

// AddSystemToMetricsBuild provides a mock function with given fields: ctx, projectID, systemID, metricsBuildID, reqEditors
func (_m *ClientInterface) AddSystemToMetricsBuild(ctx context.Context, projectID uuid.UUID, systemID uuid.UUID, metricsBuildID uuid.UUID, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, systemID, metricsBuildID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddSystemToMetricsBuild")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, systemID, metricsBuildID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, systemID, metricsBuildID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, systemID, metricsBuildID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_AddSystemToMetricsBuild_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddSystemToMetricsBuild'
type ClientInterface_AddSystemToMetricsBuild_Call struct {
	*mock.Call
}

// AddSystemToMetricsBuild is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - systemID uuid.UUID
//   - metricsBuildID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) AddSystemToMetricsBuild(ctx interface{}, projectID interface{}, systemID interface{}, metricsBuildID interface{}, reqEditors ...interface{}) *ClientInterface_AddSystemToMetricsBuild_Call {
	return &ClientInterface_AddSystemToMetricsBuild_Call{Call: _e.mock.On("AddSystemToMetricsBuild",
		append([]interface{}{ctx, projectID, systemID, metricsBuildID}, reqEditors...)...)}
}

func (_c *ClientInterface_AddSystemToMetricsBuild_Call) Run(run func(ctx context.Context, projectID uuid.UUID, systemID uuid.UUID, metricsBuildID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientInterface_AddSystemToMetricsBuild_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_AddSystemToMetricsBuild_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_AddSystemToMetricsBuild_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_AddSystemToMetricsBuild_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_AddSystemToMetricsBuild_Call {
	_c.Call.Return(run)
	return _c
}

// AddSystemsToExperiences provides a mock function with given fields: ctx, projectID, body, reqEditors
func (_m *ClientInterface) AddSystemsToExperiences(ctx context.Context, projectID uuid.UUID, body api.MutateSystemsToExperienceInput, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddSystemsToExperiences")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, api.MutateSystemsToExperienceInput, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, api.MutateSystemsToExperienceInput, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, api.MutateSystemsToExperienceInput, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_AddSystemsToExperiences_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddSystemsToExperiences'
type ClientInterface_AddSystemsToExperiences_Call struct {
	*mock.Call
}

// AddSystemsToExperiences is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - body api.MutateSystemsToExperienceInput
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) AddSystemsToExperiences(ctx interface{}, projectID interface{}, body interface{}, reqEditors ...interface{}) *ClientInterface_AddSystemsToExperiences_Call {
	return &ClientInterface_AddSystemsToExperiences_Call{Call: _e.mock.On("AddSystemsToExperiences",
		append([]interface{}{ctx, projectID, body}, reqEditors...)...)}
}

func (_c *ClientInterface_AddSystemsToExperiences_Call) Run(run func(ctx context.Context, projectID uuid.UUID, body api.MutateSystemsToExperienceInput, reqEditors ...api.RequestEditorFn)) *ClientInterface_AddSystemsToExperiences_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(api.MutateSystemsToExperienceInput), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_AddSystemsToExperiences_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_AddSystemsToExperiences_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_AddSystemsToExperiences_Call) RunAndReturn(run func(context.Context, uuid.UUID, api.MutateSystemsToExperienceInput, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_AddSystemsToExperiences_Call {
	_c.Call.Return(run)
	return _c
}

// AddSystemsToExperiencesWithBody provides a mock function with given fields: ctx, projectID, contentType, body, reqEditors
func (_m *ClientInterface) AddSystemsToExperiencesWithBody(ctx context.Context, projectID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddSystemsToExperiencesWithBody")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_AddSystemsToExperiencesWithBody_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddSystemsToExperiencesWithBody'
type ClientInterface_AddSystemsToExperiencesWithBody_Call struct {
	*mock.Call
}

// AddSystemsToExperiencesWithBody is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - contentType string
//   - body io.Reader
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) AddSystemsToExperiencesWithBody(ctx interface{}, projectID interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *ClientInterface_AddSystemsToExperiencesWithBody_Call {
	return &ClientInterface_AddSystemsToExperiencesWithBody_Call{Call: _e.mock.On("AddSystemsToExperiencesWithBody",
		append([]interface{}{ctx, projectID, contentType, body}, reqEditors...)...)}
}

func (_c *ClientInterface_AddSystemsToExperiencesWithBody_Call) Run(run func(ctx context.Context, projectID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn)) *ClientInterface_AddSystemsToExperiencesWithBody_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(string), args[3].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_AddSystemsToExperiencesWithBody_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_AddSystemsToExperiencesWithBody_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_AddSystemsToExperiencesWithBody_Call) RunAndReturn(run func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_AddSystemsToExperiencesWithBody_Call {
	_c.Call.Return(run)
	return _c
}

// AddTagsToExperiences provides a mock function with given fields: ctx, projectID, body, reqEditors
func (_m *ClientInterface) AddTagsToExperiences(ctx context.Context, projectID uuid.UUID, body api.AddTagsToExperiencesInput, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddTagsToExperiences")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, api.AddTagsToExperiencesInput, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, api.AddTagsToExperiencesInput, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, api.AddTagsToExperiencesInput, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_AddTagsToExperiences_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddTagsToExperiences'
type ClientInterface_AddTagsToExperiences_Call struct {
	*mock.Call
}

// AddTagsToExperiences is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - body api.AddTagsToExperiencesInput
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) AddTagsToExperiences(ctx interface{}, projectID interface{}, body interface{}, reqEditors ...interface{}) *ClientInterface_AddTagsToExperiences_Call {
	return &ClientInterface_AddTagsToExperiences_Call{Call: _e.mock.On("AddTagsToExperiences",
		append([]interface{}{ctx, projectID, body}, reqEditors...)...)}
}

func (_c *ClientInterface_AddTagsToExperiences_Call) Run(run func(ctx context.Context, projectID uuid.UUID, body api.AddTagsToExperiencesInput, reqEditors ...api.RequestEditorFn)) *ClientInterface_AddTagsToExperiences_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(api.AddTagsToExperiencesInput), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_AddTagsToExperiences_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_AddTagsToExperiences_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_AddTagsToExperiences_Call) RunAndReturn(run func(context.Context, uuid.UUID, api.AddTagsToExperiencesInput, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_AddTagsToExperiences_Call {
	_c.Call.Return(run)
	return _c
}

// AddTagsToExperiencesWithBody provides a mock function with given fields: ctx, projectID, contentType, body, reqEditors
func (_m *ClientInterface) AddTagsToExperiencesWithBody(ctx context.Context, projectID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddTagsToExperiencesWithBody")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_AddTagsToExperiencesWithBody_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddTagsToExperiencesWithBody'
type ClientInterface_AddTagsToExperiencesWithBody_Call struct {
	*mock.Call
}

// AddTagsToExperiencesWithBody is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - contentType string
//   - body io.Reader
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) AddTagsToExperiencesWithBody(ctx interface{}, projectID interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *ClientInterface_AddTagsToExperiencesWithBody_Call {
	return &ClientInterface_AddTagsToExperiencesWithBody_Call{Call: _e.mock.On("AddTagsToExperiencesWithBody",
		append([]interface{}{ctx, projectID, contentType, body}, reqEditors...)...)}
}

func (_c *ClientInterface_AddTagsToExperiencesWithBody_Call) Run(run func(ctx context.Context, projectID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn)) *ClientInterface_AddTagsToExperiencesWithBody_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(string), args[3].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_AddTagsToExperiencesWithBody_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_AddTagsToExperiencesWithBody_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_AddTagsToExperiencesWithBody_Call) RunAndReturn(run func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_AddTagsToExperiencesWithBody_Call {
	_c.Call.Return(run)
	return _c
}

// AddTestSuitesToExperiences provides a mock function with given fields: ctx, projectID, body, reqEditors
func (_m *ClientInterface) AddTestSuitesToExperiences(ctx context.Context, projectID uuid.UUID, body api.AddSuitesToExperiencesInput, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddTestSuitesToExperiences")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, api.AddSuitesToExperiencesInput, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, api.AddSuitesToExperiencesInput, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, api.AddSuitesToExperiencesInput, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_AddTestSuitesToExperiences_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddTestSuitesToExperiences'
type ClientInterface_AddTestSuitesToExperiences_Call struct {
	*mock.Call
}

// AddTestSuitesToExperiences is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - body api.AddSuitesToExperiencesInput
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) AddTestSuitesToExperiences(ctx interface{}, projectID interface{}, body interface{}, reqEditors ...interface{}) *ClientInterface_AddTestSuitesToExperiences_Call {
	return &ClientInterface_AddTestSuitesToExperiences_Call{Call: _e.mock.On("AddTestSuitesToExperiences",
		append([]interface{}{ctx, projectID, body}, reqEditors...)...)}
}

func (_c *ClientInterface_AddTestSuitesToExperiences_Call) Run(run func(ctx context.Context, projectID uuid.UUID, body api.AddSuitesToExperiencesInput, reqEditors ...api.RequestEditorFn)) *ClientInterface_AddTestSuitesToExperiences_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(api.AddSuitesToExperiencesInput), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_AddTestSuitesToExperiences_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_AddTestSuitesToExperiences_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_AddTestSuitesToExperiences_Call) RunAndReturn(run func(context.Context, uuid.UUID, api.AddSuitesToExperiencesInput, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_AddTestSuitesToExperiences_Call {
	_c.Call.Return(run)
	return _c
}

// AddTestSuitesToExperiencesWithBody provides a mock function with given fields: ctx, projectID, contentType, body, reqEditors
func (_m *ClientInterface) AddTestSuitesToExperiencesWithBody(ctx context.Context, projectID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddTestSuitesToExperiencesWithBody")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_AddTestSuitesToExperiencesWithBody_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddTestSuitesToExperiencesWithBody'
type ClientInterface_AddTestSuitesToExperiencesWithBody_Call struct {
	*mock.Call
}

// AddTestSuitesToExperiencesWithBody is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - contentType string
//   - body io.Reader
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) AddTestSuitesToExperiencesWithBody(ctx interface{}, projectID interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *ClientInterface_AddTestSuitesToExperiencesWithBody_Call {
	return &ClientInterface_AddTestSuitesToExperiencesWithBody_Call{Call: _e.mock.On("AddTestSuitesToExperiencesWithBody",
		append([]interface{}{ctx, projectID, contentType, body}, reqEditors...)...)}
}

func (_c *ClientInterface_AddTestSuitesToExperiencesWithBody_Call) Run(run func(ctx context.Context, projectID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn)) *ClientInterface_AddTestSuitesToExperiencesWithBody_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(string), args[3].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_AddTestSuitesToExperiencesWithBody_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_AddTestSuitesToExperiencesWithBody_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_AddTestSuitesToExperiencesWithBody_Call) RunAndReturn(run func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_AddTestSuitesToExperiencesWithBody_Call {
	_c.Call.Return(run)
	return _c
}

// ArchiveExperience provides a mock function with given fields: ctx, projectID, experienceID, reqEditors
func (_m *ClientInterface) ArchiveExperience(ctx context.Context, projectID uuid.UUID, experienceID uuid.UUID, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, experienceID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ArchiveExperience")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, experienceID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, experienceID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, experienceID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_ArchiveExperience_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ArchiveExperience'
type ClientInterface_ArchiveExperience_Call struct {
	*mock.Call
}

// ArchiveExperience is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - experienceID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) ArchiveExperience(ctx interface{}, projectID interface{}, experienceID interface{}, reqEditors ...interface{}) *ClientInterface_ArchiveExperience_Call {
	return &ClientInterface_ArchiveExperience_Call{Call: _e.mock.On("ArchiveExperience",
		append([]interface{}{ctx, projectID, experienceID}, reqEditors...)...)}
}

func (_c *ClientInterface_ArchiveExperience_Call) Run(run func(ctx context.Context, projectID uuid.UUID, experienceID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientInterface_ArchiveExperience_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_ArchiveExperience_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_ArchiveExperience_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_ArchiveExperience_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_ArchiveExperience_Call {
	_c.Call.Return(run)
	return _c
}

// ArchiveProject provides a mock function with given fields: ctx, projectID, reqEditors
func (_m *ClientInterface) ArchiveProject(ctx context.Context, projectID uuid.UUID, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ArchiveProject")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_ArchiveProject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ArchiveProject'
type ClientInterface_ArchiveProject_Call struct {
	*mock.Call
}

// ArchiveProject is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) ArchiveProject(ctx interface{}, projectID interface{}, reqEditors ...interface{}) *ClientInterface_ArchiveProject_Call {
	return &ClientInterface_ArchiveProject_Call{Call: _e.mock.On("ArchiveProject",
		append([]interface{}{ctx, projectID}, reqEditors...)...)}
}

func (_c *ClientInterface_ArchiveProject_Call) Run(run func(ctx context.Context, projectID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientInterface_ArchiveProject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_ArchiveProject_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_ArchiveProject_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_ArchiveProject_Call) RunAndReturn(run func(context.Context, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_ArchiveProject_Call {
	_c.Call.Return(run)
	return _c
}

// ArchiveSystem provides a mock function with given fields: ctx, projectID, systemID, reqEditors
func (_m *ClientInterface) ArchiveSystem(ctx context.Context, projectID uuid.UUID, systemID uuid.UUID, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, systemID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ArchiveSystem")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, systemID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, systemID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, systemID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_ArchiveSystem_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ArchiveSystem'
type ClientInterface_ArchiveSystem_Call struct {
	*mock.Call
}

// ArchiveSystem is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - systemID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) ArchiveSystem(ctx interface{}, projectID interface{}, systemID interface{}, reqEditors ...interface{}) *ClientInterface_ArchiveSystem_Call {
	return &ClientInterface_ArchiveSystem_Call{Call: _e.mock.On("ArchiveSystem",
		append([]interface{}{ctx, projectID, systemID}, reqEditors...)...)}
}

func (_c *ClientInterface_ArchiveSystem_Call) Run(run func(ctx context.Context, projectID uuid.UUID, systemID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientInterface_ArchiveSystem_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_ArchiveSystem_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_ArchiveSystem_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_ArchiveSystem_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_ArchiveSystem_Call {
	_c.Call.Return(run)
	return _c
}

// ArchiveTestSuite provides a mock function with given fields: ctx, projectID, testSuiteID, reqEditors
func (_m *ClientInterface) ArchiveTestSuite(ctx context.Context, projectID uuid.UUID, testSuiteID uuid.UUID, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, testSuiteID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ArchiveTestSuite")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, testSuiteID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, testSuiteID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, testSuiteID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_ArchiveTestSuite_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ArchiveTestSuite'
type ClientInterface_ArchiveTestSuite_Call struct {
	*mock.Call
}

// ArchiveTestSuite is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - testSuiteID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) ArchiveTestSuite(ctx interface{}, projectID interface{}, testSuiteID interface{}, reqEditors ...interface{}) *ClientInterface_ArchiveTestSuite_Call {
	return &ClientInterface_ArchiveTestSuite_Call{Call: _e.mock.On("ArchiveTestSuite",
		append([]interface{}{ctx, projectID, testSuiteID}, reqEditors...)...)}
}

func (_c *ClientInterface_ArchiveTestSuite_Call) Run(run func(ctx context.Context, projectID uuid.UUID, testSuiteID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientInterface_ArchiveTestSuite_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_ArchiveTestSuite_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_ArchiveTestSuite_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_ArchiveTestSuite_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_ArchiveTestSuite_Call {
	_c.Call.Return(run)
	return _c
}

// BulkArchiveExperiences provides a mock function with given fields: ctx, projectID, body, reqEditors
func (_m *ClientInterface) BulkArchiveExperiences(ctx context.Context, projectID uuid.UUID, body api.BulkArchiveExperiencesInput, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BulkArchiveExperiences")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, api.BulkArchiveExperiencesInput, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, api.BulkArchiveExperiencesInput, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, api.BulkArchiveExperiencesInput, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_BulkArchiveExperiences_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BulkArchiveExperiences'
type ClientInterface_BulkArchiveExperiences_Call struct {
	*mock.Call
}

// BulkArchiveExperiences is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - body api.BulkArchiveExperiencesInput
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) BulkArchiveExperiences(ctx interface{}, projectID interface{}, body interface{}, reqEditors ...interface{}) *ClientInterface_BulkArchiveExperiences_Call {
	return &ClientInterface_BulkArchiveExperiences_Call{Call: _e.mock.On("BulkArchiveExperiences",
		append([]interface{}{ctx, projectID, body}, reqEditors...)...)}
}

func (_c *ClientInterface_BulkArchiveExperiences_Call) Run(run func(ctx context.Context, projectID uuid.UUID, body api.BulkArchiveExperiencesInput, reqEditors ...api.RequestEditorFn)) *ClientInterface_BulkArchiveExperiences_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(api.BulkArchiveExperiencesInput), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_BulkArchiveExperiences_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_BulkArchiveExperiences_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_BulkArchiveExperiences_Call) RunAndReturn(run func(context.Context, uuid.UUID, api.BulkArchiveExperiencesInput, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_BulkArchiveExperiences_Call {
	_c.Call.Return(run)
	return _c
}

// BulkArchiveExperiencesWithBody provides a mock function with given fields: ctx, projectID, contentType, body, reqEditors
func (_m *ClientInterface) BulkArchiveExperiencesWithBody(ctx context.Context, projectID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BulkArchiveExperiencesWithBody")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_BulkArchiveExperiencesWithBody_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BulkArchiveExperiencesWithBody'
type ClientInterface_BulkArchiveExperiencesWithBody_Call struct {
	*mock.Call
}

// BulkArchiveExperiencesWithBody is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - contentType string
//   - body io.Reader
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) BulkArchiveExperiencesWithBody(ctx interface{}, projectID interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *ClientInterface_BulkArchiveExperiencesWithBody_Call {
	return &ClientInterface_BulkArchiveExperiencesWithBody_Call{Call: _e.mock.On("BulkArchiveExperiencesWithBody",
		append([]interface{}{ctx, projectID, contentType, body}, reqEditors...)...)}
}

func (_c *ClientInterface_BulkArchiveExperiencesWithBody_Call) Run(run func(ctx context.Context, projectID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn)) *ClientInterface_BulkArchiveExperiencesWithBody_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(string), args[3].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_BulkArchiveExperiencesWithBody_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_BulkArchiveExperiencesWithBody_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_BulkArchiveExperiencesWithBody_Call) RunAndReturn(run func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_BulkArchiveExperiencesWithBody_Call {
	_c.Call.Return(run)
	return _c
}

// CancelBatch provides a mock function with given fields: ctx, projectID, batchID, reqEditors
func (_m *ClientInterface) CancelBatch(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, batchID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CancelBatch")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, batchID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, batchID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, batchID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_CancelBatch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CancelBatch'
type ClientInterface_CancelBatch_Call struct {
	*mock.Call
}

// CancelBatch is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - batchID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) CancelBatch(ctx interface{}, projectID interface{}, batchID interface{}, reqEditors ...interface{}) *ClientInterface_CancelBatch_Call {
	return &ClientInterface_CancelBatch_Call{Call: _e.mock.On("CancelBatch",
		append([]interface{}{ctx, projectID, batchID}, reqEditors...)...)}
}

func (_c *ClientInterface_CancelBatch_Call) Run(run func(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientInterface_CancelBatch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_CancelBatch_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_CancelBatch_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_CancelBatch_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_CancelBatch_Call {
	_c.Call.Return(run)
	return _c
}

// CancelParameterSweep provides a mock function with given fields: ctx, projectID, sweepID, reqEditors
func (_m *ClientInterface) CancelParameterSweep(ctx context.Context, projectID uuid.UUID, sweepID uuid.UUID, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, sweepID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CancelParameterSweep")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, sweepID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, sweepID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, sweepID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_CancelParameterSweep_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CancelParameterSweep'
type ClientInterface_CancelParameterSweep_Call struct {
	*mock.Call
}

// CancelParameterSweep is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - sweepID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) CancelParameterSweep(ctx interface{}, projectID interface{}, sweepID interface{}, reqEditors ...interface{}) *ClientInterface_CancelParameterSweep_Call {
	return &ClientInterface_CancelParameterSweep_Call{Call: _e.mock.On("CancelParameterSweep",
		append([]interface{}{ctx, projectID, sweepID}, reqEditors...)...)}
}

func (_c *ClientInterface_CancelParameterSweep_Call) Run(run func(ctx context.Context, projectID uuid.UUID, sweepID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientInterface_CancelParameterSweep_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_CancelParameterSweep_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_CancelParameterSweep_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_CancelParameterSweep_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_CancelParameterSweep_Call {
	_c.Call.Return(run)
	return _c
}

// CompareBatches provides a mock function with given fields: ctx, projectID, batchID, otherBatchID, params, reqEditors
func (_m *ClientInterface) CompareBatches(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, otherBatchID uuid.UUID, params *api.CompareBatchesParams, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, batchID, otherBatchID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CompareBatches")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, *api.CompareBatchesParams, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, batchID, otherBatchID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, *api.CompareBatchesParams, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, batchID, otherBatchID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, *api.CompareBatchesParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, batchID, otherBatchID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_CompareBatches_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CompareBatches'
type ClientInterface_CompareBatches_Call struct {
	*mock.Call
}

// CompareBatches is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - batchID uuid.UUID
//   - otherBatchID uuid.UUID
//   - params *api.CompareBatchesParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) CompareBatches(ctx interface{}, projectID interface{}, batchID interface{}, otherBatchID interface{}, params interface{}, reqEditors ...interface{}) *ClientInterface_CompareBatches_Call {
	return &ClientInterface_CompareBatches_Call{Call: _e.mock.On("CompareBatches",
		append([]interface{}{ctx, projectID, batchID, otherBatchID, params}, reqEditors...)...)}
}

func (_c *ClientInterface_CompareBatches_Call) Run(run func(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, otherBatchID uuid.UUID, params *api.CompareBatchesParams, reqEditors ...api.RequestEditorFn)) *ClientInterface_CompareBatches_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(uuid.UUID), args[4].(*api.CompareBatchesParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_CompareBatches_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_CompareBatches_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_CompareBatches_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, *api.CompareBatchesParams, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_CompareBatches_Call {
	_c.Call.Return(run)
	return _c
}

// CreateBatch provides a mock function with given fields: ctx, projectID, body, reqEditors
func (_m *ClientInterface) CreateBatch(ctx context.Context, projectID uuid.UUID, body api.BatchInput, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateBatch")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, api.BatchInput, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, api.BatchInput, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, api.BatchInput, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_CreateBatch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateBatch'
type ClientInterface_CreateBatch_Call struct {
	*mock.Call
}

// CreateBatch is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - body api.BatchInput
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) CreateBatch(ctx interface{}, projectID interface{}, body interface{}, reqEditors ...interface{}) *ClientInterface_CreateBatch_Call {
	return &ClientInterface_CreateBatch_Call{Call: _e.mock.On("CreateBatch",
		append([]interface{}{ctx, projectID, body}, reqEditors...)...)}
}

func (_c *ClientInterface_CreateBatch_Call) Run(run func(ctx context.Context, projectID uuid.UUID, body api.BatchInput, reqEditors ...api.RequestEditorFn)) *ClientInterface_CreateBatch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(api.BatchInput), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_CreateBatch_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_CreateBatch_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_CreateBatch_Call) RunAndReturn(run func(context.Context, uuid.UUID, api.BatchInput, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_CreateBatch_Call {
	_c.Call.Return(run)
	return _c
}

// CreateBatchForTestSuite provides a mock function with given fields: ctx, projectID, testSuiteID, body, reqEditors
func (_m *ClientInterface) CreateBatchForTestSuite(ctx context.Context, projectID uuid.UUID, testSuiteID uuid.UUID, body api.TestSuiteBatchInput, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, testSuiteID, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateBatchForTestSuite")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, api.TestSuiteBatchInput, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, testSuiteID, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, api.TestSuiteBatchInput, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, testSuiteID, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, api.TestSuiteBatchInput, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, testSuiteID, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_CreateBatchForTestSuite_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateBatchForTestSuite'
type ClientInterface_CreateBatchForTestSuite_Call struct {
	*mock.Call
}

// CreateBatchForTestSuite is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - testSuiteID uuid.UUID
//   - body api.TestSuiteBatchInput
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) CreateBatchForTestSuite(ctx interface{}, projectID interface{}, testSuiteID interface{}, body interface{}, reqEditors ...interface{}) *ClientInterface_CreateBatchForTestSuite_Call {
	return &ClientInterface_CreateBatchForTestSuite_Call{Call: _e.mock.On("CreateBatchForTestSuite",
		append([]interface{}{ctx, projectID, testSuiteID, body}, reqEditors...)...)}
}

func (_c *ClientInterface_CreateBatchForTestSuite_Call) Run(run func(ctx context.Context, projectID uuid.UUID, testSuiteID uuid.UUID, body api.TestSuiteBatchInput, reqEditors ...api.RequestEditorFn)) *ClientInterface_CreateBatchForTestSuite_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(api.TestSuiteBatchInput), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_CreateBatchForTestSuite_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_CreateBatchForTestSuite_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_CreateBatchForTestSuite_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, api.TestSuiteBatchInput, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_CreateBatchForTestSuite_Call {
	_c.Call.Return(run)
	return _c
}

// CreateBatchForTestSuiteRevision provides a mock function with given fields: ctx, projectID, testSuiteID, revision, body, reqEditors
func (_m *ClientInterface) CreateBatchForTestSuiteRevision(ctx context.Context, projectID uuid.UUID, testSuiteID uuid.UUID, revision int32, body api.TestSuiteBatchInput, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, testSuiteID, revision, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateBatchForTestSuiteRevision")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, int32, api.TestSuiteBatchInput, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, testSuiteID, revision, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, int32, api.TestSuiteBatchInput, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, testSuiteID, revision, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, int32, api.TestSuiteBatchInput, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, testSuiteID, revision, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_CreateBatchForTestSuiteRevision_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateBatchForTestSuiteRevision'
type ClientInterface_CreateBatchForTestSuiteRevision_Call struct {
	*mock.Call
}

// CreateBatchForTestSuiteRevision is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - testSuiteID uuid.UUID
//   - revision int32
//   - body api.TestSuiteBatchInput
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) CreateBatchForTestSuiteRevision(ctx interface{}, projectID interface{}, testSuiteID interface{}, revision interface{}, body interface{}, reqEditors ...interface{}) *ClientInterface_CreateBatchForTestSuiteRevision_Call {
	return &ClientInterface_CreateBatchForTestSuiteRevision_Call{Call: _e.mock.On("CreateBatchForTestSuiteRevision",
		append([]interface{}{ctx, projectID, testSuiteID, revision, body}, reqEditors...)...)}
}

func (_c *ClientInterface_CreateBatchForTestSuiteRevision_Call) Run(run func(ctx context.Context, projectID uuid.UUID, testSuiteID uuid.UUID, revision int32, body api.TestSuiteBatchInput, reqEditors ...api.RequestEditorFn)) *ClientInterface_CreateBatchForTestSuiteRevision_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(int32), args[4].(api.TestSuiteBatchInput), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_CreateBatchForTestSuiteRevision_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_CreateBatchForTestSuiteRevision_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_CreateBatchForTestSuiteRevision_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, int32, api.TestSuiteBatchInput, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_CreateBatchForTestSuiteRevision_Call {
	_c.Call.Return(run)
	return _c
}

// CreateBatchForTestSuiteRevisionWithBody provides a mock function with given fields: ctx, projectID, testSuiteID, revision, contentType, body, reqEditors
func (_m *ClientInterface) CreateBatchForTestSuiteRevisionWithBody(ctx context.Context, projectID uuid.UUID, testSuiteID uuid.UUID, revision int32, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, testSuiteID, revision, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateBatchForTestSuiteRevisionWithBody")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, int32, string, io.Reader, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, testSuiteID, revision, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, int32, string, io.Reader, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, testSuiteID, revision, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, int32, string, io.Reader, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, testSuiteID, revision, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_CreateBatchForTestSuiteRevisionWithBody_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateBatchForTestSuiteRevisionWithBody'
type ClientInterface_CreateBatchForTestSuiteRevisionWithBody_Call struct {
	*mock.Call
}

// CreateBatchForTestSuiteRevisionWithBody is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - testSuiteID uuid.UUID
//   - revision int32
//   - contentType string
//   - body io.Reader
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) CreateBatchForTestSuiteRevisionWithBody(ctx interface{}, projectID interface{}, testSuiteID interface{}, revision interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *ClientInterface_CreateBatchForTestSuiteRevisionWithBody_Call {
	return &ClientInterface_CreateBatchForTestSuiteRevisionWithBody_Call{Call: _e.mock.On("CreateBatchForTestSuiteRevisionWithBody",
		append([]interface{}{ctx, projectID, testSuiteID, revision, contentType, body}, reqEditors...)...)}
}

func (_c *ClientInterface_CreateBatchForTestSuiteRevisionWithBody_Call) Run(run func(ctx context.Context, projectID uuid.UUID, testSuiteID uuid.UUID, revision int32, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn)) *ClientInterface_CreateBatchForTestSuiteRevisionWithBody_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-6)
		for i, a := range args[6:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(int32), args[4].(string), args[5].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_CreateBatchForTestSuiteRevisionWithBody_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_CreateBatchForTestSuiteRevisionWithBody_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_CreateBatchForTestSuiteRevisionWithBody_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, int32, string, io.Reader, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_CreateBatchForTestSuiteRevisionWithBody_Call {
	_c.Call.Return(run)
	return _c
}

// CreateBatchForTestSuiteWithBody provides a mock function with given fields: ctx, projectID, testSuiteID, contentType, body, reqEditors
func (_m *ClientInterface) CreateBatchForTestSuiteWithBody(ctx context.Context, projectID uuid.UUID, testSuiteID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, testSuiteID, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateBatchForTestSuiteWithBody")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, testSuiteID, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, testSuiteID, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, testSuiteID, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_CreateBatchForTestSuiteWithBody_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateBatchForTestSuiteWithBody'
type ClientInterface_CreateBatchForTestSuiteWithBody_Call struct {
	*mock.Call
}

// CreateBatchForTestSuiteWithBody is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - testSuiteID uuid.UUID
//   - contentType string
//   - body io.Reader
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) CreateBatchForTestSuiteWithBody(ctx interface{}, projectID interface{}, testSuiteID interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *ClientInterface_CreateBatchForTestSuiteWithBody_Call {
	return &ClientInterface_CreateBatchForTestSuiteWithBody_Call{Call: _e.mock.On("CreateBatchForTestSuiteWithBody",
		append([]interface{}{ctx, projectID, testSuiteID, contentType, body}, reqEditors...)...)}
}

func (_c *ClientInterface_CreateBatchForTestSuiteWithBody_Call) Run(run func(ctx context.Context, projectID uuid.UUID, testSuiteID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn)) *ClientInterface_CreateBatchForTestSuiteWithBody_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(string), args[4].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_CreateBatchForTestSuiteWithBody_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_CreateBatchForTestSuiteWithBody_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_CreateBatchForTestSuiteWithBody_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_CreateBatchForTestSuiteWithBody_Call {
	_c.Call.Return(run)
	return _c
}

// CreateBatchWithBody provides a mock function with given fields: ctx, projectID, contentType, body, reqEditors
func (_m *ClientInterface) CreateBatchWithBody(ctx context.Context, projectID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateBatchWithBody")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_CreateBatchWithBody_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateBatchWithBody'
type ClientInterface_CreateBatchWithBody_Call struct {
	*mock.Call
}

// CreateBatchWithBody is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - contentType string
//   - body io.Reader
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) CreateBatchWithBody(ctx interface{}, projectID interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *ClientInterface_CreateBatchWithBody_Call {
	return &ClientInterface_CreateBatchWithBody_Call{Call: _e.mock.On("CreateBatchWithBody",
		append([]interface{}{ctx, projectID, contentType, body}, reqEditors...)...)}
}

func (_c *ClientInterface_CreateBatchWithBody_Call) Run(run func(ctx context.Context, projectID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn)) *ClientInterface_CreateBatchWithBody_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(string), args[3].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_CreateBatchWithBody_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_CreateBatchWithBody_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_CreateBatchWithBody_Call) RunAndReturn(run func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_CreateBatchWithBody_Call {
	_c.Call.Return(run)
	return _c
}

// CreateBranchForProject provides a mock function with given fields: ctx, projectID, body, reqEditors
func (_m *ClientInterface) CreateBranchForProject(ctx context.Context, projectID uuid.UUID, body api.CreateBranchInput, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateBranchForProject")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, api.CreateBranchInput, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, api.CreateBranchInput, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, api.CreateBranchInput, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_CreateBranchForProject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateBranchForProject'
type ClientInterface_CreateBranchForProject_Call struct {
	*mock.Call
}

// CreateBranchForProject is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - body api.CreateBranchInput
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) CreateBranchForProject(ctx interface{}, projectID interface{}, body interface{}, reqEditors ...interface{}) *ClientInterface_CreateBranchForProject_Call {
	return &ClientInterface_CreateBranchForProject_Call{Call: _e.mock.On("CreateBranchForProject",
		append([]interface{}{ctx, projectID, body}, reqEditors...)...)}
}

func (_c *ClientInterface_CreateBranchForProject_Call) Run(run func(ctx context.Context, projectID uuid.UUID, body api.CreateBranchInput, reqEditors ...api.RequestEditorFn)) *ClientInterface_CreateBranchForProject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(api.CreateBranchInput), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_CreateBranchForProject_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_CreateBranchForProject_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_CreateBranchForProject_Call) RunAndReturn(run func(context.Context, uuid.UUID, api.CreateBranchInput, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_CreateBranchForProject_Call {
	_c.Call.Return(run)
	return _c
}

// CreateBranchForProjectWithBody provides a mock function with given fields: ctx, projectID, contentType, body, reqEditors
func (_m *ClientInterface) CreateBranchForProjectWithBody(ctx context.Context, projectID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateBranchForProjectWithBody")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_CreateBranchForProjectWithBody_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateBranchForProjectWithBody'
type ClientInterface_CreateBranchForProjectWithBody_Call struct {
	*mock.Call
}

// CreateBranchForProjectWithBody is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - contentType string
//   - body io.Reader
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) CreateBranchForProjectWithBody(ctx interface{}, projectID interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *ClientInterface_CreateBranchForProjectWithBody_Call {
	return &ClientInterface_CreateBranchForProjectWithBody_Call{Call: _e.mock.On("CreateBranchForProjectWithBody",
		append([]interface{}{ctx, projectID, contentType, body}, reqEditors...)...)}
}

func (_c *ClientInterface_CreateBranchForProjectWithBody_Call) Run(run func(ctx context.Context, projectID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn)) *ClientInterface_CreateBranchForProjectWithBody_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(string), args[3].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_CreateBranchForProjectWithBody_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_CreateBranchForProjectWithBody_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_CreateBranchForProjectWithBody_Call) RunAndReturn(run func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_CreateBranchForProjectWithBody_Call {
	_c.Call.Return(run)
	return _c
}

// CreateBuildForBranch provides a mock function with given fields: ctx, projectID, branchID, body, reqEditors
func (_m *ClientInterface) CreateBuildForBranch(ctx context.Context, projectID uuid.UUID, branchID uuid.UUID, body api.CreateBuildForBranchInput, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, branchID, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateBuildForBranch")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, api.CreateBuildForBranchInput, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, branchID, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, api.CreateBuildForBranchInput, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, branchID, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, api.CreateBuildForBranchInput, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, branchID, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_CreateBuildForBranch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateBuildForBranch'
type ClientInterface_CreateBuildForBranch_Call struct {
	*mock.Call
}

// CreateBuildForBranch is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - branchID uuid.UUID
//   - body api.CreateBuildForBranchInput
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) CreateBuildForBranch(ctx interface{}, projectID interface{}, branchID interface{}, body interface{}, reqEditors ...interface{}) *ClientInterface_CreateBuildForBranch_Call {
	return &ClientInterface_CreateBuildForBranch_Call{Call: _e.mock.On("CreateBuildForBranch",
		append([]interface{}{ctx, projectID, branchID, body}, reqEditors...)...)}
}

func (_c *ClientInterface_CreateBuildForBranch_Call) Run(run func(ctx context.Context, projectID uuid.UUID, branchID uuid.UUID, body api.CreateBuildForBranchInput, reqEditors ...api.RequestEditorFn)) *ClientInterface_CreateBuildForBranch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(api.CreateBuildForBranchInput), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_CreateBuildForBranch_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_CreateBuildForBranch_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_CreateBuildForBranch_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, api.CreateBuildForBranchInput, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_CreateBuildForBranch_Call {
	_c.Call.Return(run)
	return _c
}

// CreateBuildForBranchWithBody provides a mock function with given fields: ctx, projectID, branchID, contentType, body, reqEditors
func (_m *ClientInterface) CreateBuildForBranchWithBody(ctx context.Context, projectID uuid.UUID, branchID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, branchID, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateBuildForBranchWithBody")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, branchID, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, branchID, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, branchID, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_CreateBuildForBranchWithBody_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateBuildForBranchWithBody'
type ClientInterface_CreateBuildForBranchWithBody_Call struct {
	*mock.Call
}

// CreateBuildForBranchWithBody is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - branchID uuid.UUID
//   - contentType string
//   - body io.Reader
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) CreateBuildForBranchWithBody(ctx interface{}, projectID interface{}, branchID interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *ClientInterface_CreateBuildForBranchWithBody_Call {
	return &ClientInterface_CreateBuildForBranchWithBody_Call{Call: _e.mock.On("CreateBuildForBranchWithBody",
		append([]interface{}{ctx, projectID, branchID, contentType, body}, reqEditors...)...)}
}

func (_c *ClientInterface_CreateBuildForBranchWithBody_Call) Run(run func(ctx context.Context, projectID uuid.UUID, branchID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn)) *ClientInterface_CreateBuildForBranchWithBody_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(string), args[4].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_CreateBuildForBranchWithBody_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_CreateBuildForBranchWithBody_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_CreateBuildForBranchWithBody_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_CreateBuildForBranchWithBody_Call {
	_c.Call.Return(run)
	return _c
}

// CreateBuildForSystem provides a mock function with given fields: ctx, projectID, systemID, body, reqEditors
func (_m *ClientInterface) CreateBuildForSystem(ctx context.Context, projectID uuid.UUID, systemID uuid.UUID, body api.CreateBuildForSystemInput, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, systemID, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateBuildForSystem")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, api.CreateBuildForSystemInput, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, systemID, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, api.CreateBuildForSystemInput, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, systemID, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, api.CreateBuildForSystemInput, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, systemID, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_CreateBuildForSystem_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateBuildForSystem'
type ClientInterface_CreateBuildForSystem_Call struct {
	*mock.Call
}

// CreateBuildForSystem is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - systemID uuid.UUID
//   - body api.CreateBuildForSystemInput
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) CreateBuildForSystem(ctx interface{}, projectID interface{}, systemID interface{}, body interface{}, reqEditors ...interface{}) *ClientInterface_CreateBuildForSystem_Call {
	return &ClientInterface_CreateBuildForSystem_Call{Call: _e.mock.On("CreateBuildForSystem",
		append([]interface{}{ctx, projectID, systemID, body}, reqEditors...)...)}
}

func (_c *ClientInterface_CreateBuildForSystem_Call) Run(run func(ctx context.Context, projectID uuid.UUID, systemID uuid.UUID, body api.CreateBuildForSystemInput, reqEditors ...api.RequestEditorFn)) *ClientInterface_CreateBuildForSystem_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(api.CreateBuildForSystemInput), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_CreateBuildForSystem_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_CreateBuildForSystem_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_CreateBuildForSystem_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, api.CreateBuildForSystemInput, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_CreateBuildForSystem_Call {
	_c.Call.Return(run)
	return _c
}

// CreateBuildForSystemWithBody provides a mock function with given fields: ctx, projectID, systemID, contentType, body, reqEditors
func (_m *ClientInterface) CreateBuildForSystemWithBody(ctx context.Context, projectID uuid.UUID, systemID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, systemID, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateBuildForSystemWithBody")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, systemID, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, systemID, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, systemID, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_CreateBuildForSystemWithBody_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateBuildForSystemWithBody'
type ClientInterface_CreateBuildForSystemWithBody_Call struct {
	*mock.Call
}

// CreateBuildForSystemWithBody is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - systemID uuid.UUID
//   - contentType string
//   - body io.Reader
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) CreateBuildForSystemWithBody(ctx interface{}, projectID interface{}, systemID interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *ClientInterface_CreateBuildForSystemWithBody_Call {
	return &ClientInterface_CreateBuildForSystemWithBody_Call{Call: _e.mock.On("CreateBuildForSystemWithBody",
		append([]interface{}{ctx, projectID, systemID, contentType, body}, reqEditors...)...)}
}

func (_c *ClientInterface_CreateBuildForSystemWithBody_Call) Run(run func(ctx context.Context, projectID uuid.UUID, systemID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn)) *ClientInterface_CreateBuildForSystemWithBody_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(string), args[4].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_CreateBuildForSystemWithBody_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_CreateBuildForSystemWithBody_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_CreateBuildForSystemWithBody_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_CreateBuildForSystemWithBody_Call {
	_c.Call.Return(run)
	return _c
}

// CreateExperience provides a mock function with given fields: ctx, projectID, body, reqEditors
func (_m *ClientInterface) CreateExperience(ctx context.Context, projectID uuid.UUID, body api.CreateExperienceInput, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateExperience")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, api.CreateExperienceInput, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, api.CreateExperienceInput, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, api.CreateExperienceInput, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_CreateExperience_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateExperience'
type ClientInterface_CreateExperience_Call struct {
	*mock.Call
}

// CreateExperience is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - body api.CreateExperienceInput
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) CreateExperience(ctx interface{}, projectID interface{}, body interface{}, reqEditors ...interface{}) *ClientInterface_CreateExperience_Call {
	return &ClientInterface_CreateExperience_Call{Call: _e.mock.On("CreateExperience",
		append([]interface{}{ctx, projectID, body}, reqEditors...)...)}
}

func (_c *ClientInterface_CreateExperience_Call) Run(run func(ctx context.Context, projectID uuid.UUID, body api.CreateExperienceInput, reqEditors ...api.RequestEditorFn)) *ClientInterface_CreateExperience_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(api.CreateExperienceInput), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_CreateExperience_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_CreateExperience_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_CreateExperience_Call) RunAndReturn(run func(context.Context, uuid.UUID, api.CreateExperienceInput, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_CreateExperience_Call {
	_c.Call.Return(run)
	return _c
}

// CreateExperienceTag provides a mock function with given fields: ctx, projectID, body, reqEditors
func (_m *ClientInterface) CreateExperienceTag(ctx context.Context, projectID uuid.UUID, body api.CreateExperienceTagInput, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateExperienceTag")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, api.CreateExperienceTagInput, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, api.CreateExperienceTagInput, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, api.CreateExperienceTagInput, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_CreateExperienceTag_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateExperienceTag'
type ClientInterface_CreateExperienceTag_Call struct {
	*mock.Call
}

// CreateExperienceTag is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - body api.CreateExperienceTagInput
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) CreateExperienceTag(ctx interface{}, projectID interface{}, body interface{}, reqEditors ...interface{}) *ClientInterface_CreateExperienceTag_Call {
	return &ClientInterface_CreateExperienceTag_Call{Call: _e.mock.On("CreateExperienceTag",
		append([]interface{}{ctx, projectID, body}, reqEditors...)...)}
}

func (_c *ClientInterface_CreateExperienceTag_Call) Run(run func(ctx context.Context, projectID uuid.UUID, body api.CreateExperienceTagInput, reqEditors ...api.RequestEditorFn)) *ClientInterface_CreateExperienceTag_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(api.CreateExperienceTagInput), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_CreateExperienceTag_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_CreateExperienceTag_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_CreateExperienceTag_Call) RunAndReturn(run func(context.Context, uuid.UUID, api.CreateExperienceTagInput, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_CreateExperienceTag_Call {
	_c.Call.Return(run)
	return _c
}

// CreateExperienceTagWithBody provides a mock function with given fields: ctx, projectID, contentType, body, reqEditors
func (_m *ClientInterface) CreateExperienceTagWithBody(ctx context.Context, projectID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateExperienceTagWithBody")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_CreateExperienceTagWithBody_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateExperienceTagWithBody'
type ClientInterface_CreateExperienceTagWithBody_Call struct {
	*mock.Call
}

// CreateExperienceTagWithBody is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - contentType string
//   - body io.Reader
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) CreateExperienceTagWithBody(ctx interface{}, projectID interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *ClientInterface_CreateExperienceTagWithBody_Call {
	return &ClientInterface_CreateExperienceTagWithBody_Call{Call: _e.mock.On("CreateExperienceTagWithBody",
		append([]interface{}{ctx, projectID, contentType, body}, reqEditors...)...)}
}

func (_c *ClientInterface_CreateExperienceTagWithBody_Call) Run(run func(ctx context.Context, projectID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn)) *ClientInterface_CreateExperienceTagWithBody_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(string), args[3].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_CreateExperienceTagWithBody_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_CreateExperienceTagWithBody_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_CreateExperienceTagWithBody_Call) RunAndReturn(run func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_CreateExperienceTagWithBody_Call {
	_c.Call.Return(run)
	return _c
}

// CreateExperienceWithBody provides a mock function with given fields: ctx, projectID, contentType, body, reqEditors
func (_m *ClientInterface) CreateExperienceWithBody(ctx context.Context, projectID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateExperienceWithBody")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_CreateExperienceWithBody_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateExperienceWithBody'
type ClientInterface_CreateExperienceWithBody_Call struct {
	*mock.Call
}

// CreateExperienceWithBody is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - contentType string
//   - body io.Reader
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) CreateExperienceWithBody(ctx interface{}, projectID interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *ClientInterface_CreateExperienceWithBody_Call {
	return &ClientInterface_CreateExperienceWithBody_Call{Call: _e.mock.On("CreateExperienceWithBody",
		append([]interface{}{ctx, projectID, contentType, body}, reqEditors...)...)}
}

func (_c *ClientInterface_CreateExperienceWithBody_Call) Run(run func(ctx context.Context, projectID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn)) *ClientInterface_CreateExperienceWithBody_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(string), args[3].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_CreateExperienceWithBody_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_CreateExperienceWithBody_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_CreateExperienceWithBody_Call) RunAndReturn(run func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_CreateExperienceWithBody_Call {
	_c.Call.Return(run)
	return _c
}

// CreateMetricsBuild provides a mock function with given fields: ctx, projectID, body, reqEditors
func (_m *ClientInterface) CreateMetricsBuild(ctx context.Context, projectID uuid.UUID, body api.CreateMetricsBuildInput, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateMetricsBuild")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, api.CreateMetricsBuildInput, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, api.CreateMetricsBuildInput, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, api.CreateMetricsBuildInput, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_CreateMetricsBuild_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateMetricsBuild'
type ClientInterface_CreateMetricsBuild_Call struct {
	*mock.Call
}

// CreateMetricsBuild is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - body api.CreateMetricsBuildInput
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) CreateMetricsBuild(ctx interface{}, projectID interface{}, body interface{}, reqEditors ...interface{}) *ClientInterface_CreateMetricsBuild_Call {
	return &ClientInterface_CreateMetricsBuild_Call{Call: _e.mock.On("CreateMetricsBuild",
		append([]interface{}{ctx, projectID, body}, reqEditors...)...)}
}

func (_c *ClientInterface_CreateMetricsBuild_Call) Run(run func(ctx context.Context, projectID uuid.UUID, body api.CreateMetricsBuildInput, reqEditors ...api.RequestEditorFn)) *ClientInterface_CreateMetricsBuild_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(api.CreateMetricsBuildInput), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_CreateMetricsBuild_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_CreateMetricsBuild_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_CreateMetricsBuild_Call) RunAndReturn(run func(context.Context, uuid.UUID, api.CreateMetricsBuildInput, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_CreateMetricsBuild_Call {
	_c.Call.Return(run)
	return _c
}

// CreateMetricsBuildWithBody provides a mock function with given fields: ctx, projectID, contentType, body, reqEditors
func (_m *ClientInterface) CreateMetricsBuildWithBody(ctx context.Context, projectID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateMetricsBuildWithBody")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_CreateMetricsBuildWithBody_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateMetricsBuildWithBody'
type ClientInterface_CreateMetricsBuildWithBody_Call struct {
	*mock.Call
}

// CreateMetricsBuildWithBody is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - contentType string
//   - body io.Reader
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) CreateMetricsBuildWithBody(ctx interface{}, projectID interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *ClientInterface_CreateMetricsBuildWithBody_Call {
	return &ClientInterface_CreateMetricsBuildWithBody_Call{Call: _e.mock.On("CreateMetricsBuildWithBody",
		append([]interface{}{ctx, projectID, contentType, body}, reqEditors...)...)}
}

func (_c *ClientInterface_CreateMetricsBuildWithBody_Call) Run(run func(ctx context.Context, projectID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn)) *ClientInterface_CreateMetricsBuildWithBody_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(string), args[3].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_CreateMetricsBuildWithBody_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_CreateMetricsBuildWithBody_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_CreateMetricsBuildWithBody_Call) RunAndReturn(run func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_CreateMetricsBuildWithBody_Call {
	_c.Call.Return(run)
	return _c
}

// CreateParameterSweep provides a mock function with given fields: ctx, projectID, body, reqEditors
func (_m *ClientInterface) CreateParameterSweep(ctx context.Context, projectID uuid.UUID, body api.ParameterSweepInput, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateParameterSweep")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, api.ParameterSweepInput, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, api.ParameterSweepInput, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, api.ParameterSweepInput, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_CreateParameterSweep_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateParameterSweep'
type ClientInterface_CreateParameterSweep_Call struct {
	*mock.Call
}

// CreateParameterSweep is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - body api.ParameterSweepInput
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) CreateParameterSweep(ctx interface{}, projectID interface{}, body interface{}, reqEditors ...interface{}) *ClientInterface_CreateParameterSweep_Call {
	return &ClientInterface_CreateParameterSweep_Call{Call: _e.mock.On("CreateParameterSweep",
		append([]interface{}{ctx, projectID, body}, reqEditors...)...)}
}

func (_c *ClientInterface_CreateParameterSweep_Call) Run(run func(ctx context.Context, projectID uuid.UUID, body api.ParameterSweepInput, reqEditors ...api.RequestEditorFn)) *ClientInterface_CreateParameterSweep_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(api.ParameterSweepInput), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_CreateParameterSweep_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_CreateParameterSweep_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_CreateParameterSweep_Call) RunAndReturn(run func(context.Context, uuid.UUID, api.ParameterSweepInput, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_CreateParameterSweep_Call {
	_c.Call.Return(run)
	return _c
}

// CreateParameterSweepWithBody provides a mock function with given fields: ctx, projectID, contentType, body, reqEditors
func (_m *ClientInterface) CreateParameterSweepWithBody(ctx context.Context, projectID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateParameterSweepWithBody")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_CreateParameterSweepWithBody_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateParameterSweepWithBody'
type ClientInterface_CreateParameterSweepWithBody_Call struct {
	*mock.Call
}

// CreateParameterSweepWithBody is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - contentType string
//   - body io.Reader
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) CreateParameterSweepWithBody(ctx interface{}, projectID interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *ClientInterface_CreateParameterSweepWithBody_Call {
	return &ClientInterface_CreateParameterSweepWithBody_Call{Call: _e.mock.On("CreateParameterSweepWithBody",
		append([]interface{}{ctx, projectID, contentType, body}, reqEditors...)...)}
}

func (_c *ClientInterface_CreateParameterSweepWithBody_Call) Run(run func(ctx context.Context, projectID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn)) *ClientInterface_CreateParameterSweepWithBody_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(string), args[3].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_CreateParameterSweepWithBody_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_CreateParameterSweepWithBody_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_CreateParameterSweepWithBody_Call) RunAndReturn(run func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_CreateParameterSweepWithBody_Call {
	_c.Call.Return(run)
	return _c
}

// CreateProject provides a mock function with given fields: ctx, body, reqEditors
func (_m *ClientInterface) CreateProject(ctx context.Context, body api.CreateProjectInput, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateProject")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, api.CreateProjectInput, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, api.CreateProjectInput, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, api.CreateProjectInput, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_CreateProject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateProject'
type ClientInterface_CreateProject_Call struct {
	*mock.Call
}

// CreateProject is a helper method to define mock.On call
//   - ctx context.Context
//   - body api.CreateProjectInput
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) CreateProject(ctx interface{}, body interface{}, reqEditors ...interface{}) *ClientInterface_CreateProject_Call {
	return &ClientInterface_CreateProject_Call{Call: _e.mock.On("CreateProject",
		append([]interface{}{ctx, body}, reqEditors...)...)}
}

func (_c *ClientInterface_CreateProject_Call) Run(run func(ctx context.Context, body api.CreateProjectInput, reqEditors ...api.RequestEditorFn)) *ClientInterface_CreateProject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(api.CreateProjectInput), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_CreateProject_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_CreateProject_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_CreateProject_Call) RunAndReturn(run func(context.Context, api.CreateProjectInput, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_CreateProject_Call {
	_c.Call.Return(run)
	return _c
}

// CreateProjectWithBody provides a mock function with given fields: ctx, contentType, body, reqEditors
func (_m *ClientInterface) CreateProjectWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateProjectWithBody")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, io.Reader, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, io.Reader, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, io.Reader, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_CreateProjectWithBody_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateProjectWithBody'
type ClientInterface_CreateProjectWithBody_Call struct {
	*mock.Call
}

// CreateProjectWithBody is a helper method to define mock.On call
//   - ctx context.Context
//   - contentType string
//   - body io.Reader
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) CreateProjectWithBody(ctx interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *ClientInterface_CreateProjectWithBody_Call {
	return &ClientInterface_CreateProjectWithBody_Call{Call: _e.mock.On("CreateProjectWithBody",
		append([]interface{}{ctx, contentType, body}, reqEditors...)...)}
}

func (_c *ClientInterface_CreateProjectWithBody_Call) Run(run func(ctx context.Context, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn)) *ClientInterface_CreateProjectWithBody_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(string), args[2].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_CreateProjectWithBody_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_CreateProjectWithBody_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_CreateProjectWithBody_Call) RunAndReturn(run func(context.Context, string, io.Reader, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_CreateProjectWithBody_Call {
	_c.Call.Return(run)
	return _c
}

// CreateReport provides a mock function with given fields: ctx, projectID, body, reqEditors
func (_m *ClientInterface) CreateReport(ctx context.Context, projectID uuid.UUID, body api.ReportInput, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateReport")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, api.ReportInput, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, api.ReportInput, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, api.ReportInput, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_CreateReport_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateReport'
type ClientInterface_CreateReport_Call struct {
	*mock.Call
}

// CreateReport is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - body api.ReportInput
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) CreateReport(ctx interface{}, projectID interface{}, body interface{}, reqEditors ...interface{}) *ClientInterface_CreateReport_Call {
	return &ClientInterface_CreateReport_Call{Call: _e.mock.On("CreateReport",
		append([]interface{}{ctx, projectID, body}, reqEditors...)...)}
}

func (_c *ClientInterface_CreateReport_Call) Run(run func(ctx context.Context, projectID uuid.UUID, body api.ReportInput, reqEditors ...api.RequestEditorFn)) *ClientInterface_CreateReport_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(api.ReportInput), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_CreateReport_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_CreateReport_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_CreateReport_Call) RunAndReturn(run func(context.Context, uuid.UUID, api.ReportInput, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_CreateReport_Call {
	_c.Call.Return(run)
	return _c
}

// CreateReportWithBody provides a mock function with given fields: ctx, projectID, contentType, body, reqEditors
func (_m *ClientInterface) CreateReportWithBody(ctx context.Context, projectID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateReportWithBody")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_CreateReportWithBody_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateReportWithBody'
type ClientInterface_CreateReportWithBody_Call struct {
	*mock.Call
}

// CreateReportWithBody is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - contentType string
//   - body io.Reader
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) CreateReportWithBody(ctx interface{}, projectID interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *ClientInterface_CreateReportWithBody_Call {
	return &ClientInterface_CreateReportWithBody_Call{Call: _e.mock.On("CreateReportWithBody",
		append([]interface{}{ctx, projectID, contentType, body}, reqEditors...)...)}
}

func (_c *ClientInterface_CreateReportWithBody_Call) Run(run func(ctx context.Context, projectID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn)) *ClientInterface_CreateReportWithBody_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(string), args[3].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_CreateReportWithBody_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_CreateReportWithBody_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_CreateReportWithBody_Call) RunAndReturn(run func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_CreateReportWithBody_Call {
	_c.Call.Return(run)
	return _c
}

// CreateSystem provides a mock function with given fields: ctx, projectID, body, reqEditors
func (_m *ClientInterface) CreateSystem(ctx context.Context, projectID uuid.UUID, body api.CreateSystemInput, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateSystem")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, api.CreateSystemInput, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, api.CreateSystemInput, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, api.CreateSystemInput, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_CreateSystem_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateSystem'
type ClientInterface_CreateSystem_Call struct {
	*mock.Call
}

// CreateSystem is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - body api.CreateSystemInput
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) CreateSystem(ctx interface{}, projectID interface{}, body interface{}, reqEditors ...interface{}) *ClientInterface_CreateSystem_Call {
	return &ClientInterface_CreateSystem_Call{Call: _e.mock.On("CreateSystem",
		append([]interface{}{ctx, projectID, body}, reqEditors...)...)}
}

func (_c *ClientInterface_CreateSystem_Call) Run(run func(ctx context.Context, projectID uuid.UUID, body api.CreateSystemInput, reqEditors ...api.RequestEditorFn)) *ClientInterface_CreateSystem_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(api.CreateSystemInput), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_CreateSystem_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_CreateSystem_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_CreateSystem_Call) RunAndReturn(run func(context.Context, uuid.UUID, api.CreateSystemInput, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_CreateSystem_Call {
	_c.Call.Return(run)
	return _c
}

// CreateSystemWithBody provides a mock function with given fields: ctx, projectID, contentType, body, reqEditors
func (_m *ClientInterface) CreateSystemWithBody(ctx context.Context, projectID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateSystemWithBody")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_CreateSystemWithBody_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateSystemWithBody'
type ClientInterface_CreateSystemWithBody_Call struct {
	*mock.Call
}

// CreateSystemWithBody is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - contentType string
//   - body io.Reader
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) CreateSystemWithBody(ctx interface{}, projectID interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *ClientInterface_CreateSystemWithBody_Call {
	return &ClientInterface_CreateSystemWithBody_Call{Call: _e.mock.On("CreateSystemWithBody",
		append([]interface{}{ctx, projectID, contentType, body}, reqEditors...)...)}
}

func (_c *ClientInterface_CreateSystemWithBody_Call) Run(run func(ctx context.Context, projectID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn)) *ClientInterface_CreateSystemWithBody_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(string), args[3].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_CreateSystemWithBody_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_CreateSystemWithBody_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_CreateSystemWithBody_Call) RunAndReturn(run func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_CreateSystemWithBody_Call {
	_c.Call.Return(run)
	return _c
}

// CreateTestSuite provides a mock function with given fields: ctx, projectID, body, reqEditors
func (_m *ClientInterface) CreateTestSuite(ctx context.Context, projectID uuid.UUID, body api.CreateTestSuiteInput, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateTestSuite")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, api.CreateTestSuiteInput, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, api.CreateTestSuiteInput, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, api.CreateTestSuiteInput, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_CreateTestSuite_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateTestSuite'
type ClientInterface_CreateTestSuite_Call struct {
	*mock.Call
}

// CreateTestSuite is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - body api.CreateTestSuiteInput
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) CreateTestSuite(ctx interface{}, projectID interface{}, body interface{}, reqEditors ...interface{}) *ClientInterface_CreateTestSuite_Call {
	return &ClientInterface_CreateTestSuite_Call{Call: _e.mock.On("CreateTestSuite",
		append([]interface{}{ctx, projectID, body}, reqEditors...)...)}
}

func (_c *ClientInterface_CreateTestSuite_Call) Run(run func(ctx context.Context, projectID uuid.UUID, body api.CreateTestSuiteInput, reqEditors ...api.RequestEditorFn)) *ClientInterface_CreateTestSuite_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(api.CreateTestSuiteInput), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_CreateTestSuite_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_CreateTestSuite_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_CreateTestSuite_Call) RunAndReturn(run func(context.Context, uuid.UUID, api.CreateTestSuiteInput, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_CreateTestSuite_Call {
	_c.Call.Return(run)
	return _c
}

// CreateTestSuiteWithBody provides a mock function with given fields: ctx, projectID, contentType, body, reqEditors
func (_m *ClientInterface) CreateTestSuiteWithBody(ctx context.Context, projectID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateTestSuiteWithBody")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_CreateTestSuiteWithBody_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateTestSuiteWithBody'
type ClientInterface_CreateTestSuiteWithBody_Call struct {
	*mock.Call
}

// CreateTestSuiteWithBody is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - contentType string
//   - body io.Reader
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) CreateTestSuiteWithBody(ctx interface{}, projectID interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *ClientInterface_CreateTestSuiteWithBody_Call {
	return &ClientInterface_CreateTestSuiteWithBody_Call{Call: _e.mock.On("CreateTestSuiteWithBody",
		append([]interface{}{ctx, projectID, contentType, body}, reqEditors...)...)}
}

func (_c *ClientInterface_CreateTestSuiteWithBody_Call) Run(run func(ctx context.Context, projectID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn)) *ClientInterface_CreateTestSuiteWithBody_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(string), args[3].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_CreateTestSuiteWithBody_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_CreateTestSuiteWithBody_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_CreateTestSuiteWithBody_Call) RunAndReturn(run func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_CreateTestSuiteWithBody_Call {
	_c.Call.Return(run)
	return _c
}

// CreateViewSession provides a mock function with given fields: ctx, reqEditors
func (_m *ClientInterface) CreateViewSession(ctx context.Context, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateViewSession")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_CreateViewSession_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateViewSession'
type ClientInterface_CreateViewSession_Call struct {
	*mock.Call
}

// CreateViewSession is a helper method to define mock.On call
//   - ctx context.Context
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) CreateViewSession(ctx interface{}, reqEditors ...interface{}) *ClientInterface_CreateViewSession_Call {
	return &ClientInterface_CreateViewSession_Call{Call: _e.mock.On("CreateViewSession",
		append([]interface{}{ctx}, reqEditors...)...)}
}

func (_c *ClientInterface_CreateViewSession_Call) Run(run func(ctx context.Context, reqEditors ...api.RequestEditorFn)) *ClientInterface_CreateViewSession_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_CreateViewSession_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_CreateViewSession_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_CreateViewSession_Call) RunAndReturn(run func(context.Context, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_CreateViewSession_Call {
	_c.Call.Return(run)
	return _c
}

// CreateViewUpdateWithBody provides a mock function with given fields: ctx, viewSessionID, viewUpdateID, contentType, body, reqEditors
func (_m *ClientInterface) CreateViewUpdateWithBody(ctx context.Context, viewSessionID uuid.UUID, viewUpdateID int, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, viewSessionID, viewUpdateID, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateViewUpdateWithBody")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, int, string, io.Reader, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, viewSessionID, viewUpdateID, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, int, string, io.Reader, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, viewSessionID, viewUpdateID, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, int, string, io.Reader, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, viewSessionID, viewUpdateID, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_CreateViewUpdateWithBody_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateViewUpdateWithBody'
type ClientInterface_CreateViewUpdateWithBody_Call struct {
	*mock.Call
}

// CreateViewUpdateWithBody is a helper method to define mock.On call
//   - ctx context.Context
//   - viewSessionID uuid.UUID
//   - viewUpdateID int
//   - contentType string
//   - body io.Reader
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) CreateViewUpdateWithBody(ctx interface{}, viewSessionID interface{}, viewUpdateID interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *ClientInterface_CreateViewUpdateWithBody_Call {
	return &ClientInterface_CreateViewUpdateWithBody_Call{Call: _e.mock.On("CreateViewUpdateWithBody",
		append([]interface{}{ctx, viewSessionID, viewUpdateID, contentType, body}, reqEditors...)...)}
}

func (_c *ClientInterface_CreateViewUpdateWithBody_Call) Run(run func(ctx context.Context, viewSessionID uuid.UUID, viewUpdateID int, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn)) *ClientInterface_CreateViewUpdateWithBody_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(int), args[3].(string), args[4].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_CreateViewUpdateWithBody_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_CreateViewUpdateWithBody_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_CreateViewUpdateWithBody_Call) RunAndReturn(run func(context.Context, uuid.UUID, int, string, io.Reader, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_CreateViewUpdateWithBody_Call {
	_c.Call.Return(run)
	return _c
}

// CreateWorkflow provides a mock function with given fields: ctx, projectID, body, reqEditors
func (_m *ClientInterface) CreateWorkflow(ctx context.Context, projectID uuid.UUID, body api.CreateWorkflowInput, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateWorkflow")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, api.CreateWorkflowInput, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, api.CreateWorkflowInput, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, api.CreateWorkflowInput, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_CreateWorkflow_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateWorkflow'
type ClientInterface_CreateWorkflow_Call struct {
	*mock.Call
}

// CreateWorkflow is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - body api.CreateWorkflowInput
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) CreateWorkflow(ctx interface{}, projectID interface{}, body interface{}, reqEditors ...interface{}) *ClientInterface_CreateWorkflow_Call {
	return &ClientInterface_CreateWorkflow_Call{Call: _e.mock.On("CreateWorkflow",
		append([]interface{}{ctx, projectID, body}, reqEditors...)...)}
}

func (_c *ClientInterface_CreateWorkflow_Call) Run(run func(ctx context.Context, projectID uuid.UUID, body api.CreateWorkflowInput, reqEditors ...api.RequestEditorFn)) *ClientInterface_CreateWorkflow_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(api.CreateWorkflowInput), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_CreateWorkflow_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_CreateWorkflow_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_CreateWorkflow_Call) RunAndReturn(run func(context.Context, uuid.UUID, api.CreateWorkflowInput, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_CreateWorkflow_Call {
	_c.Call.Return(run)
	return _c
}

// CreateWorkflowRun provides a mock function with given fields: ctx, projectID, workflowID, body, reqEditors
func (_m *ClientInterface) CreateWorkflowRun(ctx context.Context, projectID uuid.UUID, workflowID uuid.UUID, body api.CreateWorkflowRunInput, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, workflowID, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateWorkflowRun")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, api.CreateWorkflowRunInput, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, workflowID, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, api.CreateWorkflowRunInput, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, workflowID, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, api.CreateWorkflowRunInput, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, workflowID, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_CreateWorkflowRun_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateWorkflowRun'
type ClientInterface_CreateWorkflowRun_Call struct {
	*mock.Call
}

// CreateWorkflowRun is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - workflowID uuid.UUID
//   - body api.CreateWorkflowRunInput
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) CreateWorkflowRun(ctx interface{}, projectID interface{}, workflowID interface{}, body interface{}, reqEditors ...interface{}) *ClientInterface_CreateWorkflowRun_Call {
	return &ClientInterface_CreateWorkflowRun_Call{Call: _e.mock.On("CreateWorkflowRun",
		append([]interface{}{ctx, projectID, workflowID, body}, reqEditors...)...)}
}

func (_c *ClientInterface_CreateWorkflowRun_Call) Run(run func(ctx context.Context, projectID uuid.UUID, workflowID uuid.UUID, body api.CreateWorkflowRunInput, reqEditors ...api.RequestEditorFn)) *ClientInterface_CreateWorkflowRun_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(api.CreateWorkflowRunInput), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_CreateWorkflowRun_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_CreateWorkflowRun_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_CreateWorkflowRun_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, api.CreateWorkflowRunInput, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_CreateWorkflowRun_Call {
	_c.Call.Return(run)
	return _c
}

// CreateWorkflowRunWithBody provides a mock function with given fields: ctx, projectID, workflowID, contentType, body, reqEditors
func (_m *ClientInterface) CreateWorkflowRunWithBody(ctx context.Context, projectID uuid.UUID, workflowID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, workflowID, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateWorkflowRunWithBody")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, workflowID, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, workflowID, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, workflowID, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_CreateWorkflowRunWithBody_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateWorkflowRunWithBody'
type ClientInterface_CreateWorkflowRunWithBody_Call struct {
	*mock.Call
}

// CreateWorkflowRunWithBody is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - workflowID uuid.UUID
//   - contentType string
//   - body io.Reader
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) CreateWorkflowRunWithBody(ctx interface{}, projectID interface{}, workflowID interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *ClientInterface_CreateWorkflowRunWithBody_Call {
	return &ClientInterface_CreateWorkflowRunWithBody_Call{Call: _e.mock.On("CreateWorkflowRunWithBody",
		append([]interface{}{ctx, projectID, workflowID, contentType, body}, reqEditors...)...)}
}

func (_c *ClientInterface_CreateWorkflowRunWithBody_Call) Run(run func(ctx context.Context, projectID uuid.UUID, workflowID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn)) *ClientInterface_CreateWorkflowRunWithBody_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(string), args[4].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_CreateWorkflowRunWithBody_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_CreateWorkflowRunWithBody_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_CreateWorkflowRunWithBody_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_CreateWorkflowRunWithBody_Call {
	_c.Call.Return(run)
	return _c
}

// CreateWorkflowSuites provides a mock function with given fields: ctx, projectID, workflowID, body, reqEditors
func (_m *ClientInterface) CreateWorkflowSuites(ctx context.Context, projectID uuid.UUID, workflowID uuid.UUID, body api.CreateWorkflowSuitesInput, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, workflowID, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateWorkflowSuites")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, api.CreateWorkflowSuitesInput, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, workflowID, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, api.CreateWorkflowSuitesInput, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, workflowID, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, api.CreateWorkflowSuitesInput, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, workflowID, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_CreateWorkflowSuites_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateWorkflowSuites'
type ClientInterface_CreateWorkflowSuites_Call struct {
	*mock.Call
}

// CreateWorkflowSuites is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - workflowID uuid.UUID
//   - body api.CreateWorkflowSuitesInput
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) CreateWorkflowSuites(ctx interface{}, projectID interface{}, workflowID interface{}, body interface{}, reqEditors ...interface{}) *ClientInterface_CreateWorkflowSuites_Call {
	return &ClientInterface_CreateWorkflowSuites_Call{Call: _e.mock.On("CreateWorkflowSuites",
		append([]interface{}{ctx, projectID, workflowID, body}, reqEditors...)...)}
}

func (_c *ClientInterface_CreateWorkflowSuites_Call) Run(run func(ctx context.Context, projectID uuid.UUID, workflowID uuid.UUID, body api.CreateWorkflowSuitesInput, reqEditors ...api.RequestEditorFn)) *ClientInterface_CreateWorkflowSuites_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(api.CreateWorkflowSuitesInput), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_CreateWorkflowSuites_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_CreateWorkflowSuites_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_CreateWorkflowSuites_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, api.CreateWorkflowSuitesInput, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_CreateWorkflowSuites_Call {
	_c.Call.Return(run)
	return _c
}

// CreateWorkflowSuitesWithBody provides a mock function with given fields: ctx, projectID, workflowID, contentType, body, reqEditors
func (_m *ClientInterface) CreateWorkflowSuitesWithBody(ctx context.Context, projectID uuid.UUID, workflowID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, workflowID, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateWorkflowSuitesWithBody")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, workflowID, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, workflowID, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, workflowID, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_CreateWorkflowSuitesWithBody_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateWorkflowSuitesWithBody'
type ClientInterface_CreateWorkflowSuitesWithBody_Call struct {
	*mock.Call
}

// CreateWorkflowSuitesWithBody is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - workflowID uuid.UUID
//   - contentType string
//   - body io.Reader
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) CreateWorkflowSuitesWithBody(ctx interface{}, projectID interface{}, workflowID interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *ClientInterface_CreateWorkflowSuitesWithBody_Call {
	return &ClientInterface_CreateWorkflowSuitesWithBody_Call{Call: _e.mock.On("CreateWorkflowSuitesWithBody",
		append([]interface{}{ctx, projectID, workflowID, contentType, body}, reqEditors...)...)}
}

func (_c *ClientInterface_CreateWorkflowSuitesWithBody_Call) Run(run func(ctx context.Context, projectID uuid.UUID, workflowID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn)) *ClientInterface_CreateWorkflowSuitesWithBody_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(string), args[4].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_CreateWorkflowSuitesWithBody_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_CreateWorkflowSuitesWithBody_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_CreateWorkflowSuitesWithBody_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_CreateWorkflowSuitesWithBody_Call {
	_c.Call.Return(run)
	return _c
}

// CreateWorkflowWithBody provides a mock function with given fields: ctx, projectID, contentType, body, reqEditors
func (_m *ClientInterface) CreateWorkflowWithBody(ctx context.Context, projectID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateWorkflowWithBody")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_CreateWorkflowWithBody_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateWorkflowWithBody'
type ClientInterface_CreateWorkflowWithBody_Call struct {
	*mock.Call
}

// CreateWorkflowWithBody is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - contentType string
//   - body io.Reader
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) CreateWorkflowWithBody(ctx interface{}, projectID interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *ClientInterface_CreateWorkflowWithBody_Call {
	return &ClientInterface_CreateWorkflowWithBody_Call{Call: _e.mock.On("CreateWorkflowWithBody",
		append([]interface{}{ctx, projectID, contentType, body}, reqEditors...)...)}
}

func (_c *ClientInterface_CreateWorkflowWithBody_Call) Run(run func(ctx context.Context, projectID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn)) *ClientInterface_CreateWorkflowWithBody_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(string), args[3].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_CreateWorkflowWithBody_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_CreateWorkflowWithBody_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_CreateWorkflowWithBody_Call) RunAndReturn(run func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_CreateWorkflowWithBody_Call {
	_c.Call.Return(run)
	return _c
}

// DebugExperience provides a mock function with given fields: ctx, projectID, experienceID, body, reqEditors
func (_m *ClientInterface) DebugExperience(ctx context.Context, projectID uuid.UUID, experienceID uuid.UUID, body api.DebugExperienceInput, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, experienceID, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DebugExperience")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, api.DebugExperienceInput, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, experienceID, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, api.DebugExperienceInput, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, experienceID, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, api.DebugExperienceInput, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, experienceID, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_DebugExperience_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DebugExperience'
type ClientInterface_DebugExperience_Call struct {
	*mock.Call
}

// DebugExperience is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - experienceID uuid.UUID
//   - body api.DebugExperienceInput
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) DebugExperience(ctx interface{}, projectID interface{}, experienceID interface{}, body interface{}, reqEditors ...interface{}) *ClientInterface_DebugExperience_Call {
	return &ClientInterface_DebugExperience_Call{Call: _e.mock.On("DebugExperience",
		append([]interface{}{ctx, projectID, experienceID, body}, reqEditors...)...)}
}

func (_c *ClientInterface_DebugExperience_Call) Run(run func(ctx context.Context, projectID uuid.UUID, experienceID uuid.UUID, body api.DebugExperienceInput, reqEditors ...api.RequestEditorFn)) *ClientInterface_DebugExperience_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(api.DebugExperienceInput), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_DebugExperience_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_DebugExperience_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_DebugExperience_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, api.DebugExperienceInput, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_DebugExperience_Call {
	_c.Call.Return(run)
	return _c
}

// DebugExperienceWithBody provides a mock function with given fields: ctx, projectID, experienceID, contentType, body, reqEditors
func (_m *ClientInterface) DebugExperienceWithBody(ctx context.Context, projectID uuid.UUID, experienceID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, experienceID, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DebugExperienceWithBody")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, experienceID, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, experienceID, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, experienceID, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_DebugExperienceWithBody_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DebugExperienceWithBody'
type ClientInterface_DebugExperienceWithBody_Call struct {
	*mock.Call
}

// DebugExperienceWithBody is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - experienceID uuid.UUID
//   - contentType string
//   - body io.Reader
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) DebugExperienceWithBody(ctx interface{}, projectID interface{}, experienceID interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *ClientInterface_DebugExperienceWithBody_Call {
	return &ClientInterface_DebugExperienceWithBody_Call{Call: _e.mock.On("DebugExperienceWithBody",
		append([]interface{}{ctx, projectID, experienceID, contentType, body}, reqEditors...)...)}
}

func (_c *ClientInterface_DebugExperienceWithBody_Call) Run(run func(ctx context.Context, projectID uuid.UUID, experienceID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn)) *ClientInterface_DebugExperienceWithBody_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(string), args[4].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_DebugExperienceWithBody_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_DebugExperienceWithBody_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_DebugExperienceWithBody_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_DebugExperienceWithBody_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteBatchLog provides a mock function with given fields: ctx, projectID, batchID, logID, reqEditors
func (_m *ClientInterface) DeleteBatchLog(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, logID uuid.UUID, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, batchID, logID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteBatchLog")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, batchID, logID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, batchID, logID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, batchID, logID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_DeleteBatchLog_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteBatchLog'
type ClientInterface_DeleteBatchLog_Call struct {
	*mock.Call
}

// DeleteBatchLog is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - batchID uuid.UUID
//   - logID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) DeleteBatchLog(ctx interface{}, projectID interface{}, batchID interface{}, logID interface{}, reqEditors ...interface{}) *ClientInterface_DeleteBatchLog_Call {
	return &ClientInterface_DeleteBatchLog_Call{Call: _e.mock.On("DeleteBatchLog",
		append([]interface{}{ctx, projectID, batchID, logID}, reqEditors...)...)}
}

func (_c *ClientInterface_DeleteBatchLog_Call) Run(run func(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, logID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientInterface_DeleteBatchLog_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_DeleteBatchLog_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_DeleteBatchLog_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_DeleteBatchLog_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_DeleteBatchLog_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteBranchForProject provides a mock function with given fields: ctx, projectID, branchID, reqEditors
func (_m *ClientInterface) DeleteBranchForProject(ctx context.Context, projectID uuid.UUID, branchID uuid.UUID, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, branchID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteBranchForProject")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, branchID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, branchID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, branchID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_DeleteBranchForProject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteBranchForProject'
type ClientInterface_DeleteBranchForProject_Call struct {
	*mock.Call
}

// DeleteBranchForProject is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - branchID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) DeleteBranchForProject(ctx interface{}, projectID interface{}, branchID interface{}, reqEditors ...interface{}) *ClientInterface_DeleteBranchForProject_Call {
	return &ClientInterface_DeleteBranchForProject_Call{Call: _e.mock.On("DeleteBranchForProject",
		append([]interface{}{ctx, projectID, branchID}, reqEditors...)...)}
}

func (_c *ClientInterface_DeleteBranchForProject_Call) Run(run func(ctx context.Context, projectID uuid.UUID, branchID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientInterface_DeleteBranchForProject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_DeleteBranchForProject_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_DeleteBranchForProject_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_DeleteBranchForProject_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_DeleteBranchForProject_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteBuildForBranch provides a mock function with given fields: ctx, projectID, branchID, buildID, reqEditors
func (_m *ClientInterface) DeleteBuildForBranch(ctx context.Context, projectID uuid.UUID, branchID uuid.UUID, buildID uuid.UUID, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, branchID, buildID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteBuildForBranch")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, branchID, buildID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, branchID, buildID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, branchID, buildID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_DeleteBuildForBranch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteBuildForBranch'
type ClientInterface_DeleteBuildForBranch_Call struct {
	*mock.Call
}

// DeleteBuildForBranch is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - branchID uuid.UUID
//   - buildID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) DeleteBuildForBranch(ctx interface{}, projectID interface{}, branchID interface{}, buildID interface{}, reqEditors ...interface{}) *ClientInterface_DeleteBuildForBranch_Call {
	return &ClientInterface_DeleteBuildForBranch_Call{Call: _e.mock.On("DeleteBuildForBranch",
		append([]interface{}{ctx, projectID, branchID, buildID}, reqEditors...)...)}
}

func (_c *ClientInterface_DeleteBuildForBranch_Call) Run(run func(ctx context.Context, projectID uuid.UUID, branchID uuid.UUID, buildID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientInterface_DeleteBuildForBranch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_DeleteBuildForBranch_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_DeleteBuildForBranch_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_DeleteBuildForBranch_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_DeleteBuildForBranch_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteExperienceTag provides a mock function with given fields: ctx, projectID, experienceTagID, reqEditors
func (_m *ClientInterface) DeleteExperienceTag(ctx context.Context, projectID uuid.UUID, experienceTagID uuid.UUID, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, experienceTagID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteExperienceTag")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, experienceTagID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, experienceTagID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, experienceTagID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_DeleteExperienceTag_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteExperienceTag'
type ClientInterface_DeleteExperienceTag_Call struct {
	*mock.Call
}

// DeleteExperienceTag is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - experienceTagID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) DeleteExperienceTag(ctx interface{}, projectID interface{}, experienceTagID interface{}, reqEditors ...interface{}) *ClientInterface_DeleteExperienceTag_Call {
	return &ClientInterface_DeleteExperienceTag_Call{Call: _e.mock.On("DeleteExperienceTag",
		append([]interface{}{ctx, projectID, experienceTagID}, reqEditors...)...)}
}

func (_c *ClientInterface_DeleteExperienceTag_Call) Run(run func(ctx context.Context, projectID uuid.UUID, experienceTagID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientInterface_DeleteExperienceTag_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_DeleteExperienceTag_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_DeleteExperienceTag_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_DeleteExperienceTag_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_DeleteExperienceTag_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteJobLog provides a mock function with given fields: ctx, projectID, batchID, jobID, logID, reqEditors
func (_m *ClientInterface) DeleteJobLog(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, jobID uuid.UUID, logID uuid.UUID, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, batchID, jobID, logID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteJobLog")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, batchID, jobID, logID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, batchID, jobID, logID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, batchID, jobID, logID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_DeleteJobLog_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteJobLog'
type ClientInterface_DeleteJobLog_Call struct {
	*mock.Call
}

// DeleteJobLog is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - batchID uuid.UUID
//   - jobID uuid.UUID
//   - logID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) DeleteJobLog(ctx interface{}, projectID interface{}, batchID interface{}, jobID interface{}, logID interface{}, reqEditors ...interface{}) *ClientInterface_DeleteJobLog_Call {
	return &ClientInterface_DeleteJobLog_Call{Call: _e.mock.On("DeleteJobLog",
		append([]interface{}{ctx, projectID, batchID, jobID, logID}, reqEditors...)...)}
}

func (_c *ClientInterface_DeleteJobLog_Call) Run(run func(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, jobID uuid.UUID, logID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientInterface_DeleteJobLog_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(uuid.UUID), args[4].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_DeleteJobLog_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_DeleteJobLog_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_DeleteJobLog_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_DeleteJobLog_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteWorkflowSuites provides a mock function with given fields: ctx, projectID, workflowID, body, reqEditors
func (_m *ClientInterface) DeleteWorkflowSuites(ctx context.Context, projectID uuid.UUID, workflowID uuid.UUID, body api.DeleteWorkflowSuitesInput, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, workflowID, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteWorkflowSuites")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, api.DeleteWorkflowSuitesInput, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, workflowID, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, api.DeleteWorkflowSuitesInput, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, workflowID, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, api.DeleteWorkflowSuitesInput, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, workflowID, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_DeleteWorkflowSuites_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteWorkflowSuites'
type ClientInterface_DeleteWorkflowSuites_Call struct {
	*mock.Call
}

// DeleteWorkflowSuites is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - workflowID uuid.UUID
//   - body api.DeleteWorkflowSuitesInput
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) DeleteWorkflowSuites(ctx interface{}, projectID interface{}, workflowID interface{}, body interface{}, reqEditors ...interface{}) *ClientInterface_DeleteWorkflowSuites_Call {
	return &ClientInterface_DeleteWorkflowSuites_Call{Call: _e.mock.On("DeleteWorkflowSuites",
		append([]interface{}{ctx, projectID, workflowID, body}, reqEditors...)...)}
}

func (_c *ClientInterface_DeleteWorkflowSuites_Call) Run(run func(ctx context.Context, projectID uuid.UUID, workflowID uuid.UUID, body api.DeleteWorkflowSuitesInput, reqEditors ...api.RequestEditorFn)) *ClientInterface_DeleteWorkflowSuites_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(api.DeleteWorkflowSuitesInput), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_DeleteWorkflowSuites_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_DeleteWorkflowSuites_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_DeleteWorkflowSuites_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, api.DeleteWorkflowSuitesInput, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_DeleteWorkflowSuites_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteWorkflowSuitesWithBody provides a mock function with given fields: ctx, projectID, workflowID, contentType, body, reqEditors
func (_m *ClientInterface) DeleteWorkflowSuitesWithBody(ctx context.Context, projectID uuid.UUID, workflowID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, workflowID, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteWorkflowSuitesWithBody")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, workflowID, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, workflowID, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, workflowID, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_DeleteWorkflowSuitesWithBody_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteWorkflowSuitesWithBody'
type ClientInterface_DeleteWorkflowSuitesWithBody_Call struct {
	*mock.Call
}

// DeleteWorkflowSuitesWithBody is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - workflowID uuid.UUID
//   - contentType string
//   - body io.Reader
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) DeleteWorkflowSuitesWithBody(ctx interface{}, projectID interface{}, workflowID interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *ClientInterface_DeleteWorkflowSuitesWithBody_Call {
	return &ClientInterface_DeleteWorkflowSuitesWithBody_Call{Call: _e.mock.On("DeleteWorkflowSuitesWithBody",
		append([]interface{}{ctx, projectID, workflowID, contentType, body}, reqEditors...)...)}
}

func (_c *ClientInterface_DeleteWorkflowSuitesWithBody_Call) Run(run func(ctx context.Context, projectID uuid.UUID, workflowID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn)) *ClientInterface_DeleteWorkflowSuitesWithBody_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(string), args[4].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_DeleteWorkflowSuitesWithBody_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_DeleteWorkflowSuitesWithBody_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_DeleteWorkflowSuitesWithBody_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_DeleteWorkflowSuitesWithBody_Call {
	_c.Call.Return(run)
	return _c
}

// GetBatch provides a mock function with given fields: ctx, projectID, batchID, reqEditors
func (_m *ClientInterface) GetBatch(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, batchID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetBatch")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, batchID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, batchID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, batchID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_GetBatch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBatch'
type ClientInterface_GetBatch_Call struct {
	*mock.Call
}

// GetBatch is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - batchID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) GetBatch(ctx interface{}, projectID interface{}, batchID interface{}, reqEditors ...interface{}) *ClientInterface_GetBatch_Call {
	return &ClientInterface_GetBatch_Call{Call: _e.mock.On("GetBatch",
		append([]interface{}{ctx, projectID, batchID}, reqEditors...)...)}
}

func (_c *ClientInterface_GetBatch_Call) Run(run func(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientInterface_GetBatch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_GetBatch_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_GetBatch_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_GetBatch_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_GetBatch_Call {
	_c.Call.Return(run)
	return _c
}

// GetBatchLog provides a mock function with given fields: ctx, projectID, batchID, logID, reqEditors
func (_m *ClientInterface) GetBatchLog(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, logID uuid.UUID, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, batchID, logID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetBatchLog")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, batchID, logID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, batchID, logID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, batchID, logID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_GetBatchLog_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBatchLog'
type ClientInterface_GetBatchLog_Call struct {
	*mock.Call
}

// GetBatchLog is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - batchID uuid.UUID
//   - logID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) GetBatchLog(ctx interface{}, projectID interface{}, batchID interface{}, logID interface{}, reqEditors ...interface{}) *ClientInterface_GetBatchLog_Call {
	return &ClientInterface_GetBatchLog_Call{Call: _e.mock.On("GetBatchLog",
		append([]interface{}{ctx, projectID, batchID, logID}, reqEditors...)...)}
}

func (_c *ClientInterface_GetBatchLog_Call) Run(run func(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, logID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientInterface_GetBatchLog_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_GetBatchLog_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_GetBatchLog_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_GetBatchLog_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_GetBatchLog_Call {
	_c.Call.Return(run)
	return _c
}

// GetBatchSuggestions provides a mock function with given fields: ctx, projectID, batchID, reqEditors
func (_m *ClientInterface) GetBatchSuggestions(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, batchID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetBatchSuggestions")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, batchID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, batchID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, batchID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_GetBatchSuggestions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBatchSuggestions'
type ClientInterface_GetBatchSuggestions_Call struct {
	*mock.Call
}

// GetBatchSuggestions is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - batchID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) GetBatchSuggestions(ctx interface{}, projectID interface{}, batchID interface{}, reqEditors ...interface{}) *ClientInterface_GetBatchSuggestions_Call {
	return &ClientInterface_GetBatchSuggestions_Call{Call: _e.mock.On("GetBatchSuggestions",
		append([]interface{}{ctx, projectID, batchID}, reqEditors...)...)}
}

func (_c *ClientInterface_GetBatchSuggestions_Call) Run(run func(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientInterface_GetBatchSuggestions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_GetBatchSuggestions_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_GetBatchSuggestions_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_GetBatchSuggestions_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_GetBatchSuggestions_Call {
	_c.Call.Return(run)
	return _c
}

// GetBranchForProject provides a mock function with given fields: ctx, projectID, branchID, reqEditors
func (_m *ClientInterface) GetBranchForProject(ctx context.Context, projectID uuid.UUID, branchID uuid.UUID, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, branchID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetBranchForProject")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, branchID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, branchID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, branchID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_GetBranchForProject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBranchForProject'
type ClientInterface_GetBranchForProject_Call struct {
	*mock.Call
}

// GetBranchForProject is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - branchID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) GetBranchForProject(ctx interface{}, projectID interface{}, branchID interface{}, reqEditors ...interface{}) *ClientInterface_GetBranchForProject_Call {
	return &ClientInterface_GetBranchForProject_Call{Call: _e.mock.On("GetBranchForProject",
		append([]interface{}{ctx, projectID, branchID}, reqEditors...)...)}
}

func (_c *ClientInterface_GetBranchForProject_Call) Run(run func(ctx context.Context, projectID uuid.UUID, branchID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientInterface_GetBranchForProject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_GetBranchForProject_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_GetBranchForProject_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_GetBranchForProject_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_GetBranchForProject_Call {
	_c.Call.Return(run)
	return _c
}

// GetBuild provides a mock function with given fields: ctx, projectID, buildID, reqEditors
func (_m *ClientInterface) GetBuild(ctx context.Context, projectID uuid.UUID, buildID uuid.UUID, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, buildID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetBuild")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, buildID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, buildID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, buildID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_GetBuild_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBuild'
type ClientInterface_GetBuild_Call struct {
	*mock.Call
}

// GetBuild is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - buildID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) GetBuild(ctx interface{}, projectID interface{}, buildID interface{}, reqEditors ...interface{}) *ClientInterface_GetBuild_Call {
	return &ClientInterface_GetBuild_Call{Call: _e.mock.On("GetBuild",
		append([]interface{}{ctx, projectID, buildID}, reqEditors...)...)}
}

func (_c *ClientInterface_GetBuild_Call) Run(run func(ctx context.Context, projectID uuid.UUID, buildID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientInterface_GetBuild_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_GetBuild_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_GetBuild_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_GetBuild_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_GetBuild_Call {
	_c.Call.Return(run)
	return _c
}

// GetBuildForBranch provides a mock function with given fields: ctx, projectID, branchID, buildID, reqEditors
func (_m *ClientInterface) GetBuildForBranch(ctx context.Context, projectID uuid.UUID, branchID uuid.UUID, buildID uuid.UUID, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, branchID, buildID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetBuildForBranch")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, branchID, buildID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, branchID, buildID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, branchID, buildID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_GetBuildForBranch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBuildForBranch'
type ClientInterface_GetBuildForBranch_Call struct {
	*mock.Call
}

// GetBuildForBranch is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - branchID uuid.UUID
//   - buildID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) GetBuildForBranch(ctx interface{}, projectID interface{}, branchID interface{}, buildID interface{}, reqEditors ...interface{}) *ClientInterface_GetBuildForBranch_Call {
	return &ClientInterface_GetBuildForBranch_Call{Call: _e.mock.On("GetBuildForBranch",
		append([]interface{}{ctx, projectID, branchID, buildID}, reqEditors...)...)}
}

func (_c *ClientInterface_GetBuildForBranch_Call) Run(run func(ctx context.Context, projectID uuid.UUID, branchID uuid.UUID, buildID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientInterface_GetBuildForBranch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_GetBuildForBranch_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_GetBuildForBranch_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_GetBuildForBranch_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_GetBuildForBranch_Call {
	_c.Call.Return(run)
	return _c
}

// GetBuildForSystem provides a mock function with given fields: ctx, projectID, systemID, buildID, reqEditors
func (_m *ClientInterface) GetBuildForSystem(ctx context.Context, projectID uuid.UUID, systemID uuid.UUID, buildID uuid.UUID, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, systemID, buildID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetBuildForSystem")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, systemID, buildID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, systemID, buildID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, systemID, buildID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_GetBuildForSystem_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBuildForSystem'
type ClientInterface_GetBuildForSystem_Call struct {
	*mock.Call
}

// GetBuildForSystem is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - systemID uuid.UUID
//   - buildID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) GetBuildForSystem(ctx interface{}, projectID interface{}, systemID interface{}, buildID interface{}, reqEditors ...interface{}) *ClientInterface_GetBuildForSystem_Call {
	return &ClientInterface_GetBuildForSystem_Call{Call: _e.mock.On("GetBuildForSystem",
		append([]interface{}{ctx, projectID, systemID, buildID}, reqEditors...)...)}
}

func (_c *ClientInterface_GetBuildForSystem_Call) Run(run func(ctx context.Context, projectID uuid.UUID, systemID uuid.UUID, buildID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientInterface_GetBuildForSystem_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_GetBuildForSystem_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_GetBuildForSystem_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_GetBuildForSystem_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_GetBuildForSystem_Call {
	_c.Call.Return(run)
	return _c
}

// GetEventForJob provides a mock function with given fields: ctx, projectID, batchID, jobID, eventID, reqEditors
func (_m *ClientInterface) GetEventForJob(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, jobID uuid.UUID, eventID uuid.UUID, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, batchID, jobID, eventID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetEventForJob")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, batchID, jobID, eventID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, batchID, jobID, eventID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, batchID, jobID, eventID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_GetEventForJob_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetEventForJob'
type ClientInterface_GetEventForJob_Call struct {
	*mock.Call
}

// GetEventForJob is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - batchID uuid.UUID
//   - jobID uuid.UUID
//   - eventID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) GetEventForJob(ctx interface{}, projectID interface{}, batchID interface{}, jobID interface{}, eventID interface{}, reqEditors ...interface{}) *ClientInterface_GetEventForJob_Call {
	return &ClientInterface_GetEventForJob_Call{Call: _e.mock.On("GetEventForJob",
		append([]interface{}{ctx, projectID, batchID, jobID, eventID}, reqEditors...)...)}
}

func (_c *ClientInterface_GetEventForJob_Call) Run(run func(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, jobID uuid.UUID, eventID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientInterface_GetEventForJob_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(uuid.UUID), args[4].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_GetEventForJob_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_GetEventForJob_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_GetEventForJob_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_GetEventForJob_Call {
	_c.Call.Return(run)
	return _c
}

// GetExperience provides a mock function with given fields: ctx, projectID, experienceID, reqEditors
func (_m *ClientInterface) GetExperience(ctx context.Context, projectID uuid.UUID, experienceID uuid.UUID, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, experienceID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetExperience")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, experienceID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, experienceID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, experienceID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_GetExperience_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetExperience'
type ClientInterface_GetExperience_Call struct {
	*mock.Call
}

// GetExperience is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - experienceID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) GetExperience(ctx interface{}, projectID interface{}, experienceID interface{}, reqEditors ...interface{}) *ClientInterface_GetExperience_Call {
	return &ClientInterface_GetExperience_Call{Call: _e.mock.On("GetExperience",
		append([]interface{}{ctx, projectID, experienceID}, reqEditors...)...)}
}

func (_c *ClientInterface_GetExperience_Call) Run(run func(ctx context.Context, projectID uuid.UUID, experienceID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientInterface_GetExperience_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_GetExperience_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_GetExperience_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_GetExperience_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_GetExperience_Call {
	_c.Call.Return(run)
	return _c
}

// GetExperienceTag provides a mock function with given fields: ctx, projectID, experienceTagID, reqEditors
func (_m *ClientInterface) GetExperienceTag(ctx context.Context, projectID uuid.UUID, experienceTagID uuid.UUID, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, experienceTagID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetExperienceTag")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, experienceTagID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, experienceTagID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, experienceTagID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_GetExperienceTag_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetExperienceTag'
type ClientInterface_GetExperienceTag_Call struct {
	*mock.Call
}

// GetExperienceTag is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - experienceTagID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) GetExperienceTag(ctx interface{}, projectID interface{}, experienceTagID interface{}, reqEditors ...interface{}) *ClientInterface_GetExperienceTag_Call {
	return &ClientInterface_GetExperienceTag_Call{Call: _e.mock.On("GetExperienceTag",
		append([]interface{}{ctx, projectID, experienceTagID}, reqEditors...)...)}
}

func (_c *ClientInterface_GetExperienceTag_Call) Run(run func(ctx context.Context, projectID uuid.UUID, experienceTagID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientInterface_GetExperienceTag_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_GetExperienceTag_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_GetExperienceTag_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_GetExperienceTag_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_GetExperienceTag_Call {
	_c.Call.Return(run)
	return _c
}

// GetJob provides a mock function with given fields: ctx, projectID, batchID, jobID, reqEditors
func (_m *ClientInterface) GetJob(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, jobID uuid.UUID, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, batchID, jobID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetJob")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, batchID, jobID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, batchID, jobID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, batchID, jobID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_GetJob_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetJob'
type ClientInterface_GetJob_Call struct {
	*mock.Call
}

// GetJob is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - batchID uuid.UUID
//   - jobID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) GetJob(ctx interface{}, projectID interface{}, batchID interface{}, jobID interface{}, reqEditors ...interface{}) *ClientInterface_GetJob_Call {
	return &ClientInterface_GetJob_Call{Call: _e.mock.On("GetJob",
		append([]interface{}{ctx, projectID, batchID, jobID}, reqEditors...)...)}
}

func (_c *ClientInterface_GetJob_Call) Run(run func(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, jobID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientInterface_GetJob_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_GetJob_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_GetJob_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_GetJob_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_GetJob_Call {
	_c.Call.Return(run)
	return _c
}

// GetJobLog provides a mock function with given fields: ctx, projectID, batchID, jobID, logID, reqEditors
func (_m *ClientInterface) GetJobLog(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, jobID uuid.UUID, logID uuid.UUID, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, batchID, jobID, logID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetJobLog")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, batchID, jobID, logID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, batchID, jobID, logID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, batchID, jobID, logID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_GetJobLog_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetJobLog'
type ClientInterface_GetJobLog_Call struct {
	*mock.Call
}

// GetJobLog is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - batchID uuid.UUID
//   - jobID uuid.UUID
//   - logID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) GetJobLog(ctx interface{}, projectID interface{}, batchID interface{}, jobID interface{}, logID interface{}, reqEditors ...interface{}) *ClientInterface_GetJobLog_Call {
	return &ClientInterface_GetJobLog_Call{Call: _e.mock.On("GetJobLog",
		append([]interface{}{ctx, projectID, batchID, jobID, logID}, reqEditors...)...)}
}

func (_c *ClientInterface_GetJobLog_Call) Run(run func(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, jobID uuid.UUID, logID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientInterface_GetJobLog_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(uuid.UUID), args[4].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_GetJobLog_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_GetJobLog_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_GetJobLog_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_GetJobLog_Call {
	_c.Call.Return(run)
	return _c
}

// GetMetricsBuild provides a mock function with given fields: ctx, projectID, metricsBuildID, reqEditors
func (_m *ClientInterface) GetMetricsBuild(ctx context.Context, projectID uuid.UUID, metricsBuildID uuid.UUID, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, metricsBuildID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetMetricsBuild")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, metricsBuildID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, metricsBuildID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, metricsBuildID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_GetMetricsBuild_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetMetricsBuild'
type ClientInterface_GetMetricsBuild_Call struct {
	*mock.Call
}

// GetMetricsBuild is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - metricsBuildID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) GetMetricsBuild(ctx interface{}, projectID interface{}, metricsBuildID interface{}, reqEditors ...interface{}) *ClientInterface_GetMetricsBuild_Call {
	return &ClientInterface_GetMetricsBuild_Call{Call: _e.mock.On("GetMetricsBuild",
		append([]interface{}{ctx, projectID, metricsBuildID}, reqEditors...)...)}
}

func (_c *ClientInterface_GetMetricsBuild_Call) Run(run func(ctx context.Context, projectID uuid.UUID, metricsBuildID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientInterface_GetMetricsBuild_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_GetMetricsBuild_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_GetMetricsBuild_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_GetMetricsBuild_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_GetMetricsBuild_Call {
	_c.Call.Return(run)
	return _c
}

// GetParameterSweep provides a mock function with given fields: ctx, projectID, sweepID, reqEditors
func (_m *ClientInterface) GetParameterSweep(ctx context.Context, projectID uuid.UUID, sweepID uuid.UUID, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, sweepID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetParameterSweep")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, sweepID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, sweepID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, sweepID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_GetParameterSweep_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetParameterSweep'
type ClientInterface_GetParameterSweep_Call struct {
	*mock.Call
}

// GetParameterSweep is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - sweepID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) GetParameterSweep(ctx interface{}, projectID interface{}, sweepID interface{}, reqEditors ...interface{}) *ClientInterface_GetParameterSweep_Call {
	return &ClientInterface_GetParameterSweep_Call{Call: _e.mock.On("GetParameterSweep",
		append([]interface{}{ctx, projectID, sweepID}, reqEditors...)...)}
}

func (_c *ClientInterface_GetParameterSweep_Call) Run(run func(ctx context.Context, projectID uuid.UUID, sweepID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientInterface_GetParameterSweep_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_GetParameterSweep_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_GetParameterSweep_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_GetParameterSweep_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_GetParameterSweep_Call {
	_c.Call.Return(run)
	return _c
}

// GetProject provides a mock function with given fields: ctx, projectID, reqEditors
func (_m *ClientInterface) GetProject(ctx context.Context, projectID uuid.UUID, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetProject")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_GetProject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetProject'
type ClientInterface_GetProject_Call struct {
	*mock.Call
}

// GetProject is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) GetProject(ctx interface{}, projectID interface{}, reqEditors ...interface{}) *ClientInterface_GetProject_Call {
	return &ClientInterface_GetProject_Call{Call: _e.mock.On("GetProject",
		append([]interface{}{ctx, projectID}, reqEditors...)...)}
}

func (_c *ClientInterface_GetProject_Call) Run(run func(ctx context.Context, projectID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientInterface_GetProject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_GetProject_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_GetProject_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_GetProject_Call) RunAndReturn(run func(context.Context, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_GetProject_Call {
	_c.Call.Return(run)
	return _c
}

// GetQuota provides a mock function with given fields: ctx, reqEditors
func (_m *ClientInterface) GetQuota(ctx context.Context, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetQuota")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_GetQuota_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetQuota'
type ClientInterface_GetQuota_Call struct {
	*mock.Call
}

// GetQuota is a helper method to define mock.On call
//   - ctx context.Context
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) GetQuota(ctx interface{}, reqEditors ...interface{}) *ClientInterface_GetQuota_Call {
	return &ClientInterface_GetQuota_Call{Call: _e.mock.On("GetQuota",
		append([]interface{}{ctx}, reqEditors...)...)}
}

func (_c *ClientInterface_GetQuota_Call) Run(run func(ctx context.Context, reqEditors ...api.RequestEditorFn)) *ClientInterface_GetQuota_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_GetQuota_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_GetQuota_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_GetQuota_Call) RunAndReturn(run func(context.Context, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_GetQuota_Call {
	_c.Call.Return(run)
	return _c
}

// GetReport provides a mock function with given fields: ctx, projectID, reportID, reqEditors
func (_m *ClientInterface) GetReport(ctx context.Context, projectID uuid.UUID, reportID uuid.UUID, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, reportID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetReport")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, reportID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, reportID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, reportID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_GetReport_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetReport'
type ClientInterface_GetReport_Call struct {
	*mock.Call
}

// GetReport is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - reportID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) GetReport(ctx interface{}, projectID interface{}, reportID interface{}, reqEditors ...interface{}) *ClientInterface_GetReport_Call {
	return &ClientInterface_GetReport_Call{Call: _e.mock.On("GetReport",
		append([]interface{}{ctx, projectID, reportID}, reqEditors...)...)}
}

func (_c *ClientInterface_GetReport_Call) Run(run func(ctx context.Context, projectID uuid.UUID, reportID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientInterface_GetReport_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_GetReport_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_GetReport_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_GetReport_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_GetReport_Call {
	_c.Call.Return(run)
	return _c
}

// GetReportLog provides a mock function with given fields: ctx, projectID, reportID, logID, reqEditors
func (_m *ClientInterface) GetReportLog(ctx context.Context, projectID uuid.UUID, reportID uuid.UUID, logID uuid.UUID, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, reportID, logID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetReportLog")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, reportID, logID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, reportID, logID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, reportID, logID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_GetReportLog_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetReportLog'
type ClientInterface_GetReportLog_Call struct {
	*mock.Call
}

// GetReportLog is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - reportID uuid.UUID
//   - logID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) GetReportLog(ctx interface{}, projectID interface{}, reportID interface{}, logID interface{}, reqEditors ...interface{}) *ClientInterface_GetReportLog_Call {
	return &ClientInterface_GetReportLog_Call{Call: _e.mock.On("GetReportLog",
		append([]interface{}{ctx, projectID, reportID, logID}, reqEditors...)...)}
}

func (_c *ClientInterface_GetReportLog_Call) Run(run func(ctx context.Context, projectID uuid.UUID, reportID uuid.UUID, logID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientInterface_GetReportLog_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_GetReportLog_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_GetReportLog_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_GetReportLog_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_GetReportLog_Call {
	_c.Call.Return(run)
	return _c
}

// GetSystem provides a mock function with given fields: ctx, projectID, systemID, reqEditors
func (_m *ClientInterface) GetSystem(ctx context.Context, projectID uuid.UUID, systemID uuid.UUID, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, systemID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetSystem")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, systemID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, systemID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, systemID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_GetSystem_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSystem'
type ClientInterface_GetSystem_Call struct {
	*mock.Call
}

// GetSystem is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - systemID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) GetSystem(ctx interface{}, projectID interface{}, systemID interface{}, reqEditors ...interface{}) *ClientInterface_GetSystem_Call {
	return &ClientInterface_GetSystem_Call{Call: _e.mock.On("GetSystem",
		append([]interface{}{ctx, projectID, systemID}, reqEditors...)...)}
}

func (_c *ClientInterface_GetSystem_Call) Run(run func(ctx context.Context, projectID uuid.UUID, systemID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientInterface_GetSystem_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_GetSystem_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_GetSystem_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_GetSystem_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_GetSystem_Call {
	_c.Call.Return(run)
	return _c
}

// GetSystemsForExperience provides a mock function with given fields: ctx, projectID, experienceID, params, reqEditors
func (_m *ClientInterface) GetSystemsForExperience(ctx context.Context, projectID uuid.UUID, experienceID uuid.UUID, params *api.GetSystemsForExperienceParams, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, experienceID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetSystemsForExperience")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, *api.GetSystemsForExperienceParams, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, experienceID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, *api.GetSystemsForExperienceParams, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, experienceID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, *api.GetSystemsForExperienceParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, experienceID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_GetSystemsForExperience_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSystemsForExperience'
type ClientInterface_GetSystemsForExperience_Call struct {
	*mock.Call
}

// GetSystemsForExperience is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - experienceID uuid.UUID
//   - params *api.GetSystemsForExperienceParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) GetSystemsForExperience(ctx interface{}, projectID interface{}, experienceID interface{}, params interface{}, reqEditors ...interface{}) *ClientInterface_GetSystemsForExperience_Call {
	return &ClientInterface_GetSystemsForExperience_Call{Call: _e.mock.On("GetSystemsForExperience",
		append([]interface{}{ctx, projectID, experienceID, params}, reqEditors...)...)}
}

func (_c *ClientInterface_GetSystemsForExperience_Call) Run(run func(ctx context.Context, projectID uuid.UUID, experienceID uuid.UUID, params *api.GetSystemsForExperienceParams, reqEditors ...api.RequestEditorFn)) *ClientInterface_GetSystemsForExperience_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(*api.GetSystemsForExperienceParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_GetSystemsForExperience_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_GetSystemsForExperience_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_GetSystemsForExperience_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, *api.GetSystemsForExperienceParams, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_GetSystemsForExperience_Call {
	_c.Call.Return(run)
	return _c
}

// GetSystemsForMetricsBuild provides a mock function with given fields: ctx, projectID, metricsBuildID, params, reqEditors
func (_m *ClientInterface) GetSystemsForMetricsBuild(ctx context.Context, projectID uuid.UUID, metricsBuildID uuid.UUID, params *api.GetSystemsForMetricsBuildParams, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, metricsBuildID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetSystemsForMetricsBuild")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, *api.GetSystemsForMetricsBuildParams, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, metricsBuildID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, *api.GetSystemsForMetricsBuildParams, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, metricsBuildID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, *api.GetSystemsForMetricsBuildParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, metricsBuildID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_GetSystemsForMetricsBuild_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSystemsForMetricsBuild'
type ClientInterface_GetSystemsForMetricsBuild_Call struct {
	*mock.Call
}

// GetSystemsForMetricsBuild is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - metricsBuildID uuid.UUID
//   - params *api.GetSystemsForMetricsBuildParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) GetSystemsForMetricsBuild(ctx interface{}, projectID interface{}, metricsBuildID interface{}, params interface{}, reqEditors ...interface{}) *ClientInterface_GetSystemsForMetricsBuild_Call {
	return &ClientInterface_GetSystemsForMetricsBuild_Call{Call: _e.mock.On("GetSystemsForMetricsBuild",
		append([]interface{}{ctx, projectID, metricsBuildID, params}, reqEditors...)...)}
}

func (_c *ClientInterface_GetSystemsForMetricsBuild_Call) Run(run func(ctx context.Context, projectID uuid.UUID, metricsBuildID uuid.UUID, params *api.GetSystemsForMetricsBuildParams, reqEditors ...api.RequestEditorFn)) *ClientInterface_GetSystemsForMetricsBuild_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(*api.GetSystemsForMetricsBuildParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_GetSystemsForMetricsBuild_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_GetSystemsForMetricsBuild_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_GetSystemsForMetricsBuild_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, *api.GetSystemsForMetricsBuildParams, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_GetSystemsForMetricsBuild_Call {
	_c.Call.Return(run)
	return _c
}

// GetTestSuite provides a mock function with given fields: ctx, projectID, testSuiteID, reqEditors
func (_m *ClientInterface) GetTestSuite(ctx context.Context, projectID uuid.UUID, testSuiteID uuid.UUID, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, testSuiteID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTestSuite")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, testSuiteID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, testSuiteID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, testSuiteID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_GetTestSuite_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTestSuite'
type ClientInterface_GetTestSuite_Call struct {
	*mock.Call
}

// GetTestSuite is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - testSuiteID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) GetTestSuite(ctx interface{}, projectID interface{}, testSuiteID interface{}, reqEditors ...interface{}) *ClientInterface_GetTestSuite_Call {
	return &ClientInterface_GetTestSuite_Call{Call: _e.mock.On("GetTestSuite",
		append([]interface{}{ctx, projectID, testSuiteID}, reqEditors...)...)}
}

func (_c *ClientInterface_GetTestSuite_Call) Run(run func(ctx context.Context, projectID uuid.UUID, testSuiteID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientInterface_GetTestSuite_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_GetTestSuite_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_GetTestSuite_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_GetTestSuite_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_GetTestSuite_Call {
	_c.Call.Return(run)
	return _c
}

// GetTestSuiteRevision provides a mock function with given fields: ctx, projectID, testSuiteID, revision, reqEditors
func (_m *ClientInterface) GetTestSuiteRevision(ctx context.Context, projectID uuid.UUID, testSuiteID uuid.UUID, revision int32, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, testSuiteID, revision)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTestSuiteRevision")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, int32, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, testSuiteID, revision, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, int32, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, testSuiteID, revision, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, int32, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, testSuiteID, revision, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_GetTestSuiteRevision_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTestSuiteRevision'
type ClientInterface_GetTestSuiteRevision_Call struct {
	*mock.Call
}

// GetTestSuiteRevision is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - testSuiteID uuid.UUID
//   - revision int32
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) GetTestSuiteRevision(ctx interface{}, projectID interface{}, testSuiteID interface{}, revision interface{}, reqEditors ...interface{}) *ClientInterface_GetTestSuiteRevision_Call {
	return &ClientInterface_GetTestSuiteRevision_Call{Call: _e.mock.On("GetTestSuiteRevision",
		append([]interface{}{ctx, projectID, testSuiteID, revision}, reqEditors...)...)}
}

func (_c *ClientInterface_GetTestSuiteRevision_Call) Run(run func(ctx context.Context, projectID uuid.UUID, testSuiteID uuid.UUID, revision int32, reqEditors ...api.RequestEditorFn)) *ClientInterface_GetTestSuiteRevision_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(int32), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_GetTestSuiteRevision_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_GetTestSuiteRevision_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_GetTestSuiteRevision_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, int32, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_GetTestSuiteRevision_Call {
	_c.Call.Return(run)
	return _c
}

// GetTestSuiteSummary provides a mock function with given fields: ctx, projectID, params, reqEditors
func (_m *ClientInterface) GetTestSuiteSummary(ctx context.Context, projectID uuid.UUID, params *api.GetTestSuiteSummaryParams, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTestSuiteSummary")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, *api.GetTestSuiteSummaryParams, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, *api.GetTestSuiteSummaryParams, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, *api.GetTestSuiteSummaryParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_GetTestSuiteSummary_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTestSuiteSummary'
type ClientInterface_GetTestSuiteSummary_Call struct {
	*mock.Call
}

// GetTestSuiteSummary is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - params *api.GetTestSuiteSummaryParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) GetTestSuiteSummary(ctx interface{}, projectID interface{}, params interface{}, reqEditors ...interface{}) *ClientInterface_GetTestSuiteSummary_Call {
	return &ClientInterface_GetTestSuiteSummary_Call{Call: _e.mock.On("GetTestSuiteSummary",
		append([]interface{}{ctx, projectID, params}, reqEditors...)...)}
}

func (_c *ClientInterface_GetTestSuiteSummary_Call) Run(run func(ctx context.Context, projectID uuid.UUID, params *api.GetTestSuiteSummaryParams, reqEditors ...api.RequestEditorFn)) *ClientInterface_GetTestSuiteSummary_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(*api.GetTestSuiteSummaryParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_GetTestSuiteSummary_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_GetTestSuiteSummary_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_GetTestSuiteSummary_Call) RunAndReturn(run func(context.Context, uuid.UUID, *api.GetTestSuiteSummaryParams, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_GetTestSuiteSummary_Call {
	_c.Call.Return(run)
	return _c
}

// GetViewSession provides a mock function with given fields: ctx, viewSessionID, reqEditors
func (_m *ClientInterface) GetViewSession(ctx context.Context, viewSessionID uuid.UUID, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, viewSessionID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetViewSession")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, viewSessionID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, viewSessionID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, viewSessionID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_GetViewSession_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetViewSession'
type ClientInterface_GetViewSession_Call struct {
	*mock.Call
}

// GetViewSession is a helper method to define mock.On call
//   - ctx context.Context
//   - viewSessionID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) GetViewSession(ctx interface{}, viewSessionID interface{}, reqEditors ...interface{}) *ClientInterface_GetViewSession_Call {
	return &ClientInterface_GetViewSession_Call{Call: _e.mock.On("GetViewSession",
		append([]interface{}{ctx, viewSessionID}, reqEditors...)...)}
}

func (_c *ClientInterface_GetViewSession_Call) Run(run func(ctx context.Context, viewSessionID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientInterface_GetViewSession_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_GetViewSession_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_GetViewSession_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_GetViewSession_Call) RunAndReturn(run func(context.Context, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_GetViewSession_Call {
	_c.Call.Return(run)
	return _c
}

// GetWorkflow provides a mock function with given fields: ctx, projectID, workflowID, reqEditors
func (_m *ClientInterface) GetWorkflow(ctx context.Context, projectID uuid.UUID, workflowID uuid.UUID, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, workflowID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetWorkflow")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, workflowID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, workflowID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, workflowID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_GetWorkflow_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetWorkflow'
type ClientInterface_GetWorkflow_Call struct {
	*mock.Call
}

// GetWorkflow is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - workflowID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) GetWorkflow(ctx interface{}, projectID interface{}, workflowID interface{}, reqEditors ...interface{}) *ClientInterface_GetWorkflow_Call {
	return &ClientInterface_GetWorkflow_Call{Call: _e.mock.On("GetWorkflow",
		append([]interface{}{ctx, projectID, workflowID}, reqEditors...)...)}
}

func (_c *ClientInterface_GetWorkflow_Call) Run(run func(ctx context.Context, projectID uuid.UUID, workflowID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientInterface_GetWorkflow_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_GetWorkflow_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_GetWorkflow_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_GetWorkflow_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_GetWorkflow_Call {
	_c.Call.Return(run)
	return _c
}

// GetWorkflowRun provides a mock function with given fields: ctx, projectID, workflowID, workflowRunID, reqEditors
func (_m *ClientInterface) GetWorkflowRun(ctx context.Context, projectID uuid.UUID, workflowID uuid.UUID, workflowRunID uuid.UUID, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, workflowID, workflowRunID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetWorkflowRun")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, workflowID, workflowRunID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, workflowID, workflowRunID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, workflowID, workflowRunID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_GetWorkflowRun_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetWorkflowRun'
type ClientInterface_GetWorkflowRun_Call struct {
	*mock.Call
}

// GetWorkflowRun is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - workflowID uuid.UUID
//   - workflowRunID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) GetWorkflowRun(ctx interface{}, projectID interface{}, workflowID interface{}, workflowRunID interface{}, reqEditors ...interface{}) *ClientInterface_GetWorkflowRun_Call {
	return &ClientInterface_GetWorkflowRun_Call{Call: _e.mock.On("GetWorkflowRun",
		append([]interface{}{ctx, projectID, workflowID, workflowRunID}, reqEditors...)...)}
}

func (_c *ClientInterface_GetWorkflowRun_Call) Run(run func(ctx context.Context, projectID uuid.UUID, workflowID uuid.UUID, workflowRunID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientInterface_GetWorkflowRun_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_GetWorkflowRun_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_GetWorkflowRun_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_GetWorkflowRun_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_GetWorkflowRun_Call {
	_c.Call.Return(run)
	return _c
}

// GetWorkflowSuite provides a mock function with given fields: ctx, projectID, workflowID, testSuiteID, reqEditors
func (_m *ClientInterface) GetWorkflowSuite(ctx context.Context, projectID uuid.UUID, workflowID uuid.UUID, testSuiteID uuid.UUID, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, workflowID, testSuiteID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetWorkflowSuite")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, workflowID, testSuiteID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, workflowID, testSuiteID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, workflowID, testSuiteID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_GetWorkflowSuite_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetWorkflowSuite'
type ClientInterface_GetWorkflowSuite_Call struct {
	*mock.Call
}

// GetWorkflowSuite is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - workflowID uuid.UUID
//   - testSuiteID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) GetWorkflowSuite(ctx interface{}, projectID interface{}, workflowID interface{}, testSuiteID interface{}, reqEditors ...interface{}) *ClientInterface_GetWorkflowSuite_Call {
	return &ClientInterface_GetWorkflowSuite_Call{Call: _e.mock.On("GetWorkflowSuite",
		append([]interface{}{ctx, projectID, workflowID, testSuiteID}, reqEditors...)...)}
}

func (_c *ClientInterface_GetWorkflowSuite_Call) Run(run func(ctx context.Context, projectID uuid.UUID, workflowID uuid.UUID, testSuiteID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientInterface_GetWorkflowSuite_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_GetWorkflowSuite_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_GetWorkflowSuite_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_GetWorkflowSuite_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_GetWorkflowSuite_Call {
	_c.Call.Return(run)
	return _c
}

// Health provides a mock function with given fields: ctx, reqEditors
func (_m *ClientInterface) Health(ctx context.Context, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Health")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_Health_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Health'
type ClientInterface_Health_Call struct {
	*mock.Call
}

// Health is a helper method to define mock.On call
//   - ctx context.Context
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) Health(ctx interface{}, reqEditors ...interface{}) *ClientInterface_Health_Call {
	return &ClientInterface_Health_Call{Call: _e.mock.On("Health",
		append([]interface{}{ctx}, reqEditors...)...)}
}

func (_c *ClientInterface_Health_Call) Run(run func(ctx context.Context, reqEditors ...api.RequestEditorFn)) *ClientInterface_Health_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_Health_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_Health_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_Health_Call) RunAndReturn(run func(context.Context, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_Health_Call {
	_c.Call.Return(run)
	return _c
}

// ListAllJobs provides a mock function with given fields: ctx, projectID, params, reqEditors
func (_m *ClientInterface) ListAllJobs(ctx context.Context, projectID uuid.UUID, params *api.ListAllJobsParams, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListAllJobs")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, *api.ListAllJobsParams, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, *api.ListAllJobsParams, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, *api.ListAllJobsParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_ListAllJobs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListAllJobs'
type ClientInterface_ListAllJobs_Call struct {
	*mock.Call
}

// ListAllJobs is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - params *api.ListAllJobsParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) ListAllJobs(ctx interface{}, projectID interface{}, params interface{}, reqEditors ...interface{}) *ClientInterface_ListAllJobs_Call {
	return &ClientInterface_ListAllJobs_Call{Call: _e.mock.On("ListAllJobs",
		append([]interface{}{ctx, projectID, params}, reqEditors...)...)}
}

func (_c *ClientInterface_ListAllJobs_Call) Run(run func(ctx context.Context, projectID uuid.UUID, params *api.ListAllJobsParams, reqEditors ...api.RequestEditorFn)) *ClientInterface_ListAllJobs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(*api.ListAllJobsParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_ListAllJobs_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_ListAllJobs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_ListAllJobs_Call) RunAndReturn(run func(context.Context, uuid.UUID, *api.ListAllJobsParams, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_ListAllJobs_Call {
	_c.Call.Return(run)
	return _c
}

// ListBatchAccounts provides a mock function with given fields: ctx, projectID, params, reqEditors
func (_m *ClientInterface) ListBatchAccounts(ctx context.Context, projectID uuid.UUID, params *api.ListBatchAccountsParams, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListBatchAccounts")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, *api.ListBatchAccountsParams, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, *api.ListBatchAccountsParams, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, *api.ListBatchAccountsParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_ListBatchAccounts_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListBatchAccounts'
type ClientInterface_ListBatchAccounts_Call struct {
	*mock.Call
}

// ListBatchAccounts is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - params *api.ListBatchAccountsParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) ListBatchAccounts(ctx interface{}, projectID interface{}, params interface{}, reqEditors ...interface{}) *ClientInterface_ListBatchAccounts_Call {
	return &ClientInterface_ListBatchAccounts_Call{Call: _e.mock.On("ListBatchAccounts",
		append([]interface{}{ctx, projectID, params}, reqEditors...)...)}
}

func (_c *ClientInterface_ListBatchAccounts_Call) Run(run func(ctx context.Context, projectID uuid.UUID, params *api.ListBatchAccountsParams, reqEditors ...api.RequestEditorFn)) *ClientInterface_ListBatchAccounts_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(*api.ListBatchAccountsParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_ListBatchAccounts_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_ListBatchAccounts_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_ListBatchAccounts_Call) RunAndReturn(run func(context.Context, uuid.UUID, *api.ListBatchAccountsParams, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_ListBatchAccounts_Call {
	_c.Call.Return(run)
	return _c
}

// ListBatchErrors provides a mock function with given fields: ctx, projectID, batchID, reqEditors
func (_m *ClientInterface) ListBatchErrors(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, batchID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListBatchErrors")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, batchID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, batchID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, batchID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_ListBatchErrors_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListBatchErrors'
type ClientInterface_ListBatchErrors_Call struct {
	*mock.Call
}

// ListBatchErrors is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - batchID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) ListBatchErrors(ctx interface{}, projectID interface{}, batchID interface{}, reqEditors ...interface{}) *ClientInterface_ListBatchErrors_Call {
	return &ClientInterface_ListBatchErrors_Call{Call: _e.mock.On("ListBatchErrors",
		append([]interface{}{ctx, projectID, batchID}, reqEditors...)...)}
}

func (_c *ClientInterface_ListBatchErrors_Call) Run(run func(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientInterface_ListBatchErrors_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_ListBatchErrors_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_ListBatchErrors_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_ListBatchErrors_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_ListBatchErrors_Call {
	_c.Call.Return(run)
	return _c
}

// ListBatchLogsForBatch provides a mock function with given fields: ctx, projectID, batchID, params, reqEditors
func (_m *ClientInterface) ListBatchLogsForBatch(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, params *api.ListBatchLogsForBatchParams, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, batchID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListBatchLogsForBatch")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, *api.ListBatchLogsForBatchParams, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, batchID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, *api.ListBatchLogsForBatchParams, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, batchID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, *api.ListBatchLogsForBatchParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, batchID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_ListBatchLogsForBatch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListBatchLogsForBatch'
type ClientInterface_ListBatchLogsForBatch_Call struct {
	*mock.Call
}

// ListBatchLogsForBatch is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - batchID uuid.UUID
//   - params *api.ListBatchLogsForBatchParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) ListBatchLogsForBatch(ctx interface{}, projectID interface{}, batchID interface{}, params interface{}, reqEditors ...interface{}) *ClientInterface_ListBatchLogsForBatch_Call {
	return &ClientInterface_ListBatchLogsForBatch_Call{Call: _e.mock.On("ListBatchLogsForBatch",
		append([]interface{}{ctx, projectID, batchID, params}, reqEditors...)...)}
}

func (_c *ClientInterface_ListBatchLogsForBatch_Call) Run(run func(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, params *api.ListBatchLogsForBatchParams, reqEditors ...api.RequestEditorFn)) *ClientInterface_ListBatchLogsForBatch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(*api.ListBatchLogsForBatchParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_ListBatchLogsForBatch_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_ListBatchLogsForBatch_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_ListBatchLogsForBatch_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, *api.ListBatchLogsForBatchParams, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_ListBatchLogsForBatch_Call {
	_c.Call.Return(run)
	return _c
}

// ListBatchMetrics provides a mock function with given fields: ctx, projectID, batchID, params, reqEditors
func (_m *ClientInterface) ListBatchMetrics(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, params *api.ListBatchMetricsParams, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, batchID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListBatchMetrics")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, *api.ListBatchMetricsParams, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, batchID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, *api.ListBatchMetricsParams, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, batchID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, *api.ListBatchMetricsParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, batchID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_ListBatchMetrics_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListBatchMetrics'
type ClientInterface_ListBatchMetrics_Call struct {
	*mock.Call
}

// ListBatchMetrics is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - batchID uuid.UUID
//   - params *api.ListBatchMetricsParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) ListBatchMetrics(ctx interface{}, projectID interface{}, batchID interface{}, params interface{}, reqEditors ...interface{}) *ClientInterface_ListBatchMetrics_Call {
	return &ClientInterface_ListBatchMetrics_Call{Call: _e.mock.On("ListBatchMetrics",
		append([]interface{}{ctx, projectID, batchID, params}, reqEditors...)...)}
}

func (_c *ClientInterface_ListBatchMetrics_Call) Run(run func(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, params *api.ListBatchMetricsParams, reqEditors ...api.RequestEditorFn)) *ClientInterface_ListBatchMetrics_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(*api.ListBatchMetricsParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_ListBatchMetrics_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_ListBatchMetrics_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_ListBatchMetrics_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, *api.ListBatchMetricsParams, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_ListBatchMetrics_Call {
	_c.Call.Return(run)
	return _c
}

// ListBatchMetricsData provides a mock function with given fields: ctx, projectID, batchID, params, reqEditors
func (_m *ClientInterface) ListBatchMetricsData(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, params *api.ListBatchMetricsDataParams, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, batchID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListBatchMetricsData")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, *api.ListBatchMetricsDataParams, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, batchID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, *api.ListBatchMetricsDataParams, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, batchID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, *api.ListBatchMetricsDataParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, batchID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_ListBatchMetricsData_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListBatchMetricsData'
type ClientInterface_ListBatchMetricsData_Call struct {
	*mock.Call
}

// ListBatchMetricsData is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - batchID uuid.UUID
//   - params *api.ListBatchMetricsDataParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) ListBatchMetricsData(ctx interface{}, projectID interface{}, batchID interface{}, params interface{}, reqEditors ...interface{}) *ClientInterface_ListBatchMetricsData_Call {
	return &ClientInterface_ListBatchMetricsData_Call{Call: _e.mock.On("ListBatchMetricsData",
		append([]interface{}{ctx, projectID, batchID, params}, reqEditors...)...)}
}

func (_c *ClientInterface_ListBatchMetricsData_Call) Run(run func(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, params *api.ListBatchMetricsDataParams, reqEditors ...api.RequestEditorFn)) *ClientInterface_ListBatchMetricsData_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(*api.ListBatchMetricsDataParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_ListBatchMetricsData_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_ListBatchMetricsData_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_ListBatchMetricsData_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, *api.ListBatchMetricsDataParams, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_ListBatchMetricsData_Call {
	_c.Call.Return(run)
	return _c
}

// ListBatchMetricsDataForBatchMetricIDs provides a mock function with given fields: ctx, projectID, batchID, metricID, params, reqEditors
func (_m *ClientInterface) ListBatchMetricsDataForBatchMetricIDs(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, metricID []uuid.UUID, params *api.ListBatchMetricsDataForBatchMetricIDsParams, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, batchID, metricID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListBatchMetricsDataForBatchMetricIDs")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListBatchMetricsDataForBatchMetricIDsParams, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, batchID, metricID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListBatchMetricsDataForBatchMetricIDsParams, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, batchID, metricID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListBatchMetricsDataForBatchMetricIDsParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, batchID, metricID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_ListBatchMetricsDataForBatchMetricIDs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListBatchMetricsDataForBatchMetricIDs'
type ClientInterface_ListBatchMetricsDataForBatchMetricIDs_Call struct {
	*mock.Call
}

// ListBatchMetricsDataForBatchMetricIDs is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - batchID uuid.UUID
//   - metricID []uuid.UUID
//   - params *api.ListBatchMetricsDataForBatchMetricIDsParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) ListBatchMetricsDataForBatchMetricIDs(ctx interface{}, projectID interface{}, batchID interface{}, metricID interface{}, params interface{}, reqEditors ...interface{}) *ClientInterface_ListBatchMetricsDataForBatchMetricIDs_Call {
	return &ClientInterface_ListBatchMetricsDataForBatchMetricIDs_Call{Call: _e.mock.On("ListBatchMetricsDataForBatchMetricIDs",
		append([]interface{}{ctx, projectID, batchID, metricID, params}, reqEditors...)...)}
}

func (_c *ClientInterface_ListBatchMetricsDataForBatchMetricIDs_Call) Run(run func(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, metricID []uuid.UUID, params *api.ListBatchMetricsDataForBatchMetricIDsParams, reqEditors ...api.RequestEditorFn)) *ClientInterface_ListBatchMetricsDataForBatchMetricIDs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].([]uuid.UUID), args[4].(*api.ListBatchMetricsDataForBatchMetricIDsParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_ListBatchMetricsDataForBatchMetricIDs_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_ListBatchMetricsDataForBatchMetricIDs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_ListBatchMetricsDataForBatchMetricIDs_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListBatchMetricsDataForBatchMetricIDsParams, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_ListBatchMetricsDataForBatchMetricIDs_Call {
	_c.Call.Return(run)
	return _c
}

// ListBatchMetricsDataForBatchMetricsDataIDs provides a mock function with given fields: ctx, projectID, batchID, metricsDataID, params, reqEditors
func (_m *ClientInterface) ListBatchMetricsDataForBatchMetricsDataIDs(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, metricsDataID []uuid.UUID, params *api.ListBatchMetricsDataForBatchMetricsDataIDsParams, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, batchID, metricsDataID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListBatchMetricsDataForBatchMetricsDataIDs")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListBatchMetricsDataForBatchMetricsDataIDsParams, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, batchID, metricsDataID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListBatchMetricsDataForBatchMetricsDataIDsParams, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, batchID, metricsDataID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListBatchMetricsDataForBatchMetricsDataIDsParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, batchID, metricsDataID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_ListBatchMetricsDataForBatchMetricsDataIDs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListBatchMetricsDataForBatchMetricsDataIDs'
type ClientInterface_ListBatchMetricsDataForBatchMetricsDataIDs_Call struct {
	*mock.Call
}

// ListBatchMetricsDataForBatchMetricsDataIDs is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - batchID uuid.UUID
//   - metricsDataID []uuid.UUID
//   - params *api.ListBatchMetricsDataForBatchMetricsDataIDsParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) ListBatchMetricsDataForBatchMetricsDataIDs(ctx interface{}, projectID interface{}, batchID interface{}, metricsDataID interface{}, params interface{}, reqEditors ...interface{}) *ClientInterface_ListBatchMetricsDataForBatchMetricsDataIDs_Call {
	return &ClientInterface_ListBatchMetricsDataForBatchMetricsDataIDs_Call{Call: _e.mock.On("ListBatchMetricsDataForBatchMetricsDataIDs",
		append([]interface{}{ctx, projectID, batchID, metricsDataID, params}, reqEditors...)...)}
}

func (_c *ClientInterface_ListBatchMetricsDataForBatchMetricsDataIDs_Call) Run(run func(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, metricsDataID []uuid.UUID, params *api.ListBatchMetricsDataForBatchMetricsDataIDsParams, reqEditors ...api.RequestEditorFn)) *ClientInterface_ListBatchMetricsDataForBatchMetricsDataIDs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].([]uuid.UUID), args[4].(*api.ListBatchMetricsDataForBatchMetricsDataIDsParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_ListBatchMetricsDataForBatchMetricsDataIDs_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_ListBatchMetricsDataForBatchMetricsDataIDs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_ListBatchMetricsDataForBatchMetricsDataIDs_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListBatchMetricsDataForBatchMetricsDataIDsParams, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_ListBatchMetricsDataForBatchMetricsDataIDs_Call {
	_c.Call.Return(run)
	return _c
}

// ListBatchMetricsForBatchMetricIDs provides a mock function with given fields: ctx, projectID, batchID, metricID, params, reqEditors
func (_m *ClientInterface) ListBatchMetricsForBatchMetricIDs(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, metricID []uuid.UUID, params *api.ListBatchMetricsForBatchMetricIDsParams, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, batchID, metricID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListBatchMetricsForBatchMetricIDs")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListBatchMetricsForBatchMetricIDsParams, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, batchID, metricID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListBatchMetricsForBatchMetricIDsParams, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, batchID, metricID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListBatchMetricsForBatchMetricIDsParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, batchID, metricID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_ListBatchMetricsForBatchMetricIDs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListBatchMetricsForBatchMetricIDs'
type ClientInterface_ListBatchMetricsForBatchMetricIDs_Call struct {
	*mock.Call
}

// ListBatchMetricsForBatchMetricIDs is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - batchID uuid.UUID
//   - metricID []uuid.UUID
//   - params *api.ListBatchMetricsForBatchMetricIDsParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) ListBatchMetricsForBatchMetricIDs(ctx interface{}, projectID interface{}, batchID interface{}, metricID interface{}, params interface{}, reqEditors ...interface{}) *ClientInterface_ListBatchMetricsForBatchMetricIDs_Call {
	return &ClientInterface_ListBatchMetricsForBatchMetricIDs_Call{Call: _e.mock.On("ListBatchMetricsForBatchMetricIDs",
		append([]interface{}{ctx, projectID, batchID, metricID, params}, reqEditors...)...)}
}

func (_c *ClientInterface_ListBatchMetricsForBatchMetricIDs_Call) Run(run func(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, metricID []uuid.UUID, params *api.ListBatchMetricsForBatchMetricIDsParams, reqEditors ...api.RequestEditorFn)) *ClientInterface_ListBatchMetricsForBatchMetricIDs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].([]uuid.UUID), args[4].(*api.ListBatchMetricsForBatchMetricIDsParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_ListBatchMetricsForBatchMetricIDs_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_ListBatchMetricsForBatchMetricIDs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_ListBatchMetricsForBatchMetricIDs_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListBatchMetricsForBatchMetricIDsParams, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_ListBatchMetricsForBatchMetricIDs_Call {
	_c.Call.Return(run)
	return _c
}

// ListBatches provides a mock function with given fields: ctx, projectID, params, reqEditors
func (_m *ClientInterface) ListBatches(ctx context.Context, projectID uuid.UUID, params *api.ListBatchesParams, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListBatches")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, *api.ListBatchesParams, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, *api.ListBatchesParams, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, *api.ListBatchesParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_ListBatches_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListBatches'
type ClientInterface_ListBatches_Call struct {
	*mock.Call
}

// ListBatches is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - params *api.ListBatchesParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) ListBatches(ctx interface{}, projectID interface{}, params interface{}, reqEditors ...interface{}) *ClientInterface_ListBatches_Call {
	return &ClientInterface_ListBatches_Call{Call: _e.mock.On("ListBatches",
		append([]interface{}{ctx, projectID, params}, reqEditors...)...)}
}

func (_c *ClientInterface_ListBatches_Call) Run(run func(ctx context.Context, projectID uuid.UUID, params *api.ListBatchesParams, reqEditors ...api.RequestEditorFn)) *ClientInterface_ListBatches_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(*api.ListBatchesParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_ListBatches_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_ListBatches_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_ListBatches_Call) RunAndReturn(run func(context.Context, uuid.UUID, *api.ListBatchesParams, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_ListBatches_Call {
	_c.Call.Return(run)
	return _c
}

// ListBatchesForBuilds provides a mock function with given fields: ctx, projectID, branchID, buildID, params, reqEditors
func (_m *ClientInterface) ListBatchesForBuilds(ctx context.Context, projectID uuid.UUID, branchID uuid.UUID, buildID []uuid.UUID, params *api.ListBatchesForBuildsParams, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, branchID, buildID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListBatchesForBuilds")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListBatchesForBuildsParams, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, branchID, buildID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListBatchesForBuildsParams, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, branchID, buildID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListBatchesForBuildsParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, branchID, buildID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_ListBatchesForBuilds_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListBatchesForBuilds'
type ClientInterface_ListBatchesForBuilds_Call struct {
	*mock.Call
}

// ListBatchesForBuilds is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - branchID uuid.UUID
//   - buildID []uuid.UUID
//   - params *api.ListBatchesForBuildsParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) ListBatchesForBuilds(ctx interface{}, projectID interface{}, branchID interface{}, buildID interface{}, params interface{}, reqEditors ...interface{}) *ClientInterface_ListBatchesForBuilds_Call {
	return &ClientInterface_ListBatchesForBuilds_Call{Call: _e.mock.On("ListBatchesForBuilds",
		append([]interface{}{ctx, projectID, branchID, buildID, params}, reqEditors...)...)}
}

func (_c *ClientInterface_ListBatchesForBuilds_Call) Run(run func(ctx context.Context, projectID uuid.UUID, branchID uuid.UUID, buildID []uuid.UUID, params *api.ListBatchesForBuildsParams, reqEditors ...api.RequestEditorFn)) *ClientInterface_ListBatchesForBuilds_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].([]uuid.UUID), args[4].(*api.ListBatchesForBuildsParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_ListBatchesForBuilds_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_ListBatchesForBuilds_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_ListBatchesForBuilds_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListBatchesForBuildsParams, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_ListBatchesForBuilds_Call {
	_c.Call.Return(run)
	return _c
}

// ListBatchesForTestSuite provides a mock function with given fields: ctx, projectID, testSuiteID, params, reqEditors
func (_m *ClientInterface) ListBatchesForTestSuite(ctx context.Context, projectID uuid.UUID, testSuiteID uuid.UUID, params *api.ListBatchesForTestSuiteParams, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, testSuiteID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListBatchesForTestSuite")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, *api.ListBatchesForTestSuiteParams, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, testSuiteID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, *api.ListBatchesForTestSuiteParams, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, testSuiteID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, *api.ListBatchesForTestSuiteParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, testSuiteID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_ListBatchesForTestSuite_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListBatchesForTestSuite'
type ClientInterface_ListBatchesForTestSuite_Call struct {
	*mock.Call
}

// ListBatchesForTestSuite is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - testSuiteID uuid.UUID
//   - params *api.ListBatchesForTestSuiteParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) ListBatchesForTestSuite(ctx interface{}, projectID interface{}, testSuiteID interface{}, params interface{}, reqEditors ...interface{}) *ClientInterface_ListBatchesForTestSuite_Call {
	return &ClientInterface_ListBatchesForTestSuite_Call{Call: _e.mock.On("ListBatchesForTestSuite",
		append([]interface{}{ctx, projectID, testSuiteID, params}, reqEditors...)...)}
}

func (_c *ClientInterface_ListBatchesForTestSuite_Call) Run(run func(ctx context.Context, projectID uuid.UUID, testSuiteID uuid.UUID, params *api.ListBatchesForTestSuiteParams, reqEditors ...api.RequestEditorFn)) *ClientInterface_ListBatchesForTestSuite_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(*api.ListBatchesForTestSuiteParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_ListBatchesForTestSuite_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_ListBatchesForTestSuite_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_ListBatchesForTestSuite_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, *api.ListBatchesForTestSuiteParams, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_ListBatchesForTestSuite_Call {
	_c.Call.Return(run)
	return _c
}

// ListBatchesForTestSuiteRevision provides a mock function with given fields: ctx, projectID, testSuiteID, revision, params, reqEditors
func (_m *ClientInterface) ListBatchesForTestSuiteRevision(ctx context.Context, projectID uuid.UUID, testSuiteID uuid.UUID, revision int32, params *api.ListBatchesForTestSuiteRevisionParams, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, testSuiteID, revision, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListBatchesForTestSuiteRevision")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, int32, *api.ListBatchesForTestSuiteRevisionParams, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, testSuiteID, revision, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, int32, *api.ListBatchesForTestSuiteRevisionParams, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, testSuiteID, revision, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, int32, *api.ListBatchesForTestSuiteRevisionParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, testSuiteID, revision, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_ListBatchesForTestSuiteRevision_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListBatchesForTestSuiteRevision'
type ClientInterface_ListBatchesForTestSuiteRevision_Call struct {
	*mock.Call
}

// ListBatchesForTestSuiteRevision is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - testSuiteID uuid.UUID
//   - revision int32
//   - params *api.ListBatchesForTestSuiteRevisionParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) ListBatchesForTestSuiteRevision(ctx interface{}, projectID interface{}, testSuiteID interface{}, revision interface{}, params interface{}, reqEditors ...interface{}) *ClientInterface_ListBatchesForTestSuiteRevision_Call {
	return &ClientInterface_ListBatchesForTestSuiteRevision_Call{Call: _e.mock.On("ListBatchesForTestSuiteRevision",
		append([]interface{}{ctx, projectID, testSuiteID, revision, params}, reqEditors...)...)}
}

func (_c *ClientInterface_ListBatchesForTestSuiteRevision_Call) Run(run func(ctx context.Context, projectID uuid.UUID, testSuiteID uuid.UUID, revision int32, params *api.ListBatchesForTestSuiteRevisionParams, reqEditors ...api.RequestEditorFn)) *ClientInterface_ListBatchesForTestSuiteRevision_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(int32), args[4].(*api.ListBatchesForTestSuiteRevisionParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_ListBatchesForTestSuiteRevision_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_ListBatchesForTestSuiteRevision_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_ListBatchesForTestSuiteRevision_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, int32, *api.ListBatchesForTestSuiteRevisionParams, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_ListBatchesForTestSuiteRevision_Call {
	_c.Call.Return(run)
	return _c
}

// ListBranchesForProject provides a mock function with given fields: ctx, projectID, params, reqEditors
func (_m *ClientInterface) ListBranchesForProject(ctx context.Context, projectID uuid.UUID, params *api.ListBranchesForProjectParams, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListBranchesForProject")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, *api.ListBranchesForProjectParams, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, *api.ListBranchesForProjectParams, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, *api.ListBranchesForProjectParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_ListBranchesForProject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListBranchesForProject'
type ClientInterface_ListBranchesForProject_Call struct {
	*mock.Call
}

// ListBranchesForProject is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - params *api.ListBranchesForProjectParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) ListBranchesForProject(ctx interface{}, projectID interface{}, params interface{}, reqEditors ...interface{}) *ClientInterface_ListBranchesForProject_Call {
	return &ClientInterface_ListBranchesForProject_Call{Call: _e.mock.On("ListBranchesForProject",
		append([]interface{}{ctx, projectID, params}, reqEditors...)...)}
}

func (_c *ClientInterface_ListBranchesForProject_Call) Run(run func(ctx context.Context, projectID uuid.UUID, params *api.ListBranchesForProjectParams, reqEditors ...api.RequestEditorFn)) *ClientInterface_ListBranchesForProject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(*api.ListBranchesForProjectParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_ListBranchesForProject_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_ListBranchesForProject_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_ListBranchesForProject_Call) RunAndReturn(run func(context.Context, uuid.UUID, *api.ListBranchesForProjectParams, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_ListBranchesForProject_Call {
	_c.Call.Return(run)
	return _c
}

// ListBuildAccounts provides a mock function with given fields: ctx, projectID, reqEditors
func (_m *ClientInterface) ListBuildAccounts(ctx context.Context, projectID uuid.UUID, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListBuildAccounts")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_ListBuildAccounts_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListBuildAccounts'
type ClientInterface_ListBuildAccounts_Call struct {
	*mock.Call
}

// ListBuildAccounts is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) ListBuildAccounts(ctx interface{}, projectID interface{}, reqEditors ...interface{}) *ClientInterface_ListBuildAccounts_Call {
	return &ClientInterface_ListBuildAccounts_Call{Call: _e.mock.On("ListBuildAccounts",
		append([]interface{}{ctx, projectID}, reqEditors...)...)}
}

func (_c *ClientInterface_ListBuildAccounts_Call) Run(run func(ctx context.Context, projectID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientInterface_ListBuildAccounts_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_ListBuildAccounts_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_ListBuildAccounts_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_ListBuildAccounts_Call) RunAndReturn(run func(context.Context, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_ListBuildAccounts_Call {
	_c.Call.Return(run)
	return _c
}

// ListBuilds provides a mock function with given fields: ctx, projectID, params, reqEditors
func (_m *ClientInterface) ListBuilds(ctx context.Context, projectID uuid.UUID, params *api.ListBuildsParams, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListBuilds")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, *api.ListBuildsParams, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, *api.ListBuildsParams, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, *api.ListBuildsParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_ListBuilds_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListBuilds'
type ClientInterface_ListBuilds_Call struct {
	*mock.Call
}

// ListBuilds is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - params *api.ListBuildsParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) ListBuilds(ctx interface{}, projectID interface{}, params interface{}, reqEditors ...interface{}) *ClientInterface_ListBuilds_Call {
	return &ClientInterface_ListBuilds_Call{Call: _e.mock.On("ListBuilds",
		append([]interface{}{ctx, projectID, params}, reqEditors...)...)}
}

func (_c *ClientInterface_ListBuilds_Call) Run(run func(ctx context.Context, projectID uuid.UUID, params *api.ListBuildsParams, reqEditors ...api.RequestEditorFn)) *ClientInterface_ListBuilds_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(*api.ListBuildsParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_ListBuilds_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_ListBuilds_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_ListBuilds_Call) RunAndReturn(run func(context.Context, uuid.UUID, *api.ListBuildsParams, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_ListBuilds_Call {
	_c.Call.Return(run)
	return _c
}

// ListBuildsForBranches provides a mock function with given fields: ctx, projectID, branchID, params, reqEditors
func (_m *ClientInterface) ListBuildsForBranches(ctx context.Context, projectID uuid.UUID, branchID []uuid.UUID, params *api.ListBuildsForBranchesParams, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, branchID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListBuildsForBranches")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, []uuid.UUID, *api.ListBuildsForBranchesParams, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, branchID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, []uuid.UUID, *api.ListBuildsForBranchesParams, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, branchID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, []uuid.UUID, *api.ListBuildsForBranchesParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, branchID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_ListBuildsForBranches_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListBuildsForBranches'
type ClientInterface_ListBuildsForBranches_Call struct {
	*mock.Call
}

// ListBuildsForBranches is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - branchID []uuid.UUID
//   - params *api.ListBuildsForBranchesParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) ListBuildsForBranches(ctx interface{}, projectID interface{}, branchID interface{}, params interface{}, reqEditors ...interface{}) *ClientInterface_ListBuildsForBranches_Call {
	return &ClientInterface_ListBuildsForBranches_Call{Call: _e.mock.On("ListBuildsForBranches",
		append([]interface{}{ctx, projectID, branchID, params}, reqEditors...)...)}
}

func (_c *ClientInterface_ListBuildsForBranches_Call) Run(run func(ctx context.Context, projectID uuid.UUID, branchID []uuid.UUID, params *api.ListBuildsForBranchesParams, reqEditors ...api.RequestEditorFn)) *ClientInterface_ListBuildsForBranches_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].([]uuid.UUID), args[3].(*api.ListBuildsForBranchesParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_ListBuildsForBranches_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_ListBuildsForBranches_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_ListBuildsForBranches_Call) RunAndReturn(run func(context.Context, uuid.UUID, []uuid.UUID, *api.ListBuildsForBranchesParams, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_ListBuildsForBranches_Call {
	_c.Call.Return(run)
	return _c
}

// ListBuildsForSystem provides a mock function with given fields: ctx, projectID, systemID, params, reqEditors
func (_m *ClientInterface) ListBuildsForSystem(ctx context.Context, projectID uuid.UUID, systemID uuid.UUID, params *api.ListBuildsForSystemParams, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, systemID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListBuildsForSystem")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, *api.ListBuildsForSystemParams, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, systemID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, *api.ListBuildsForSystemParams, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, systemID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, *api.ListBuildsForSystemParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, systemID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_ListBuildsForSystem_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListBuildsForSystem'
type ClientInterface_ListBuildsForSystem_Call struct {
	*mock.Call
}

// ListBuildsForSystem is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - systemID uuid.UUID
//   - params *api.ListBuildsForSystemParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) ListBuildsForSystem(ctx interface{}, projectID interface{}, systemID interface{}, params interface{}, reqEditors ...interface{}) *ClientInterface_ListBuildsForSystem_Call {
	return &ClientInterface_ListBuildsForSystem_Call{Call: _e.mock.On("ListBuildsForSystem",
		append([]interface{}{ctx, projectID, systemID, params}, reqEditors...)...)}
}

func (_c *ClientInterface_ListBuildsForSystem_Call) Run(run func(ctx context.Context, projectID uuid.UUID, systemID uuid.UUID, params *api.ListBuildsForSystemParams, reqEditors ...api.RequestEditorFn)) *ClientInterface_ListBuildsForSystem_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(*api.ListBuildsForSystemParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_ListBuildsForSystem_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_ListBuildsForSystem_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_ListBuildsForSystem_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, *api.ListBuildsForSystemParams, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_ListBuildsForSystem_Call {
	_c.Call.Return(run)
	return _c
}

// ListEventTagsForJob provides a mock function with given fields: ctx, projectID, batchID, jobID, params, reqEditors
func (_m *ClientInterface) ListEventTagsForJob(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, jobID uuid.UUID, params *api.ListEventTagsForJobParams, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, batchID, jobID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListEventTagsForJob")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, *api.ListEventTagsForJobParams, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, batchID, jobID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, *api.ListEventTagsForJobParams, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, batchID, jobID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, *api.ListEventTagsForJobParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, batchID, jobID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_ListEventTagsForJob_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListEventTagsForJob'
type ClientInterface_ListEventTagsForJob_Call struct {
	*mock.Call
}

// ListEventTagsForJob is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - batchID uuid.UUID
//   - jobID uuid.UUID
//   - params *api.ListEventTagsForJobParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) ListEventTagsForJob(ctx interface{}, projectID interface{}, batchID interface{}, jobID interface{}, params interface{}, reqEditors ...interface{}) *ClientInterface_ListEventTagsForJob_Call {
	return &ClientInterface_ListEventTagsForJob_Call{Call: _e.mock.On("ListEventTagsForJob",
		append([]interface{}{ctx, projectID, batchID, jobID, params}, reqEditors...)...)}
}

func (_c *ClientInterface_ListEventTagsForJob_Call) Run(run func(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, jobID uuid.UUID, params *api.ListEventTagsForJobParams, reqEditors ...api.RequestEditorFn)) *ClientInterface_ListEventTagsForJob_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(uuid.UUID), args[4].(*api.ListEventTagsForJobParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_ListEventTagsForJob_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_ListEventTagsForJob_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_ListEventTagsForJob_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, *api.ListEventTagsForJobParams, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_ListEventTagsForJob_Call {
	_c.Call.Return(run)
	return _c
}

// ListEventsForJob provides a mock function with given fields: ctx, projectID, batchID, jobID, params, reqEditors
func (_m *ClientInterface) ListEventsForJob(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, jobID uuid.UUID, params *api.ListEventsForJobParams, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, batchID, jobID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListEventsForJob")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, *api.ListEventsForJobParams, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, batchID, jobID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, *api.ListEventsForJobParams, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, batchID, jobID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, *api.ListEventsForJobParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, batchID, jobID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_ListEventsForJob_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListEventsForJob'
type ClientInterface_ListEventsForJob_Call struct {
	*mock.Call
}

// ListEventsForJob is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - batchID uuid.UUID
//   - jobID uuid.UUID
//   - params *api.ListEventsForJobParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) ListEventsForJob(ctx interface{}, projectID interface{}, batchID interface{}, jobID interface{}, params interface{}, reqEditors ...interface{}) *ClientInterface_ListEventsForJob_Call {
	return &ClientInterface_ListEventsForJob_Call{Call: _e.mock.On("ListEventsForJob",
		append([]interface{}{ctx, projectID, batchID, jobID, params}, reqEditors...)...)}
}

func (_c *ClientInterface_ListEventsForJob_Call) Run(run func(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, jobID uuid.UUID, params *api.ListEventsForJobParams, reqEditors ...api.RequestEditorFn)) *ClientInterface_ListEventsForJob_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(uuid.UUID), args[4].(*api.ListEventsForJobParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_ListEventsForJob_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_ListEventsForJob_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_ListEventsForJob_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, *api.ListEventsForJobParams, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_ListEventsForJob_Call {
	_c.Call.Return(run)
	return _c
}

// ListExperienceTags provides a mock function with given fields: ctx, projectID, params, reqEditors
func (_m *ClientInterface) ListExperienceTags(ctx context.Context, projectID uuid.UUID, params *api.ListExperienceTagsParams, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListExperienceTags")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, *api.ListExperienceTagsParams, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, *api.ListExperienceTagsParams, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, *api.ListExperienceTagsParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_ListExperienceTags_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListExperienceTags'
type ClientInterface_ListExperienceTags_Call struct {
	*mock.Call
}

// ListExperienceTags is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - params *api.ListExperienceTagsParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) ListExperienceTags(ctx interface{}, projectID interface{}, params interface{}, reqEditors ...interface{}) *ClientInterface_ListExperienceTags_Call {
	return &ClientInterface_ListExperienceTags_Call{Call: _e.mock.On("ListExperienceTags",
		append([]interface{}{ctx, projectID, params}, reqEditors...)...)}
}

func (_c *ClientInterface_ListExperienceTags_Call) Run(run func(ctx context.Context, projectID uuid.UUID, params *api.ListExperienceTagsParams, reqEditors ...api.RequestEditorFn)) *ClientInterface_ListExperienceTags_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(*api.ListExperienceTagsParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_ListExperienceTags_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_ListExperienceTags_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_ListExperienceTags_Call) RunAndReturn(run func(context.Context, uuid.UUID, *api.ListExperienceTagsParams, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_ListExperienceTags_Call {
	_c.Call.Return(run)
	return _c
}

// ListExperienceTagsForExperience provides a mock function with given fields: ctx, projectID, experienceID, params, reqEditors
func (_m *ClientInterface) ListExperienceTagsForExperience(ctx context.Context, projectID uuid.UUID, experienceID uuid.UUID, params *api.ListExperienceTagsForExperienceParams, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, experienceID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListExperienceTagsForExperience")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, *api.ListExperienceTagsForExperienceParams, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, experienceID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, *api.ListExperienceTagsForExperienceParams, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, experienceID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, *api.ListExperienceTagsForExperienceParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, experienceID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_ListExperienceTagsForExperience_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListExperienceTagsForExperience'
type ClientInterface_ListExperienceTagsForExperience_Call struct {
	*mock.Call
}

// ListExperienceTagsForExperience is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - experienceID uuid.UUID
//   - params *api.ListExperienceTagsForExperienceParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) ListExperienceTagsForExperience(ctx interface{}, projectID interface{}, experienceID interface{}, params interface{}, reqEditors ...interface{}) *ClientInterface_ListExperienceTagsForExperience_Call {
	return &ClientInterface_ListExperienceTagsForExperience_Call{Call: _e.mock.On("ListExperienceTagsForExperience",
		append([]interface{}{ctx, projectID, experienceID, params}, reqEditors...)...)}
}

func (_c *ClientInterface_ListExperienceTagsForExperience_Call) Run(run func(ctx context.Context, projectID uuid.UUID, experienceID uuid.UUID, params *api.ListExperienceTagsForExperienceParams, reqEditors ...api.RequestEditorFn)) *ClientInterface_ListExperienceTagsForExperience_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(*api.ListExperienceTagsForExperienceParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_ListExperienceTagsForExperience_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_ListExperienceTagsForExperience_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_ListExperienceTagsForExperience_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, *api.ListExperienceTagsForExperienceParams, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_ListExperienceTagsForExperience_Call {
	_c.Call.Return(run)
	return _c
}

// ListExperiences provides a mock function with given fields: ctx, projectID, params, reqEditors
func (_m *ClientInterface) ListExperiences(ctx context.Context, projectID uuid.UUID, params *api.ListExperiencesParams, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListExperiences")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, *api.ListExperiencesParams, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, *api.ListExperiencesParams, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, *api.ListExperiencesParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_ListExperiences_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListExperiences'
type ClientInterface_ListExperiences_Call struct {
	*mock.Call
}

// ListExperiences is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - params *api.ListExperiencesParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) ListExperiences(ctx interface{}, projectID interface{}, params interface{}, reqEditors ...interface{}) *ClientInterface_ListExperiences_Call {
	return &ClientInterface_ListExperiences_Call{Call: _e.mock.On("ListExperiences",
		append([]interface{}{ctx, projectID, params}, reqEditors...)...)}
}

func (_c *ClientInterface_ListExperiences_Call) Run(run func(ctx context.Context, projectID uuid.UUID, params *api.ListExperiencesParams, reqEditors ...api.RequestEditorFn)) *ClientInterface_ListExperiences_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(*api.ListExperiencesParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_ListExperiences_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_ListExperiences_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_ListExperiences_Call) RunAndReturn(run func(context.Context, uuid.UUID, *api.ListExperiencesParams, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_ListExperiences_Call {
	_c.Call.Return(run)
	return _c
}

// ListExperiencesForSystem provides a mock function with given fields: ctx, projectID, systemID, params, reqEditors
func (_m *ClientInterface) ListExperiencesForSystem(ctx context.Context, projectID uuid.UUID, systemID uuid.UUID, params *api.ListExperiencesForSystemParams, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, systemID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListExperiencesForSystem")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, *api.ListExperiencesForSystemParams, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, systemID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, *api.ListExperiencesForSystemParams, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, systemID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, *api.ListExperiencesForSystemParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, systemID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_ListExperiencesForSystem_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListExperiencesForSystem'
type ClientInterface_ListExperiencesForSystem_Call struct {
	*mock.Call
}

// ListExperiencesForSystem is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - systemID uuid.UUID
//   - params *api.ListExperiencesForSystemParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) ListExperiencesForSystem(ctx interface{}, projectID interface{}, systemID interface{}, params interface{}, reqEditors ...interface{}) *ClientInterface_ListExperiencesForSystem_Call {
	return &ClientInterface_ListExperiencesForSystem_Call{Call: _e.mock.On("ListExperiencesForSystem",
		append([]interface{}{ctx, projectID, systemID, params}, reqEditors...)...)}
}

func (_c *ClientInterface_ListExperiencesForSystem_Call) Run(run func(ctx context.Context, projectID uuid.UUID, systemID uuid.UUID, params *api.ListExperiencesForSystemParams, reqEditors ...api.RequestEditorFn)) *ClientInterface_ListExperiencesForSystem_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(*api.ListExperiencesForSystemParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_ListExperiencesForSystem_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_ListExperiencesForSystem_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_ListExperiencesForSystem_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, *api.ListExperiencesForSystemParams, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_ListExperiencesForSystem_Call {
	_c.Call.Return(run)
	return _c
}

// ListExperiencesWithExperienceTag provides a mock function with given fields: ctx, projectID, experienceTagID, params, reqEditors
func (_m *ClientInterface) ListExperiencesWithExperienceTag(ctx context.Context, projectID uuid.UUID, experienceTagID uuid.UUID, params *api.ListExperiencesWithExperienceTagParams, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, experienceTagID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListExperiencesWithExperienceTag")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, *api.ListExperiencesWithExperienceTagParams, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, experienceTagID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, *api.ListExperiencesWithExperienceTagParams, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, experienceTagID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, *api.ListExperiencesWithExperienceTagParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, experienceTagID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_ListExperiencesWithExperienceTag_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListExperiencesWithExperienceTag'
type ClientInterface_ListExperiencesWithExperienceTag_Call struct {
	*mock.Call
}

// ListExperiencesWithExperienceTag is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - experienceTagID uuid.UUID
//   - params *api.ListExperiencesWithExperienceTagParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) ListExperiencesWithExperienceTag(ctx interface{}, projectID interface{}, experienceTagID interface{}, params interface{}, reqEditors ...interface{}) *ClientInterface_ListExperiencesWithExperienceTag_Call {
	return &ClientInterface_ListExperiencesWithExperienceTag_Call{Call: _e.mock.On("ListExperiencesWithExperienceTag",
		append([]interface{}{ctx, projectID, experienceTagID, params}, reqEditors...)...)}
}

func (_c *ClientInterface_ListExperiencesWithExperienceTag_Call) Run(run func(ctx context.Context, projectID uuid.UUID, experienceTagID uuid.UUID, params *api.ListExperiencesWithExperienceTagParams, reqEditors ...api.RequestEditorFn)) *ClientInterface_ListExperiencesWithExperienceTag_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(*api.ListExperiencesWithExperienceTagParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_ListExperiencesWithExperienceTag_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_ListExperiencesWithExperienceTag_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_ListExperiencesWithExperienceTag_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, *api.ListExperiencesWithExperienceTagParams, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_ListExperiencesWithExperienceTag_Call {
	_c.Call.Return(run)
	return _c
}

// ListJobLogsForJob provides a mock function with given fields: ctx, projectID, batchID, jobID, params, reqEditors
func (_m *ClientInterface) ListJobLogsForJob(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, jobID uuid.UUID, params *api.ListJobLogsForJobParams, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, batchID, jobID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListJobLogsForJob")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, *api.ListJobLogsForJobParams, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, batchID, jobID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, *api.ListJobLogsForJobParams, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, batchID, jobID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, *api.ListJobLogsForJobParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, batchID, jobID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_ListJobLogsForJob_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListJobLogsForJob'
type ClientInterface_ListJobLogsForJob_Call struct {
	*mock.Call
}

// ListJobLogsForJob is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - batchID uuid.UUID
//   - jobID uuid.UUID
//   - params *api.ListJobLogsForJobParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) ListJobLogsForJob(ctx interface{}, projectID interface{}, batchID interface{}, jobID interface{}, params interface{}, reqEditors ...interface{}) *ClientInterface_ListJobLogsForJob_Call {
	return &ClientInterface_ListJobLogsForJob_Call{Call: _e.mock.On("ListJobLogsForJob",
		append([]interface{}{ctx, projectID, batchID, jobID, params}, reqEditors...)...)}
}

func (_c *ClientInterface_ListJobLogsForJob_Call) Run(run func(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, jobID uuid.UUID, params *api.ListJobLogsForJobParams, reqEditors ...api.RequestEditorFn)) *ClientInterface_ListJobLogsForJob_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(uuid.UUID), args[4].(*api.ListJobLogsForJobParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_ListJobLogsForJob_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_ListJobLogsForJob_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_ListJobLogsForJob_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, *api.ListJobLogsForJobParams, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_ListJobLogsForJob_Call {
	_c.Call.Return(run)
	return _c
}

// ListJobs provides a mock function with given fields: ctx, projectID, batchID, params, reqEditors
func (_m *ClientInterface) ListJobs(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, params *api.ListJobsParams, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, batchID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListJobs")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, *api.ListJobsParams, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, batchID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, *api.ListJobsParams, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, batchID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, *api.ListJobsParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, batchID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_ListJobs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListJobs'
type ClientInterface_ListJobs_Call struct {
	*mock.Call
}

// ListJobs is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - batchID uuid.UUID
//   - params *api.ListJobsParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) ListJobs(ctx interface{}, projectID interface{}, batchID interface{}, params interface{}, reqEditors ...interface{}) *ClientInterface_ListJobs_Call {
	return &ClientInterface_ListJobs_Call{Call: _e.mock.On("ListJobs",
		append([]interface{}{ctx, projectID, batchID, params}, reqEditors...)...)}
}

func (_c *ClientInterface_ListJobs_Call) Run(run func(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, params *api.ListJobsParams, reqEditors ...api.RequestEditorFn)) *ClientInterface_ListJobs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(*api.ListJobsParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_ListJobs_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_ListJobs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_ListJobs_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, *api.ListJobsParams, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_ListJobs_Call {
	_c.Call.Return(run)
	return _c
}

// ListLogsForReport provides a mock function with given fields: ctx, projectID, reportID, params, reqEditors
func (_m *ClientInterface) ListLogsForReport(ctx context.Context, projectID uuid.UUID, reportID uuid.UUID, params *api.ListLogsForReportParams, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, reportID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListLogsForReport")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, *api.ListLogsForReportParams, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, reportID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, *api.ListLogsForReportParams, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, reportID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, *api.ListLogsForReportParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, reportID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_ListLogsForReport_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListLogsForReport'
type ClientInterface_ListLogsForReport_Call struct {
	*mock.Call
}

// ListLogsForReport is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - reportID uuid.UUID
//   - params *api.ListLogsForReportParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) ListLogsForReport(ctx interface{}, projectID interface{}, reportID interface{}, params interface{}, reqEditors ...interface{}) *ClientInterface_ListLogsForReport_Call {
	return &ClientInterface_ListLogsForReport_Call{Call: _e.mock.On("ListLogsForReport",
		append([]interface{}{ctx, projectID, reportID, params}, reqEditors...)...)}
}

func (_c *ClientInterface_ListLogsForReport_Call) Run(run func(ctx context.Context, projectID uuid.UUID, reportID uuid.UUID, params *api.ListLogsForReportParams, reqEditors ...api.RequestEditorFn)) *ClientInterface_ListLogsForReport_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(*api.ListLogsForReportParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_ListLogsForReport_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_ListLogsForReport_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_ListLogsForReport_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, *api.ListLogsForReportParams, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_ListLogsForReport_Call {
	_c.Call.Return(run)
	return _c
}

// ListMetricsBuilds provides a mock function with given fields: ctx, projectID, params, reqEditors
func (_m *ClientInterface) ListMetricsBuilds(ctx context.Context, projectID uuid.UUID, params *api.ListMetricsBuildsParams, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListMetricsBuilds")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, *api.ListMetricsBuildsParams, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, *api.ListMetricsBuildsParams, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, *api.ListMetricsBuildsParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_ListMetricsBuilds_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListMetricsBuilds'
type ClientInterface_ListMetricsBuilds_Call struct {
	*mock.Call
}

// ListMetricsBuilds is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - params *api.ListMetricsBuildsParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) ListMetricsBuilds(ctx interface{}, projectID interface{}, params interface{}, reqEditors ...interface{}) *ClientInterface_ListMetricsBuilds_Call {
	return &ClientInterface_ListMetricsBuilds_Call{Call: _e.mock.On("ListMetricsBuilds",
		append([]interface{}{ctx, projectID, params}, reqEditors...)...)}
}

func (_c *ClientInterface_ListMetricsBuilds_Call) Run(run func(ctx context.Context, projectID uuid.UUID, params *api.ListMetricsBuildsParams, reqEditors ...api.RequestEditorFn)) *ClientInterface_ListMetricsBuilds_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(*api.ListMetricsBuildsParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_ListMetricsBuilds_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_ListMetricsBuilds_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_ListMetricsBuilds_Call) RunAndReturn(run func(context.Context, uuid.UUID, *api.ListMetricsBuildsParams, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_ListMetricsBuilds_Call {
	_c.Call.Return(run)
	return _c
}

// ListMetricsDataForJob provides a mock function with given fields: ctx, projectID, batchID, jobID, params, reqEditors
func (_m *ClientInterface) ListMetricsDataForJob(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, jobID uuid.UUID, params *api.ListMetricsDataForJobParams, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, batchID, jobID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListMetricsDataForJob")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, *api.ListMetricsDataForJobParams, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, batchID, jobID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, *api.ListMetricsDataForJobParams, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, batchID, jobID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, *api.ListMetricsDataForJobParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, batchID, jobID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_ListMetricsDataForJob_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListMetricsDataForJob'
type ClientInterface_ListMetricsDataForJob_Call struct {
	*mock.Call
}

// ListMetricsDataForJob is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - batchID uuid.UUID
//   - jobID uuid.UUID
//   - params *api.ListMetricsDataForJobParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) ListMetricsDataForJob(ctx interface{}, projectID interface{}, batchID interface{}, jobID interface{}, params interface{}, reqEditors ...interface{}) *ClientInterface_ListMetricsDataForJob_Call {
	return &ClientInterface_ListMetricsDataForJob_Call{Call: _e.mock.On("ListMetricsDataForJob",
		append([]interface{}{ctx, projectID, batchID, jobID, params}, reqEditors...)...)}
}

func (_c *ClientInterface_ListMetricsDataForJob_Call) Run(run func(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, jobID uuid.UUID, params *api.ListMetricsDataForJobParams, reqEditors ...api.RequestEditorFn)) *ClientInterface_ListMetricsDataForJob_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(uuid.UUID), args[4].(*api.ListMetricsDataForJobParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_ListMetricsDataForJob_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_ListMetricsDataForJob_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_ListMetricsDataForJob_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, *api.ListMetricsDataForJobParams, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_ListMetricsDataForJob_Call {
	_c.Call.Return(run)
	return _c
}

// ListMetricsDataForMetricIDs provides a mock function with given fields: ctx, projectID, batchID, jobID, metricID, params, reqEditors
func (_m *ClientInterface) ListMetricsDataForMetricIDs(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, jobID uuid.UUID, metricID []uuid.UUID, params *api.ListMetricsDataForMetricIDsParams, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, batchID, jobID, metricID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListMetricsDataForMetricIDs")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListMetricsDataForMetricIDsParams, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, batchID, jobID, metricID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListMetricsDataForMetricIDsParams, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, batchID, jobID, metricID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListMetricsDataForMetricIDsParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, batchID, jobID, metricID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_ListMetricsDataForMetricIDs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListMetricsDataForMetricIDs'
type ClientInterface_ListMetricsDataForMetricIDs_Call struct {
	*mock.Call
}

// ListMetricsDataForMetricIDs is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - batchID uuid.UUID
//   - jobID uuid.UUID
//   - metricID []uuid.UUID
//   - params *api.ListMetricsDataForMetricIDsParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) ListMetricsDataForMetricIDs(ctx interface{}, projectID interface{}, batchID interface{}, jobID interface{}, metricID interface{}, params interface{}, reqEditors ...interface{}) *ClientInterface_ListMetricsDataForMetricIDs_Call {
	return &ClientInterface_ListMetricsDataForMetricIDs_Call{Call: _e.mock.On("ListMetricsDataForMetricIDs",
		append([]interface{}{ctx, projectID, batchID, jobID, metricID, params}, reqEditors...)...)}
}

func (_c *ClientInterface_ListMetricsDataForMetricIDs_Call) Run(run func(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, jobID uuid.UUID, metricID []uuid.UUID, params *api.ListMetricsDataForMetricIDsParams, reqEditors ...api.RequestEditorFn)) *ClientInterface_ListMetricsDataForMetricIDs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-6)
		for i, a := range args[6:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(uuid.UUID), args[4].([]uuid.UUID), args[5].(*api.ListMetricsDataForMetricIDsParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_ListMetricsDataForMetricIDs_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_ListMetricsDataForMetricIDs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_ListMetricsDataForMetricIDs_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListMetricsDataForMetricIDsParams, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_ListMetricsDataForMetricIDs_Call {
	_c.Call.Return(run)
	return _c
}

// ListMetricsDataForMetricsDataIDs provides a mock function with given fields: ctx, projectID, batchID, jobID, metricsDataID, params, reqEditors
func (_m *ClientInterface) ListMetricsDataForMetricsDataIDs(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, jobID uuid.UUID, metricsDataID []uuid.UUID, params *api.ListMetricsDataForMetricsDataIDsParams, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, batchID, jobID, metricsDataID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListMetricsDataForMetricsDataIDs")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListMetricsDataForMetricsDataIDsParams, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, batchID, jobID, metricsDataID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListMetricsDataForMetricsDataIDsParams, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, batchID, jobID, metricsDataID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListMetricsDataForMetricsDataIDsParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, batchID, jobID, metricsDataID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_ListMetricsDataForMetricsDataIDs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListMetricsDataForMetricsDataIDs'
type ClientInterface_ListMetricsDataForMetricsDataIDs_Call struct {
	*mock.Call
}

// ListMetricsDataForMetricsDataIDs is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - batchID uuid.UUID
//   - jobID uuid.UUID
//   - metricsDataID []uuid.UUID
//   - params *api.ListMetricsDataForMetricsDataIDsParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) ListMetricsDataForMetricsDataIDs(ctx interface{}, projectID interface{}, batchID interface{}, jobID interface{}, metricsDataID interface{}, params interface{}, reqEditors ...interface{}) *ClientInterface_ListMetricsDataForMetricsDataIDs_Call {
	return &ClientInterface_ListMetricsDataForMetricsDataIDs_Call{Call: _e.mock.On("ListMetricsDataForMetricsDataIDs",
		append([]interface{}{ctx, projectID, batchID, jobID, metricsDataID, params}, reqEditors...)...)}
}

func (_c *ClientInterface_ListMetricsDataForMetricsDataIDs_Call) Run(run func(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, jobID uuid.UUID, metricsDataID []uuid.UUID, params *api.ListMetricsDataForMetricsDataIDsParams, reqEditors ...api.RequestEditorFn)) *ClientInterface_ListMetricsDataForMetricsDataIDs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-6)
		for i, a := range args[6:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(uuid.UUID), args[4].([]uuid.UUID), args[5].(*api.ListMetricsDataForMetricsDataIDsParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_ListMetricsDataForMetricsDataIDs_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_ListMetricsDataForMetricsDataIDs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_ListMetricsDataForMetricsDataIDs_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListMetricsDataForMetricsDataIDsParams, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_ListMetricsDataForMetricsDataIDs_Call {
	_c.Call.Return(run)
	return _c
}

// ListMetricsForJob provides a mock function with given fields: ctx, projectID, batchID, jobID, params, reqEditors
func (_m *ClientInterface) ListMetricsForJob(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, jobID uuid.UUID, params *api.ListMetricsForJobParams, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, batchID, jobID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListMetricsForJob")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, *api.ListMetricsForJobParams, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, batchID, jobID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, *api.ListMetricsForJobParams, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, batchID, jobID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, *api.ListMetricsForJobParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, batchID, jobID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_ListMetricsForJob_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListMetricsForJob'
type ClientInterface_ListMetricsForJob_Call struct {
	*mock.Call
}

// ListMetricsForJob is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - batchID uuid.UUID
//   - jobID uuid.UUID
//   - params *api.ListMetricsForJobParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) ListMetricsForJob(ctx interface{}, projectID interface{}, batchID interface{}, jobID interface{}, params interface{}, reqEditors ...interface{}) *ClientInterface_ListMetricsForJob_Call {
	return &ClientInterface_ListMetricsForJob_Call{Call: _e.mock.On("ListMetricsForJob",
		append([]interface{}{ctx, projectID, batchID, jobID, params}, reqEditors...)...)}
}

func (_c *ClientInterface_ListMetricsForJob_Call) Run(run func(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, jobID uuid.UUID, params *api.ListMetricsForJobParams, reqEditors ...api.RequestEditorFn)) *ClientInterface_ListMetricsForJob_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(uuid.UUID), args[4].(*api.ListMetricsForJobParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_ListMetricsForJob_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_ListMetricsForJob_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_ListMetricsForJob_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, *api.ListMetricsForJobParams, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_ListMetricsForJob_Call {
	_c.Call.Return(run)
	return _c
}

// ListMetricsForMetricIDs provides a mock function with given fields: ctx, projectID, batchID, jobID, metricID, params, reqEditors
func (_m *ClientInterface) ListMetricsForMetricIDs(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, jobID uuid.UUID, metricID []uuid.UUID, params *api.ListMetricsForMetricIDsParams, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, batchID, jobID, metricID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListMetricsForMetricIDs")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListMetricsForMetricIDsParams, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, batchID, jobID, metricID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListMetricsForMetricIDsParams, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, batchID, jobID, metricID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListMetricsForMetricIDsParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, batchID, jobID, metricID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_ListMetricsForMetricIDs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListMetricsForMetricIDs'
type ClientInterface_ListMetricsForMetricIDs_Call struct {
	*mock.Call
}

// ListMetricsForMetricIDs is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - batchID uuid.UUID
//   - jobID uuid.UUID
//   - metricID []uuid.UUID
//   - params *api.ListMetricsForMetricIDsParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) ListMetricsForMetricIDs(ctx interface{}, projectID interface{}, batchID interface{}, jobID interface{}, metricID interface{}, params interface{}, reqEditors ...interface{}) *ClientInterface_ListMetricsForMetricIDs_Call {
	return &ClientInterface_ListMetricsForMetricIDs_Call{Call: _e.mock.On("ListMetricsForMetricIDs",
		append([]interface{}{ctx, projectID, batchID, jobID, metricID, params}, reqEditors...)...)}
}

func (_c *ClientInterface_ListMetricsForMetricIDs_Call) Run(run func(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, jobID uuid.UUID, metricID []uuid.UUID, params *api.ListMetricsForMetricIDsParams, reqEditors ...api.RequestEditorFn)) *ClientInterface_ListMetricsForMetricIDs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-6)
		for i, a := range args[6:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(uuid.UUID), args[4].([]uuid.UUID), args[5].(*api.ListMetricsForMetricIDsParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_ListMetricsForMetricIDs_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_ListMetricsForMetricIDs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_ListMetricsForMetricIDs_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListMetricsForMetricIDsParams, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_ListMetricsForMetricIDs_Call {
	_c.Call.Return(run)
	return _c
}

// ListParameterSweeps provides a mock function with given fields: ctx, projectID, params, reqEditors
func (_m *ClientInterface) ListParameterSweeps(ctx context.Context, projectID uuid.UUID, params *api.ListParameterSweepsParams, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListParameterSweeps")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, *api.ListParameterSweepsParams, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, *api.ListParameterSweepsParams, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, *api.ListParameterSweepsParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_ListParameterSweeps_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListParameterSweeps'
type ClientInterface_ListParameterSweeps_Call struct {
	*mock.Call
}

// ListParameterSweeps is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - params *api.ListParameterSweepsParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) ListParameterSweeps(ctx interface{}, projectID interface{}, params interface{}, reqEditors ...interface{}) *ClientInterface_ListParameterSweeps_Call {
	return &ClientInterface_ListParameterSweeps_Call{Call: _e.mock.On("ListParameterSweeps",
		append([]interface{}{ctx, projectID, params}, reqEditors...)...)}
}

func (_c *ClientInterface_ListParameterSweeps_Call) Run(run func(ctx context.Context, projectID uuid.UUID, params *api.ListParameterSweepsParams, reqEditors ...api.RequestEditorFn)) *ClientInterface_ListParameterSweeps_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(*api.ListParameterSweepsParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_ListParameterSweeps_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_ListParameterSweeps_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_ListParameterSweeps_Call) RunAndReturn(run func(context.Context, uuid.UUID, *api.ListParameterSweepsParams, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_ListParameterSweeps_Call {
	_c.Call.Return(run)
	return _c
}

// ListProjects provides a mock function with given fields: ctx, params, reqEditors
func (_m *ClientInterface) ListProjects(ctx context.Context, params *api.ListProjectsParams, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListProjects")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *api.ListProjectsParams, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *api.ListProjectsParams, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *api.ListProjectsParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_ListProjects_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListProjects'
type ClientInterface_ListProjects_Call struct {
	*mock.Call
}

// ListProjects is a helper method to define mock.On call
//   - ctx context.Context
//   - params *api.ListProjectsParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) ListProjects(ctx interface{}, params interface{}, reqEditors ...interface{}) *ClientInterface_ListProjects_Call {
	return &ClientInterface_ListProjects_Call{Call: _e.mock.On("ListProjects",
		append([]interface{}{ctx, params}, reqEditors...)...)}
}

func (_c *ClientInterface_ListProjects_Call) Run(run func(ctx context.Context, params *api.ListProjectsParams, reqEditors ...api.RequestEditorFn)) *ClientInterface_ListProjects_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(*api.ListProjectsParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_ListProjects_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_ListProjects_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_ListProjects_Call) RunAndReturn(run func(context.Context, *api.ListProjectsParams, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_ListProjects_Call {
	_c.Call.Return(run)
	return _c
}

// ListReportAccounts provides a mock function with given fields: ctx, projectID, reqEditors
func (_m *ClientInterface) ListReportAccounts(ctx context.Context, projectID uuid.UUID, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListReportAccounts")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_ListReportAccounts_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListReportAccounts'
type ClientInterface_ListReportAccounts_Call struct {
	*mock.Call
}

// ListReportAccounts is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) ListReportAccounts(ctx interface{}, projectID interface{}, reqEditors ...interface{}) *ClientInterface_ListReportAccounts_Call {
	return &ClientInterface_ListReportAccounts_Call{Call: _e.mock.On("ListReportAccounts",
		append([]interface{}{ctx, projectID}, reqEditors...)...)}
}

func (_c *ClientInterface_ListReportAccounts_Call) Run(run func(ctx context.Context, projectID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientInterface_ListReportAccounts_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_ListReportAccounts_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_ListReportAccounts_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_ListReportAccounts_Call) RunAndReturn(run func(context.Context, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_ListReportAccounts_Call {
	_c.Call.Return(run)
	return _c
}

// ListReportMetrics provides a mock function with given fields: ctx, projectID, reportID, params, reqEditors
func (_m *ClientInterface) ListReportMetrics(ctx context.Context, projectID uuid.UUID, reportID uuid.UUID, params *api.ListReportMetricsParams, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, reportID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListReportMetrics")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, *api.ListReportMetricsParams, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, reportID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, *api.ListReportMetricsParams, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, reportID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, *api.ListReportMetricsParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, reportID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_ListReportMetrics_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListReportMetrics'
type ClientInterface_ListReportMetrics_Call struct {
	*mock.Call
}

// ListReportMetrics is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - reportID uuid.UUID
//   - params *api.ListReportMetricsParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) ListReportMetrics(ctx interface{}, projectID interface{}, reportID interface{}, params interface{}, reqEditors ...interface{}) *ClientInterface_ListReportMetrics_Call {
	return &ClientInterface_ListReportMetrics_Call{Call: _e.mock.On("ListReportMetrics",
		append([]interface{}{ctx, projectID, reportID, params}, reqEditors...)...)}
}

func (_c *ClientInterface_ListReportMetrics_Call) Run(run func(ctx context.Context, projectID uuid.UUID, reportID uuid.UUID, params *api.ListReportMetricsParams, reqEditors ...api.RequestEditorFn)) *ClientInterface_ListReportMetrics_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(*api.ListReportMetricsParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_ListReportMetrics_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_ListReportMetrics_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_ListReportMetrics_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, *api.ListReportMetricsParams, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_ListReportMetrics_Call {
	_c.Call.Return(run)
	return _c
}

// ListReportMetricsData provides a mock function with given fields: ctx, projectID, reportID, params, reqEditors
func (_m *ClientInterface) ListReportMetricsData(ctx context.Context, projectID uuid.UUID, reportID uuid.UUID, params *api.ListReportMetricsDataParams, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, reportID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListReportMetricsData")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, *api.ListReportMetricsDataParams, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, reportID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, *api.ListReportMetricsDataParams, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, reportID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, *api.ListReportMetricsDataParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, reportID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_ListReportMetricsData_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListReportMetricsData'
type ClientInterface_ListReportMetricsData_Call struct {
	*mock.Call
}

// ListReportMetricsData is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - reportID uuid.UUID
//   - params *api.ListReportMetricsDataParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) ListReportMetricsData(ctx interface{}, projectID interface{}, reportID interface{}, params interface{}, reqEditors ...interface{}) *ClientInterface_ListReportMetricsData_Call {
	return &ClientInterface_ListReportMetricsData_Call{Call: _e.mock.On("ListReportMetricsData",
		append([]interface{}{ctx, projectID, reportID, params}, reqEditors...)...)}
}

func (_c *ClientInterface_ListReportMetricsData_Call) Run(run func(ctx context.Context, projectID uuid.UUID, reportID uuid.UUID, params *api.ListReportMetricsDataParams, reqEditors ...api.RequestEditorFn)) *ClientInterface_ListReportMetricsData_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(*api.ListReportMetricsDataParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_ListReportMetricsData_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_ListReportMetricsData_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_ListReportMetricsData_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, *api.ListReportMetricsDataParams, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_ListReportMetricsData_Call {
	_c.Call.Return(run)
	return _c
}

// ListReportMetricsDataForReportMetricIDs provides a mock function with given fields: ctx, projectID, reportID, metricID, params, reqEditors
func (_m *ClientInterface) ListReportMetricsDataForReportMetricIDs(ctx context.Context, projectID uuid.UUID, reportID uuid.UUID, metricID []uuid.UUID, params *api.ListReportMetricsDataForReportMetricIDsParams, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, reportID, metricID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListReportMetricsDataForReportMetricIDs")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListReportMetricsDataForReportMetricIDsParams, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, reportID, metricID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListReportMetricsDataForReportMetricIDsParams, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, reportID, metricID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListReportMetricsDataForReportMetricIDsParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, reportID, metricID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_ListReportMetricsDataForReportMetricIDs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListReportMetricsDataForReportMetricIDs'
type ClientInterface_ListReportMetricsDataForReportMetricIDs_Call struct {
	*mock.Call
}

// ListReportMetricsDataForReportMetricIDs is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - reportID uuid.UUID
//   - metricID []uuid.UUID
//   - params *api.ListReportMetricsDataForReportMetricIDsParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) ListReportMetricsDataForReportMetricIDs(ctx interface{}, projectID interface{}, reportID interface{}, metricID interface{}, params interface{}, reqEditors ...interface{}) *ClientInterface_ListReportMetricsDataForReportMetricIDs_Call {
	return &ClientInterface_ListReportMetricsDataForReportMetricIDs_Call{Call: _e.mock.On("ListReportMetricsDataForReportMetricIDs",
		append([]interface{}{ctx, projectID, reportID, metricID, params}, reqEditors...)...)}
}

func (_c *ClientInterface_ListReportMetricsDataForReportMetricIDs_Call) Run(run func(ctx context.Context, projectID uuid.UUID, reportID uuid.UUID, metricID []uuid.UUID, params *api.ListReportMetricsDataForReportMetricIDsParams, reqEditors ...api.RequestEditorFn)) *ClientInterface_ListReportMetricsDataForReportMetricIDs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].([]uuid.UUID), args[4].(*api.ListReportMetricsDataForReportMetricIDsParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_ListReportMetricsDataForReportMetricIDs_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_ListReportMetricsDataForReportMetricIDs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_ListReportMetricsDataForReportMetricIDs_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListReportMetricsDataForReportMetricIDsParams, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_ListReportMetricsDataForReportMetricIDs_Call {
	_c.Call.Return(run)
	return _c
}

// ListReportMetricsDataForReportMetricsDataIDs provides a mock function with given fields: ctx, projectID, reportID, metricsDataID, params, reqEditors
func (_m *ClientInterface) ListReportMetricsDataForReportMetricsDataIDs(ctx context.Context, projectID uuid.UUID, reportID uuid.UUID, metricsDataID []uuid.UUID, params *api.ListReportMetricsDataForReportMetricsDataIDsParams, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, reportID, metricsDataID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListReportMetricsDataForReportMetricsDataIDs")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListReportMetricsDataForReportMetricsDataIDsParams, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, reportID, metricsDataID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListReportMetricsDataForReportMetricsDataIDsParams, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, reportID, metricsDataID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListReportMetricsDataForReportMetricsDataIDsParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, reportID, metricsDataID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_ListReportMetricsDataForReportMetricsDataIDs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListReportMetricsDataForReportMetricsDataIDs'
type ClientInterface_ListReportMetricsDataForReportMetricsDataIDs_Call struct {
	*mock.Call
}

// ListReportMetricsDataForReportMetricsDataIDs is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - reportID uuid.UUID
//   - metricsDataID []uuid.UUID
//   - params *api.ListReportMetricsDataForReportMetricsDataIDsParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) ListReportMetricsDataForReportMetricsDataIDs(ctx interface{}, projectID interface{}, reportID interface{}, metricsDataID interface{}, params interface{}, reqEditors ...interface{}) *ClientInterface_ListReportMetricsDataForReportMetricsDataIDs_Call {
	return &ClientInterface_ListReportMetricsDataForReportMetricsDataIDs_Call{Call: _e.mock.On("ListReportMetricsDataForReportMetricsDataIDs",
		append([]interface{}{ctx, projectID, reportID, metricsDataID, params}, reqEditors...)...)}
}

func (_c *ClientInterface_ListReportMetricsDataForReportMetricsDataIDs_Call) Run(run func(ctx context.Context, projectID uuid.UUID, reportID uuid.UUID, metricsDataID []uuid.UUID, params *api.ListReportMetricsDataForReportMetricsDataIDsParams, reqEditors ...api.RequestEditorFn)) *ClientInterface_ListReportMetricsDataForReportMetricsDataIDs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].([]uuid.UUID), args[4].(*api.ListReportMetricsDataForReportMetricsDataIDsParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_ListReportMetricsDataForReportMetricsDataIDs_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_ListReportMetricsDataForReportMetricsDataIDs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_ListReportMetricsDataForReportMetricsDataIDs_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListReportMetricsDataForReportMetricsDataIDsParams, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_ListReportMetricsDataForReportMetricsDataIDs_Call {
	_c.Call.Return(run)
	return _c
}

// ListReportMetricsForReportMetricIDs provides a mock function with given fields: ctx, projectID, reportID, metricID, params, reqEditors
func (_m *ClientInterface) ListReportMetricsForReportMetricIDs(ctx context.Context, projectID uuid.UUID, reportID uuid.UUID, metricID []uuid.UUID, params *api.ListReportMetricsForReportMetricIDsParams, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, reportID, metricID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListReportMetricsForReportMetricIDs")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListReportMetricsForReportMetricIDsParams, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, reportID, metricID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListReportMetricsForReportMetricIDsParams, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, reportID, metricID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListReportMetricsForReportMetricIDsParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, reportID, metricID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_ListReportMetricsForReportMetricIDs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListReportMetricsForReportMetricIDs'
type ClientInterface_ListReportMetricsForReportMetricIDs_Call struct {
	*mock.Call
}

// ListReportMetricsForReportMetricIDs is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - reportID uuid.UUID
//   - metricID []uuid.UUID
//   - params *api.ListReportMetricsForReportMetricIDsParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) ListReportMetricsForReportMetricIDs(ctx interface{}, projectID interface{}, reportID interface{}, metricID interface{}, params interface{}, reqEditors ...interface{}) *ClientInterface_ListReportMetricsForReportMetricIDs_Call {
	return &ClientInterface_ListReportMetricsForReportMetricIDs_Call{Call: _e.mock.On("ListReportMetricsForReportMetricIDs",
		append([]interface{}{ctx, projectID, reportID, metricID, params}, reqEditors...)...)}
}

func (_c *ClientInterface_ListReportMetricsForReportMetricIDs_Call) Run(run func(ctx context.Context, projectID uuid.UUID, reportID uuid.UUID, metricID []uuid.UUID, params *api.ListReportMetricsForReportMetricIDsParams, reqEditors ...api.RequestEditorFn)) *ClientInterface_ListReportMetricsForReportMetricIDs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].([]uuid.UUID), args[4].(*api.ListReportMetricsForReportMetricIDsParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_ListReportMetricsForReportMetricIDs_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_ListReportMetricsForReportMetricIDs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_ListReportMetricsForReportMetricIDs_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListReportMetricsForReportMetricIDsParams, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_ListReportMetricsForReportMetricIDs_Call {
	_c.Call.Return(run)
	return _c
}

// ListReports provides a mock function with given fields: ctx, projectID, params, reqEditors
func (_m *ClientInterface) ListReports(ctx context.Context, projectID uuid.UUID, params *api.ListReportsParams, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListReports")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, *api.ListReportsParams, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, *api.ListReportsParams, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, *api.ListReportsParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_ListReports_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListReports'
type ClientInterface_ListReports_Call struct {
	*mock.Call
}

// ListReports is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - params *api.ListReportsParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) ListReports(ctx interface{}, projectID interface{}, params interface{}, reqEditors ...interface{}) *ClientInterface_ListReports_Call {
	return &ClientInterface_ListReports_Call{Call: _e.mock.On("ListReports",
		append([]interface{}{ctx, projectID, params}, reqEditors...)...)}
}

func (_c *ClientInterface_ListReports_Call) Run(run func(ctx context.Context, projectID uuid.UUID, params *api.ListReportsParams, reqEditors ...api.RequestEditorFn)) *ClientInterface_ListReports_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(*api.ListReportsParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_ListReports_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_ListReports_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_ListReports_Call) RunAndReturn(run func(context.Context, uuid.UUID, *api.ListReportsParams, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_ListReports_Call {
	_c.Call.Return(run)
	return _c
}

// ListServiceProfiles provides a mock function with given fields: ctx, projectID, reqEditors
func (_m *ClientInterface) ListServiceProfiles(ctx context.Context, projectID uuid.UUID, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListServiceProfiles")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_ListServiceProfiles_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListServiceProfiles'
type ClientInterface_ListServiceProfiles_Call struct {
	*mock.Call
}

// ListServiceProfiles is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) ListServiceProfiles(ctx interface{}, projectID interface{}, reqEditors ...interface{}) *ClientInterface_ListServiceProfiles_Call {
	return &ClientInterface_ListServiceProfiles_Call{Call: _e.mock.On("ListServiceProfiles",
		append([]interface{}{ctx, projectID}, reqEditors...)...)}
}

func (_c *ClientInterface_ListServiceProfiles_Call) Run(run func(ctx context.Context, projectID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientInterface_ListServiceProfiles_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_ListServiceProfiles_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_ListServiceProfiles_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_ListServiceProfiles_Call) RunAndReturn(run func(context.Context, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_ListServiceProfiles_Call {
	_c.Call.Return(run)
	return _c
}

// ListSweepAccounts provides a mock function with given fields: ctx, projectID, reqEditors
func (_m *ClientInterface) ListSweepAccounts(ctx context.Context, projectID uuid.UUID, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListSweepAccounts")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_ListSweepAccounts_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListSweepAccounts'
type ClientInterface_ListSweepAccounts_Call struct {
	*mock.Call
}

// ListSweepAccounts is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) ListSweepAccounts(ctx interface{}, projectID interface{}, reqEditors ...interface{}) *ClientInterface_ListSweepAccounts_Call {
	return &ClientInterface_ListSweepAccounts_Call{Call: _e.mock.On("ListSweepAccounts",
		append([]interface{}{ctx, projectID}, reqEditors...)...)}
}

func (_c *ClientInterface_ListSweepAccounts_Call) Run(run func(ctx context.Context, projectID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientInterface_ListSweepAccounts_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_ListSweepAccounts_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_ListSweepAccounts_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_ListSweepAccounts_Call) RunAndReturn(run func(context.Context, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_ListSweepAccounts_Call {
	_c.Call.Return(run)
	return _c
}

// ListSystems provides a mock function with given fields: ctx, projectID, params, reqEditors
func (_m *ClientInterface) ListSystems(ctx context.Context, projectID uuid.UUID, params *api.ListSystemsParams, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListSystems")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, *api.ListSystemsParams, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, *api.ListSystemsParams, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, *api.ListSystemsParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_ListSystems_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListSystems'
type ClientInterface_ListSystems_Call struct {
	*mock.Call
}

// ListSystems is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - params *api.ListSystemsParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) ListSystems(ctx interface{}, projectID interface{}, params interface{}, reqEditors ...interface{}) *ClientInterface_ListSystems_Call {
	return &ClientInterface_ListSystems_Call{Call: _e.mock.On("ListSystems",
		append([]interface{}{ctx, projectID, params}, reqEditors...)...)}
}

func (_c *ClientInterface_ListSystems_Call) Run(run func(ctx context.Context, projectID uuid.UUID, params *api.ListSystemsParams, reqEditors ...api.RequestEditorFn)) *ClientInterface_ListSystems_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(*api.ListSystemsParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_ListSystems_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_ListSystems_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_ListSystems_Call) RunAndReturn(run func(context.Context, uuid.UUID, *api.ListSystemsParams, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_ListSystems_Call {
	_c.Call.Return(run)
	return _c
}

// ListTagsForBatchMetrics provides a mock function with given fields: ctx, projectID, batchID, metricID, params, reqEditors
func (_m *ClientInterface) ListTagsForBatchMetrics(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, metricID []uuid.UUID, params *api.ListTagsForBatchMetricsParams, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, batchID, metricID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTagsForBatchMetrics")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListTagsForBatchMetricsParams, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, batchID, metricID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListTagsForBatchMetricsParams, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, batchID, metricID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListTagsForBatchMetricsParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, batchID, metricID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_ListTagsForBatchMetrics_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListTagsForBatchMetrics'
type ClientInterface_ListTagsForBatchMetrics_Call struct {
	*mock.Call
}

// ListTagsForBatchMetrics is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - batchID uuid.UUID
//   - metricID []uuid.UUID
//   - params *api.ListTagsForBatchMetricsParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) ListTagsForBatchMetrics(ctx interface{}, projectID interface{}, batchID interface{}, metricID interface{}, params interface{}, reqEditors ...interface{}) *ClientInterface_ListTagsForBatchMetrics_Call {
	return &ClientInterface_ListTagsForBatchMetrics_Call{Call: _e.mock.On("ListTagsForBatchMetrics",
		append([]interface{}{ctx, projectID, batchID, metricID, params}, reqEditors...)...)}
}

func (_c *ClientInterface_ListTagsForBatchMetrics_Call) Run(run func(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, metricID []uuid.UUID, params *api.ListTagsForBatchMetricsParams, reqEditors ...api.RequestEditorFn)) *ClientInterface_ListTagsForBatchMetrics_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].([]uuid.UUID), args[4].(*api.ListTagsForBatchMetricsParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_ListTagsForBatchMetrics_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_ListTagsForBatchMetrics_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_ListTagsForBatchMetrics_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListTagsForBatchMetricsParams, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_ListTagsForBatchMetrics_Call {
	_c.Call.Return(run)
	return _c
}

// ListTagsForJobMetrics provides a mock function with given fields: ctx, projectID, batchID, jobID, metricID, params, reqEditors
func (_m *ClientInterface) ListTagsForJobMetrics(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, jobID uuid.UUID, metricID []uuid.UUID, params *api.ListTagsForJobMetricsParams, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, batchID, jobID, metricID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTagsForJobMetrics")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListTagsForJobMetricsParams, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, batchID, jobID, metricID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListTagsForJobMetricsParams, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, batchID, jobID, metricID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListTagsForJobMetricsParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, batchID, jobID, metricID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_ListTagsForJobMetrics_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListTagsForJobMetrics'
type ClientInterface_ListTagsForJobMetrics_Call struct {
	*mock.Call
}

// ListTagsForJobMetrics is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - batchID uuid.UUID
//   - jobID uuid.UUID
//   - metricID []uuid.UUID
//   - params *api.ListTagsForJobMetricsParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) ListTagsForJobMetrics(ctx interface{}, projectID interface{}, batchID interface{}, jobID interface{}, metricID interface{}, params interface{}, reqEditors ...interface{}) *ClientInterface_ListTagsForJobMetrics_Call {
	return &ClientInterface_ListTagsForJobMetrics_Call{Call: _e.mock.On("ListTagsForJobMetrics",
		append([]interface{}{ctx, projectID, batchID, jobID, metricID, params}, reqEditors...)...)}
}

func (_c *ClientInterface_ListTagsForJobMetrics_Call) Run(run func(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, jobID uuid.UUID, metricID []uuid.UUID, params *api.ListTagsForJobMetricsParams, reqEditors ...api.RequestEditorFn)) *ClientInterface_ListTagsForJobMetrics_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-6)
		for i, a := range args[6:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(uuid.UUID), args[4].([]uuid.UUID), args[5].(*api.ListTagsForJobMetricsParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_ListTagsForJobMetrics_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_ListTagsForJobMetrics_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_ListTagsForJobMetrics_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListTagsForJobMetricsParams, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_ListTagsForJobMetrics_Call {
	_c.Call.Return(run)
	return _c
}

// ListTagsForReportMetrics provides a mock function with given fields: ctx, projectID, reportID, metricID, params, reqEditors
func (_m *ClientInterface) ListTagsForReportMetrics(ctx context.Context, projectID uuid.UUID, reportID uuid.UUID, metricID []uuid.UUID, params *api.ListTagsForReportMetricsParams, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, reportID, metricID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTagsForReportMetrics")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListTagsForReportMetricsParams, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, reportID, metricID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListTagsForReportMetricsParams, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, reportID, metricID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListTagsForReportMetricsParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, reportID, metricID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_ListTagsForReportMetrics_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListTagsForReportMetrics'
type ClientInterface_ListTagsForReportMetrics_Call struct {
	*mock.Call
}

// ListTagsForReportMetrics is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - reportID uuid.UUID
//   - metricID []uuid.UUID
//   - params *api.ListTagsForReportMetricsParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) ListTagsForReportMetrics(ctx interface{}, projectID interface{}, reportID interface{}, metricID interface{}, params interface{}, reqEditors ...interface{}) *ClientInterface_ListTagsForReportMetrics_Call {
	return &ClientInterface_ListTagsForReportMetrics_Call{Call: _e.mock.On("ListTagsForReportMetrics",
		append([]interface{}{ctx, projectID, reportID, metricID, params}, reqEditors...)...)}
}

func (_c *ClientInterface_ListTagsForReportMetrics_Call) Run(run func(ctx context.Context, projectID uuid.UUID, reportID uuid.UUID, metricID []uuid.UUID, params *api.ListTagsForReportMetricsParams, reqEditors ...api.RequestEditorFn)) *ClientInterface_ListTagsForReportMetrics_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].([]uuid.UUID), args[4].(*api.ListTagsForReportMetricsParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_ListTagsForReportMetrics_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_ListTagsForReportMetrics_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_ListTagsForReportMetrics_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListTagsForReportMetricsParams, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_ListTagsForReportMetrics_Call {
	_c.Call.Return(run)
	return _c
}

// ListTestSuiteRevisions provides a mock function with given fields: ctx, projectID, testSuiteID, params, reqEditors
func (_m *ClientInterface) ListTestSuiteRevisions(ctx context.Context, projectID uuid.UUID, testSuiteID uuid.UUID, params *api.ListTestSuiteRevisionsParams, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, testSuiteID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTestSuiteRevisions")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, *api.ListTestSuiteRevisionsParams, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, testSuiteID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, *api.ListTestSuiteRevisionsParams, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, testSuiteID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, *api.ListTestSuiteRevisionsParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, testSuiteID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_ListTestSuiteRevisions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListTestSuiteRevisions'
type ClientInterface_ListTestSuiteRevisions_Call struct {
	*mock.Call
}

// ListTestSuiteRevisions is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - testSuiteID uuid.UUID
//   - params *api.ListTestSuiteRevisionsParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) ListTestSuiteRevisions(ctx interface{}, projectID interface{}, testSuiteID interface{}, params interface{}, reqEditors ...interface{}) *ClientInterface_ListTestSuiteRevisions_Call {
	return &ClientInterface_ListTestSuiteRevisions_Call{Call: _e.mock.On("ListTestSuiteRevisions",
		append([]interface{}{ctx, projectID, testSuiteID, params}, reqEditors...)...)}
}

func (_c *ClientInterface_ListTestSuiteRevisions_Call) Run(run func(ctx context.Context, projectID uuid.UUID, testSuiteID uuid.UUID, params *api.ListTestSuiteRevisionsParams, reqEditors ...api.RequestEditorFn)) *ClientInterface_ListTestSuiteRevisions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(*api.ListTestSuiteRevisionsParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_ListTestSuiteRevisions_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_ListTestSuiteRevisions_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_ListTestSuiteRevisions_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, *api.ListTestSuiteRevisionsParams, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_ListTestSuiteRevisions_Call {
	_c.Call.Return(run)
	return _c
}

// ListTestSuites provides a mock function with given fields: ctx, projectID, params, reqEditors
func (_m *ClientInterface) ListTestSuites(ctx context.Context, projectID uuid.UUID, params *api.ListTestSuitesParams, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTestSuites")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, *api.ListTestSuitesParams, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, *api.ListTestSuitesParams, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, *api.ListTestSuitesParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_ListTestSuites_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListTestSuites'
type ClientInterface_ListTestSuites_Call struct {
	*mock.Call
}

// ListTestSuites is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - params *api.ListTestSuitesParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) ListTestSuites(ctx interface{}, projectID interface{}, params interface{}, reqEditors ...interface{}) *ClientInterface_ListTestSuites_Call {
	return &ClientInterface_ListTestSuites_Call{Call: _e.mock.On("ListTestSuites",
		append([]interface{}{ctx, projectID, params}, reqEditors...)...)}
}

func (_c *ClientInterface_ListTestSuites_Call) Run(run func(ctx context.Context, projectID uuid.UUID, params *api.ListTestSuitesParams, reqEditors ...api.RequestEditorFn)) *ClientInterface_ListTestSuites_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(*api.ListTestSuitesParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_ListTestSuites_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_ListTestSuites_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_ListTestSuites_Call) RunAndReturn(run func(context.Context, uuid.UUID, *api.ListTestSuitesParams, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_ListTestSuites_Call {
	_c.Call.Return(run)
	return _c
}

// ListViewSessions provides a mock function with given fields: ctx, params, reqEditors
func (_m *ClientInterface) ListViewSessions(ctx context.Context, params *api.ListViewSessionsParams, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListViewSessions")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *api.ListViewSessionsParams, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *api.ListViewSessionsParams, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *api.ListViewSessionsParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_ListViewSessions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListViewSessions'
type ClientInterface_ListViewSessions_Call struct {
	*mock.Call
}

// ListViewSessions is a helper method to define mock.On call
//   - ctx context.Context
//   - params *api.ListViewSessionsParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) ListViewSessions(ctx interface{}, params interface{}, reqEditors ...interface{}) *ClientInterface_ListViewSessions_Call {
	return &ClientInterface_ListViewSessions_Call{Call: _e.mock.On("ListViewSessions",
		append([]interface{}{ctx, params}, reqEditors...)...)}
}

func (_c *ClientInterface_ListViewSessions_Call) Run(run func(ctx context.Context, params *api.ListViewSessionsParams, reqEditors ...api.RequestEditorFn)) *ClientInterface_ListViewSessions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(*api.ListViewSessionsParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_ListViewSessions_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_ListViewSessions_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_ListViewSessions_Call) RunAndReturn(run func(context.Context, *api.ListViewSessionsParams, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_ListViewSessions_Call {
	_c.Call.Return(run)
	return _c
}

// ListWorkflowRuns provides a mock function with given fields: ctx, projectID, workflowID, params, reqEditors
func (_m *ClientInterface) ListWorkflowRuns(ctx context.Context, projectID uuid.UUID, workflowID uuid.UUID, params *api.ListWorkflowRunsParams, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, workflowID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListWorkflowRuns")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, *api.ListWorkflowRunsParams, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, workflowID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, *api.ListWorkflowRunsParams, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, workflowID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, *api.ListWorkflowRunsParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, workflowID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_ListWorkflowRuns_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListWorkflowRuns'
type ClientInterface_ListWorkflowRuns_Call struct {
	*mock.Call
}

// ListWorkflowRuns is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - workflowID uuid.UUID
//   - params *api.ListWorkflowRunsParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) ListWorkflowRuns(ctx interface{}, projectID interface{}, workflowID interface{}, params interface{}, reqEditors ...interface{}) *ClientInterface_ListWorkflowRuns_Call {
	return &ClientInterface_ListWorkflowRuns_Call{Call: _e.mock.On("ListWorkflowRuns",
		append([]interface{}{ctx, projectID, workflowID, params}, reqEditors...)...)}
}

func (_c *ClientInterface_ListWorkflowRuns_Call) Run(run func(ctx context.Context, projectID uuid.UUID, workflowID uuid.UUID, params *api.ListWorkflowRunsParams, reqEditors ...api.RequestEditorFn)) *ClientInterface_ListWorkflowRuns_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(*api.ListWorkflowRunsParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_ListWorkflowRuns_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_ListWorkflowRuns_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_ListWorkflowRuns_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, *api.ListWorkflowRunsParams, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_ListWorkflowRuns_Call {
	_c.Call.Return(run)
	return _c
}

// ListWorkflowSuites provides a mock function with given fields: ctx, projectID, workflowID, reqEditors
func (_m *ClientInterface) ListWorkflowSuites(ctx context.Context, projectID uuid.UUID, workflowID uuid.UUID, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, workflowID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListWorkflowSuites")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, workflowID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, workflowID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, workflowID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_ListWorkflowSuites_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListWorkflowSuites'
type ClientInterface_ListWorkflowSuites_Call struct {
	*mock.Call
}

// ListWorkflowSuites is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - workflowID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) ListWorkflowSuites(ctx interface{}, projectID interface{}, workflowID interface{}, reqEditors ...interface{}) *ClientInterface_ListWorkflowSuites_Call {
	return &ClientInterface_ListWorkflowSuites_Call{Call: _e.mock.On("ListWorkflowSuites",
		append([]interface{}{ctx, projectID, workflowID}, reqEditors...)...)}
}

func (_c *ClientInterface_ListWorkflowSuites_Call) Run(run func(ctx context.Context, projectID uuid.UUID, workflowID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientInterface_ListWorkflowSuites_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_ListWorkflowSuites_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_ListWorkflowSuites_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_ListWorkflowSuites_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_ListWorkflowSuites_Call {
	_c.Call.Return(run)
	return _c
}

// ListWorkflows provides a mock function with given fields: ctx, projectID, params, reqEditors
func (_m *ClientInterface) ListWorkflows(ctx context.Context, projectID uuid.UUID, params *api.ListWorkflowsParams, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListWorkflows")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, *api.ListWorkflowsParams, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, *api.ListWorkflowsParams, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, *api.ListWorkflowsParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_ListWorkflows_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListWorkflows'
type ClientInterface_ListWorkflows_Call struct {
	*mock.Call
}

// ListWorkflows is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - params *api.ListWorkflowsParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) ListWorkflows(ctx interface{}, projectID interface{}, params interface{}, reqEditors ...interface{}) *ClientInterface_ListWorkflows_Call {
	return &ClientInterface_ListWorkflows_Call{Call: _e.mock.On("ListWorkflows",
		append([]interface{}{ctx, projectID, params}, reqEditors...)...)}
}

func (_c *ClientInterface_ListWorkflows_Call) Run(run func(ctx context.Context, projectID uuid.UUID, params *api.ListWorkflowsParams, reqEditors ...api.RequestEditorFn)) *ClientInterface_ListWorkflows_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(*api.ListWorkflowsParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_ListWorkflows_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_ListWorkflows_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_ListWorkflows_Call) RunAndReturn(run func(context.Context, uuid.UUID, *api.ListWorkflowsParams, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_ListWorkflows_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveExperienceTagFromExperience provides a mock function with given fields: ctx, projectID, experienceTagID, experienceID, reqEditors
func (_m *ClientInterface) RemoveExperienceTagFromExperience(ctx context.Context, projectID uuid.UUID, experienceTagID uuid.UUID, experienceID uuid.UUID, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, experienceTagID, experienceID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RemoveExperienceTagFromExperience")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, experienceTagID, experienceID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, experienceTagID, experienceID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, experienceTagID, experienceID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_RemoveExperienceTagFromExperience_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveExperienceTagFromExperience'
type ClientInterface_RemoveExperienceTagFromExperience_Call struct {
	*mock.Call
}

// RemoveExperienceTagFromExperience is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - experienceTagID uuid.UUID
//   - experienceID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) RemoveExperienceTagFromExperience(ctx interface{}, projectID interface{}, experienceTagID interface{}, experienceID interface{}, reqEditors ...interface{}) *ClientInterface_RemoveExperienceTagFromExperience_Call {
	return &ClientInterface_RemoveExperienceTagFromExperience_Call{Call: _e.mock.On("RemoveExperienceTagFromExperience",
		append([]interface{}{ctx, projectID, experienceTagID, experienceID}, reqEditors...)...)}
}

func (_c *ClientInterface_RemoveExperienceTagFromExperience_Call) Run(run func(ctx context.Context, projectID uuid.UUID, experienceTagID uuid.UUID, experienceID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientInterface_RemoveExperienceTagFromExperience_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_RemoveExperienceTagFromExperience_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_RemoveExperienceTagFromExperience_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_RemoveExperienceTagFromExperience_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_RemoveExperienceTagFromExperience_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveExperiencesFromTestSuite provides a mock function with given fields: ctx, projectID, testSuiteID, body, reqEditors
func (_m *ClientInterface) RemoveExperiencesFromTestSuite(ctx context.Context, projectID uuid.UUID, testSuiteID uuid.UUID, body api.SelectExperiencesInput, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, testSuiteID, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RemoveExperiencesFromTestSuite")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, api.SelectExperiencesInput, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, testSuiteID, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, api.SelectExperiencesInput, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, testSuiteID, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, api.SelectExperiencesInput, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, testSuiteID, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_RemoveExperiencesFromTestSuite_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveExperiencesFromTestSuite'
type ClientInterface_RemoveExperiencesFromTestSuite_Call struct {
	*mock.Call
}

// RemoveExperiencesFromTestSuite is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - testSuiteID uuid.UUID
//   - body api.SelectExperiencesInput
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) RemoveExperiencesFromTestSuite(ctx interface{}, projectID interface{}, testSuiteID interface{}, body interface{}, reqEditors ...interface{}) *ClientInterface_RemoveExperiencesFromTestSuite_Call {
	return &ClientInterface_RemoveExperiencesFromTestSuite_Call{Call: _e.mock.On("RemoveExperiencesFromTestSuite",
		append([]interface{}{ctx, projectID, testSuiteID, body}, reqEditors...)...)}
}

func (_c *ClientInterface_RemoveExperiencesFromTestSuite_Call) Run(run func(ctx context.Context, projectID uuid.UUID, testSuiteID uuid.UUID, body api.SelectExperiencesInput, reqEditors ...api.RequestEditorFn)) *ClientInterface_RemoveExperiencesFromTestSuite_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(api.SelectExperiencesInput), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_RemoveExperiencesFromTestSuite_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_RemoveExperiencesFromTestSuite_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_RemoveExperiencesFromTestSuite_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, api.SelectExperiencesInput, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_RemoveExperiencesFromTestSuite_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveExperiencesFromTestSuiteWithBody provides a mock function with given fields: ctx, projectID, testSuiteID, contentType, body, reqEditors
func (_m *ClientInterface) RemoveExperiencesFromTestSuiteWithBody(ctx context.Context, projectID uuid.UUID, testSuiteID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, testSuiteID, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RemoveExperiencesFromTestSuiteWithBody")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, testSuiteID, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, testSuiteID, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, testSuiteID, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_RemoveExperiencesFromTestSuiteWithBody_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveExperiencesFromTestSuiteWithBody'
type ClientInterface_RemoveExperiencesFromTestSuiteWithBody_Call struct {
	*mock.Call
}

// RemoveExperiencesFromTestSuiteWithBody is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - testSuiteID uuid.UUID
//   - contentType string
//   - body io.Reader
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) RemoveExperiencesFromTestSuiteWithBody(ctx interface{}, projectID interface{}, testSuiteID interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *ClientInterface_RemoveExperiencesFromTestSuiteWithBody_Call {
	return &ClientInterface_RemoveExperiencesFromTestSuiteWithBody_Call{Call: _e.mock.On("RemoveExperiencesFromTestSuiteWithBody",
		append([]interface{}{ctx, projectID, testSuiteID, contentType, body}, reqEditors...)...)}
}

func (_c *ClientInterface_RemoveExperiencesFromTestSuiteWithBody_Call) Run(run func(ctx context.Context, projectID uuid.UUID, testSuiteID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn)) *ClientInterface_RemoveExperiencesFromTestSuiteWithBody_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(string), args[4].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_RemoveExperiencesFromTestSuiteWithBody_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_RemoveExperiencesFromTestSuiteWithBody_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_RemoveExperiencesFromTestSuiteWithBody_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_RemoveExperiencesFromTestSuiteWithBody_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveSystemFromExperience provides a mock function with given fields: ctx, projectID, systemID, experienceID, reqEditors
func (_m *ClientInterface) RemoveSystemFromExperience(ctx context.Context, projectID uuid.UUID, systemID uuid.UUID, experienceID uuid.UUID, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, systemID, experienceID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RemoveSystemFromExperience")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, systemID, experienceID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, systemID, experienceID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, systemID, experienceID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_RemoveSystemFromExperience_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveSystemFromExperience'
type ClientInterface_RemoveSystemFromExperience_Call struct {
	*mock.Call
}

// RemoveSystemFromExperience is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - systemID uuid.UUID
//   - experienceID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) RemoveSystemFromExperience(ctx interface{}, projectID interface{}, systemID interface{}, experienceID interface{}, reqEditors ...interface{}) *ClientInterface_RemoveSystemFromExperience_Call {
	return &ClientInterface_RemoveSystemFromExperience_Call{Call: _e.mock.On("RemoveSystemFromExperience",
		append([]interface{}{ctx, projectID, systemID, experienceID}, reqEditors...)...)}
}

func (_c *ClientInterface_RemoveSystemFromExperience_Call) Run(run func(ctx context.Context, projectID uuid.UUID, systemID uuid.UUID, experienceID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientInterface_RemoveSystemFromExperience_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_RemoveSystemFromExperience_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_RemoveSystemFromExperience_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_RemoveSystemFromExperience_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_RemoveSystemFromExperience_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveSystemFromMetricsBuild provides a mock function with given fields: ctx, projectID, systemID, metricsBuildID, reqEditors
func (_m *ClientInterface) RemoveSystemFromMetricsBuild(ctx context.Context, projectID uuid.UUID, systemID uuid.UUID, metricsBuildID uuid.UUID, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, systemID, metricsBuildID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RemoveSystemFromMetricsBuild")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, systemID, metricsBuildID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, systemID, metricsBuildID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, systemID, metricsBuildID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_RemoveSystemFromMetricsBuild_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveSystemFromMetricsBuild'
type ClientInterface_RemoveSystemFromMetricsBuild_Call struct {
	*mock.Call
}

// RemoveSystemFromMetricsBuild is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - systemID uuid.UUID
//   - metricsBuildID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) RemoveSystemFromMetricsBuild(ctx interface{}, projectID interface{}, systemID interface{}, metricsBuildID interface{}, reqEditors ...interface{}) *ClientInterface_RemoveSystemFromMetricsBuild_Call {
	return &ClientInterface_RemoveSystemFromMetricsBuild_Call{Call: _e.mock.On("RemoveSystemFromMetricsBuild",
		append([]interface{}{ctx, projectID, systemID, metricsBuildID}, reqEditors...)...)}
}

func (_c *ClientInterface_RemoveSystemFromMetricsBuild_Call) Run(run func(ctx context.Context, projectID uuid.UUID, systemID uuid.UUID, metricsBuildID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientInterface_RemoveSystemFromMetricsBuild_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_RemoveSystemFromMetricsBuild_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_RemoveSystemFromMetricsBuild_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_RemoveSystemFromMetricsBuild_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_RemoveSystemFromMetricsBuild_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveSystemsFromExperiences provides a mock function with given fields: ctx, projectID, body, reqEditors
func (_m *ClientInterface) RemoveSystemsFromExperiences(ctx context.Context, projectID uuid.UUID, body api.MutateSystemsToExperienceInput, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RemoveSystemsFromExperiences")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, api.MutateSystemsToExperienceInput, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, api.MutateSystemsToExperienceInput, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, api.MutateSystemsToExperienceInput, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_RemoveSystemsFromExperiences_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveSystemsFromExperiences'
type ClientInterface_RemoveSystemsFromExperiences_Call struct {
	*mock.Call
}

// RemoveSystemsFromExperiences is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - body api.MutateSystemsToExperienceInput
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) RemoveSystemsFromExperiences(ctx interface{}, projectID interface{}, body interface{}, reqEditors ...interface{}) *ClientInterface_RemoveSystemsFromExperiences_Call {
	return &ClientInterface_RemoveSystemsFromExperiences_Call{Call: _e.mock.On("RemoveSystemsFromExperiences",
		append([]interface{}{ctx, projectID, body}, reqEditors...)...)}
}

func (_c *ClientInterface_RemoveSystemsFromExperiences_Call) Run(run func(ctx context.Context, projectID uuid.UUID, body api.MutateSystemsToExperienceInput, reqEditors ...api.RequestEditorFn)) *ClientInterface_RemoveSystemsFromExperiences_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(api.MutateSystemsToExperienceInput), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_RemoveSystemsFromExperiences_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_RemoveSystemsFromExperiences_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_RemoveSystemsFromExperiences_Call) RunAndReturn(run func(context.Context, uuid.UUID, api.MutateSystemsToExperienceInput, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_RemoveSystemsFromExperiences_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveSystemsFromExperiencesWithBody provides a mock function with given fields: ctx, projectID, contentType, body, reqEditors
func (_m *ClientInterface) RemoveSystemsFromExperiencesWithBody(ctx context.Context, projectID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RemoveSystemsFromExperiencesWithBody")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_RemoveSystemsFromExperiencesWithBody_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveSystemsFromExperiencesWithBody'
type ClientInterface_RemoveSystemsFromExperiencesWithBody_Call struct {
	*mock.Call
}

// RemoveSystemsFromExperiencesWithBody is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - contentType string
//   - body io.Reader
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) RemoveSystemsFromExperiencesWithBody(ctx interface{}, projectID interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *ClientInterface_RemoveSystemsFromExperiencesWithBody_Call {
	return &ClientInterface_RemoveSystemsFromExperiencesWithBody_Call{Call: _e.mock.On("RemoveSystemsFromExperiencesWithBody",
		append([]interface{}{ctx, projectID, contentType, body}, reqEditors...)...)}
}

func (_c *ClientInterface_RemoveSystemsFromExperiencesWithBody_Call) Run(run func(ctx context.Context, projectID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn)) *ClientInterface_RemoveSystemsFromExperiencesWithBody_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(string), args[3].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_RemoveSystemsFromExperiencesWithBody_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_RemoveSystemsFromExperiencesWithBody_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_RemoveSystemsFromExperiencesWithBody_Call) RunAndReturn(run func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_RemoveSystemsFromExperiencesWithBody_Call {
	_c.Call.Return(run)
	return _c
}

// RerunBatch provides a mock function with given fields: ctx, projectID, batchID, body, reqEditors
func (_m *ClientInterface) RerunBatch(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, body api.RerunBatchInput, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, batchID, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RerunBatch")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, api.RerunBatchInput, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, batchID, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, api.RerunBatchInput, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, batchID, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, api.RerunBatchInput, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, batchID, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_RerunBatch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RerunBatch'
type ClientInterface_RerunBatch_Call struct {
	*mock.Call
}

// RerunBatch is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - batchID uuid.UUID
//   - body api.RerunBatchInput
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) RerunBatch(ctx interface{}, projectID interface{}, batchID interface{}, body interface{}, reqEditors ...interface{}) *ClientInterface_RerunBatch_Call {
	return &ClientInterface_RerunBatch_Call{Call: _e.mock.On("RerunBatch",
		append([]interface{}{ctx, projectID, batchID, body}, reqEditors...)...)}
}

func (_c *ClientInterface_RerunBatch_Call) Run(run func(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, body api.RerunBatchInput, reqEditors ...api.RequestEditorFn)) *ClientInterface_RerunBatch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(api.RerunBatchInput), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_RerunBatch_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_RerunBatch_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_RerunBatch_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, api.RerunBatchInput, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_RerunBatch_Call {
	_c.Call.Return(run)
	return _c
}

// RerunBatchWithBody provides a mock function with given fields: ctx, projectID, batchID, contentType, body, reqEditors
func (_m *ClientInterface) RerunBatchWithBody(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, batchID, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RerunBatchWithBody")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, batchID, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, batchID, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, batchID, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_RerunBatchWithBody_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RerunBatchWithBody'
type ClientInterface_RerunBatchWithBody_Call struct {
	*mock.Call
}

// RerunBatchWithBody is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - batchID uuid.UUID
//   - contentType string
//   - body io.Reader
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) RerunBatchWithBody(ctx interface{}, projectID interface{}, batchID interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *ClientInterface_RerunBatchWithBody_Call {
	return &ClientInterface_RerunBatchWithBody_Call{Call: _e.mock.On("RerunBatchWithBody",
		append([]interface{}{ctx, projectID, batchID, contentType, body}, reqEditors...)...)}
}

func (_c *ClientInterface_RerunBatchWithBody_Call) Run(run func(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn)) *ClientInterface_RerunBatchWithBody_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(string), args[4].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_RerunBatchWithBody_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_RerunBatchWithBody_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_RerunBatchWithBody_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_RerunBatchWithBody_Call {
	_c.Call.Return(run)
	return _c
}

// RestoreExperience provides a mock function with given fields: ctx, projectID, experienceID, reqEditors
func (_m *ClientInterface) RestoreExperience(ctx context.Context, projectID uuid.UUID, experienceID uuid.UUID, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, experienceID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RestoreExperience")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, experienceID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, experienceID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, experienceID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_RestoreExperience_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RestoreExperience'
type ClientInterface_RestoreExperience_Call struct {
	*mock.Call
}

// RestoreExperience is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - experienceID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) RestoreExperience(ctx interface{}, projectID interface{}, experienceID interface{}, reqEditors ...interface{}) *ClientInterface_RestoreExperience_Call {
	return &ClientInterface_RestoreExperience_Call{Call: _e.mock.On("RestoreExperience",
		append([]interface{}{ctx, projectID, experienceID}, reqEditors...)...)}
}

func (_c *ClientInterface_RestoreExperience_Call) Run(run func(ctx context.Context, projectID uuid.UUID, experienceID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientInterface_RestoreExperience_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_RestoreExperience_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_RestoreExperience_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_RestoreExperience_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_RestoreExperience_Call {
	_c.Call.Return(run)
	return _c
}

// RestoreTestSuite provides a mock function with given fields: ctx, projectID, testSuiteID, reqEditors
func (_m *ClientInterface) RestoreTestSuite(ctx context.Context, projectID uuid.UUID, testSuiteID uuid.UUID, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, testSuiteID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RestoreTestSuite")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, testSuiteID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, testSuiteID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, testSuiteID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_RestoreTestSuite_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RestoreTestSuite'
type ClientInterface_RestoreTestSuite_Call struct {
	*mock.Call
}

// RestoreTestSuite is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - testSuiteID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) RestoreTestSuite(ctx interface{}, projectID interface{}, testSuiteID interface{}, reqEditors ...interface{}) *ClientInterface_RestoreTestSuite_Call {
	return &ClientInterface_RestoreTestSuite_Call{Call: _e.mock.On("RestoreTestSuite",
		append([]interface{}{ctx, projectID, testSuiteID}, reqEditors...)...)}
}

func (_c *ClientInterface_RestoreTestSuite_Call) Run(run func(ctx context.Context, projectID uuid.UUID, testSuiteID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientInterface_RestoreTestSuite_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_RestoreTestSuite_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_RestoreTestSuite_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_RestoreTestSuite_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_RestoreTestSuite_Call {
	_c.Call.Return(run)
	return _c
}

// ReviseTestSuite provides a mock function with given fields: ctx, projectID, testSuiteID, body, reqEditors
func (_m *ClientInterface) ReviseTestSuite(ctx context.Context, projectID uuid.UUID, testSuiteID uuid.UUID, body api.ReviseTestSuiteInput, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, testSuiteID, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ReviseTestSuite")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, api.ReviseTestSuiteInput, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, testSuiteID, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, api.ReviseTestSuiteInput, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, testSuiteID, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, api.ReviseTestSuiteInput, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, testSuiteID, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_ReviseTestSuite_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReviseTestSuite'
type ClientInterface_ReviseTestSuite_Call struct {
	*mock.Call
}

// ReviseTestSuite is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - testSuiteID uuid.UUID
//   - body api.ReviseTestSuiteInput
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) ReviseTestSuite(ctx interface{}, projectID interface{}, testSuiteID interface{}, body interface{}, reqEditors ...interface{}) *ClientInterface_ReviseTestSuite_Call {
	return &ClientInterface_ReviseTestSuite_Call{Call: _e.mock.On("ReviseTestSuite",
		append([]interface{}{ctx, projectID, testSuiteID, body}, reqEditors...)...)}
}

func (_c *ClientInterface_ReviseTestSuite_Call) Run(run func(ctx context.Context, projectID uuid.UUID, testSuiteID uuid.UUID, body api.ReviseTestSuiteInput, reqEditors ...api.RequestEditorFn)) *ClientInterface_ReviseTestSuite_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(api.ReviseTestSuiteInput), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_ReviseTestSuite_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_ReviseTestSuite_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_ReviseTestSuite_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, api.ReviseTestSuiteInput, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_ReviseTestSuite_Call {
	_c.Call.Return(run)
	return _c
}

// ReviseTestSuiteWithBody provides a mock function with given fields: ctx, projectID, testSuiteID, contentType, body, reqEditors
func (_m *ClientInterface) ReviseTestSuiteWithBody(ctx context.Context, projectID uuid.UUID, testSuiteID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, testSuiteID, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ReviseTestSuiteWithBody")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, testSuiteID, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, testSuiteID, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, testSuiteID, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_ReviseTestSuiteWithBody_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReviseTestSuiteWithBody'
type ClientInterface_ReviseTestSuiteWithBody_Call struct {
	*mock.Call
}

// ReviseTestSuiteWithBody is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - testSuiteID uuid.UUID
//   - contentType string
//   - body io.Reader
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) ReviseTestSuiteWithBody(ctx interface{}, projectID interface{}, testSuiteID interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *ClientInterface_ReviseTestSuiteWithBody_Call {
	return &ClientInterface_ReviseTestSuiteWithBody_Call{Call: _e.mock.On("ReviseTestSuiteWithBody",
		append([]interface{}{ctx, projectID, testSuiteID, contentType, body}, reqEditors...)...)}
}

func (_c *ClientInterface_ReviseTestSuiteWithBody_Call) Run(run func(ctx context.Context, projectID uuid.UUID, testSuiteID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn)) *ClientInterface_ReviseTestSuiteWithBody_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(string), args[4].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_ReviseTestSuiteWithBody_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_ReviseTestSuiteWithBody_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_ReviseTestSuiteWithBody_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_ReviseTestSuiteWithBody_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateBatch provides a mock function with given fields: ctx, projectID, batchID, body, reqEditors
func (_m *ClientInterface) UpdateBatch(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, body api.UpdateBatchInput, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, batchID, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateBatch")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, api.UpdateBatchInput, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, batchID, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, api.UpdateBatchInput, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, batchID, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, api.UpdateBatchInput, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, batchID, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_UpdateBatch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateBatch'
type ClientInterface_UpdateBatch_Call struct {
	*mock.Call
}

// UpdateBatch is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - batchID uuid.UUID
//   - body api.UpdateBatchInput
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) UpdateBatch(ctx interface{}, projectID interface{}, batchID interface{}, body interface{}, reqEditors ...interface{}) *ClientInterface_UpdateBatch_Call {
	return &ClientInterface_UpdateBatch_Call{Call: _e.mock.On("UpdateBatch",
		append([]interface{}{ctx, projectID, batchID, body}, reqEditors...)...)}
}

func (_c *ClientInterface_UpdateBatch_Call) Run(run func(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, body api.UpdateBatchInput, reqEditors ...api.RequestEditorFn)) *ClientInterface_UpdateBatch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(api.UpdateBatchInput), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_UpdateBatch_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_UpdateBatch_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_UpdateBatch_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, api.UpdateBatchInput, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_UpdateBatch_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateBatchWithBody provides a mock function with given fields: ctx, projectID, batchID, contentType, body, reqEditors
func (_m *ClientInterface) UpdateBatchWithBody(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, batchID, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateBatchWithBody")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, batchID, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, batchID, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, batchID, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_UpdateBatchWithBody_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateBatchWithBody'
type ClientInterface_UpdateBatchWithBody_Call struct {
	*mock.Call
}

// UpdateBatchWithBody is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - batchID uuid.UUID
//   - contentType string
//   - body io.Reader
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) UpdateBatchWithBody(ctx interface{}, projectID interface{}, batchID interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *ClientInterface_UpdateBatchWithBody_Call {
	return &ClientInterface_UpdateBatchWithBody_Call{Call: _e.mock.On("UpdateBatchWithBody",
		append([]interface{}{ctx, projectID, batchID, contentType, body}, reqEditors...)...)}
}

func (_c *ClientInterface_UpdateBatchWithBody_Call) Run(run func(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn)) *ClientInterface_UpdateBatchWithBody_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(string), args[4].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_UpdateBatchWithBody_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_UpdateBatchWithBody_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_UpdateBatchWithBody_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_UpdateBatchWithBody_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateBuild provides a mock function with given fields: ctx, projectID, buildID, body, reqEditors
func (_m *ClientInterface) UpdateBuild(ctx context.Context, projectID uuid.UUID, buildID uuid.UUID, body api.UpdateBuildInput, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, buildID, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateBuild")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, api.UpdateBuildInput, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, buildID, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, api.UpdateBuildInput, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, buildID, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, api.UpdateBuildInput, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, buildID, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_UpdateBuild_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateBuild'
type ClientInterface_UpdateBuild_Call struct {
	*mock.Call
}

// UpdateBuild is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - buildID uuid.UUID
//   - body api.UpdateBuildInput
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) UpdateBuild(ctx interface{}, projectID interface{}, buildID interface{}, body interface{}, reqEditors ...interface{}) *ClientInterface_UpdateBuild_Call {
	return &ClientInterface_UpdateBuild_Call{Call: _e.mock.On("UpdateBuild",
		append([]interface{}{ctx, projectID, buildID, body}, reqEditors...)...)}
}

func (_c *ClientInterface_UpdateBuild_Call) Run(run func(ctx context.Context, projectID uuid.UUID, buildID uuid.UUID, body api.UpdateBuildInput, reqEditors ...api.RequestEditorFn)) *ClientInterface_UpdateBuild_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(api.UpdateBuildInput), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_UpdateBuild_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_UpdateBuild_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_UpdateBuild_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, api.UpdateBuildInput, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_UpdateBuild_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateBuildWithBody provides a mock function with given fields: ctx, projectID, buildID, contentType, body, reqEditors
func (_m *ClientInterface) UpdateBuildWithBody(ctx context.Context, projectID uuid.UUID, buildID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, buildID, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateBuildWithBody")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, buildID, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, buildID, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, buildID, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_UpdateBuildWithBody_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateBuildWithBody'
type ClientInterface_UpdateBuildWithBody_Call struct {
	*mock.Call
}

// UpdateBuildWithBody is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - buildID uuid.UUID
//   - contentType string
//   - body io.Reader
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) UpdateBuildWithBody(ctx interface{}, projectID interface{}, buildID interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *ClientInterface_UpdateBuildWithBody_Call {
	return &ClientInterface_UpdateBuildWithBody_Call{Call: _e.mock.On("UpdateBuildWithBody",
		append([]interface{}{ctx, projectID, buildID, contentType, body}, reqEditors...)...)}
}

func (_c *ClientInterface_UpdateBuildWithBody_Call) Run(run func(ctx context.Context, projectID uuid.UUID, buildID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn)) *ClientInterface_UpdateBuildWithBody_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(string), args[4].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_UpdateBuildWithBody_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_UpdateBuildWithBody_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_UpdateBuildWithBody_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_UpdateBuildWithBody_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateEvent provides a mock function with given fields: ctx, projectID, batchID, jobID, eventID, body, reqEditors
func (_m *ClientInterface) UpdateEvent(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, jobID uuid.UUID, eventID uuid.UUID, body api.UpdateEventInput, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, batchID, jobID, eventID, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateEvent")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, uuid.UUID, api.UpdateEventInput, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, batchID, jobID, eventID, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, uuid.UUID, api.UpdateEventInput, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, batchID, jobID, eventID, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, uuid.UUID, api.UpdateEventInput, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, batchID, jobID, eventID, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_UpdateEvent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateEvent'
type ClientInterface_UpdateEvent_Call struct {
	*mock.Call
}

// UpdateEvent is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - batchID uuid.UUID
//   - jobID uuid.UUID
//   - eventID uuid.UUID
//   - body api.UpdateEventInput
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) UpdateEvent(ctx interface{}, projectID interface{}, batchID interface{}, jobID interface{}, eventID interface{}, body interface{}, reqEditors ...interface{}) *ClientInterface_UpdateEvent_Call {
	return &ClientInterface_UpdateEvent_Call{Call: _e.mock.On("UpdateEvent",
		append([]interface{}{ctx, projectID, batchID, jobID, eventID, body}, reqEditors...)...)}
}

func (_c *ClientInterface_UpdateEvent_Call) Run(run func(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, jobID uuid.UUID, eventID uuid.UUID, body api.UpdateEventInput, reqEditors ...api.RequestEditorFn)) *ClientInterface_UpdateEvent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-6)
		for i, a := range args[6:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(uuid.UUID), args[4].(uuid.UUID), args[5].(api.UpdateEventInput), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_UpdateEvent_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_UpdateEvent_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_UpdateEvent_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, uuid.UUID, api.UpdateEventInput, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_UpdateEvent_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateEventWithBody provides a mock function with given fields: ctx, projectID, batchID, jobID, eventID, contentType, body, reqEditors
func (_m *ClientInterface) UpdateEventWithBody(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, jobID uuid.UUID, eventID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, batchID, jobID, eventID, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateEventWithBody")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, batchID, jobID, eventID, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, batchID, jobID, eventID, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, batchID, jobID, eventID, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_UpdateEventWithBody_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateEventWithBody'
type ClientInterface_UpdateEventWithBody_Call struct {
	*mock.Call
}

// UpdateEventWithBody is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - batchID uuid.UUID
//   - jobID uuid.UUID
//   - eventID uuid.UUID
//   - contentType string
//   - body io.Reader
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) UpdateEventWithBody(ctx interface{}, projectID interface{}, batchID interface{}, jobID interface{}, eventID interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *ClientInterface_UpdateEventWithBody_Call {
	return &ClientInterface_UpdateEventWithBody_Call{Call: _e.mock.On("UpdateEventWithBody",
		append([]interface{}{ctx, projectID, batchID, jobID, eventID, contentType, body}, reqEditors...)...)}
}

func (_c *ClientInterface_UpdateEventWithBody_Call) Run(run func(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, jobID uuid.UUID, eventID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn)) *ClientInterface_UpdateEventWithBody_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-7)
		for i, a := range args[7:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(uuid.UUID), args[4].(uuid.UUID), args[5].(string), args[6].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_UpdateEventWithBody_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_UpdateEventWithBody_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_UpdateEventWithBody_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_UpdateEventWithBody_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateExperience provides a mock function with given fields: ctx, projectID, experienceID, body, reqEditors
func (_m *ClientInterface) UpdateExperience(ctx context.Context, projectID uuid.UUID, experienceID uuid.UUID, body api.UpdateExperienceInput, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, experienceID, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateExperience")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, api.UpdateExperienceInput, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, experienceID, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, api.UpdateExperienceInput, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, experienceID, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, api.UpdateExperienceInput, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, experienceID, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_UpdateExperience_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateExperience'
type ClientInterface_UpdateExperience_Call struct {
	*mock.Call
}

// UpdateExperience is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - experienceID uuid.UUID
//   - body api.UpdateExperienceInput
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) UpdateExperience(ctx interface{}, projectID interface{}, experienceID interface{}, body interface{}, reqEditors ...interface{}) *ClientInterface_UpdateExperience_Call {
	return &ClientInterface_UpdateExperience_Call{Call: _e.mock.On("UpdateExperience",
		append([]interface{}{ctx, projectID, experienceID, body}, reqEditors...)...)}
}

func (_c *ClientInterface_UpdateExperience_Call) Run(run func(ctx context.Context, projectID uuid.UUID, experienceID uuid.UUID, body api.UpdateExperienceInput, reqEditors ...api.RequestEditorFn)) *ClientInterface_UpdateExperience_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(api.UpdateExperienceInput), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_UpdateExperience_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_UpdateExperience_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_UpdateExperience_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, api.UpdateExperienceInput, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_UpdateExperience_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateExperienceTag provides a mock function with given fields: ctx, projectID, experienceTagID, body, reqEditors
func (_m *ClientInterface) UpdateExperienceTag(ctx context.Context, projectID uuid.UUID, experienceTagID uuid.UUID, body api.UpdateExperienceTagInput, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, experienceTagID, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateExperienceTag")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, api.UpdateExperienceTagInput, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, experienceTagID, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, api.UpdateExperienceTagInput, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, experienceTagID, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, api.UpdateExperienceTagInput, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, experienceTagID, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_UpdateExperienceTag_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateExperienceTag'
type ClientInterface_UpdateExperienceTag_Call struct {
	*mock.Call
}

// UpdateExperienceTag is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - experienceTagID uuid.UUID
//   - body api.UpdateExperienceTagInput
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) UpdateExperienceTag(ctx interface{}, projectID interface{}, experienceTagID interface{}, body interface{}, reqEditors ...interface{}) *ClientInterface_UpdateExperienceTag_Call {
	return &ClientInterface_UpdateExperienceTag_Call{Call: _e.mock.On("UpdateExperienceTag",
		append([]interface{}{ctx, projectID, experienceTagID, body}, reqEditors...)...)}
}

func (_c *ClientInterface_UpdateExperienceTag_Call) Run(run func(ctx context.Context, projectID uuid.UUID, experienceTagID uuid.UUID, body api.UpdateExperienceTagInput, reqEditors ...api.RequestEditorFn)) *ClientInterface_UpdateExperienceTag_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(api.UpdateExperienceTagInput), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_UpdateExperienceTag_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_UpdateExperienceTag_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_UpdateExperienceTag_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, api.UpdateExperienceTagInput, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_UpdateExperienceTag_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateExperienceTagWithBody provides a mock function with given fields: ctx, projectID, experienceTagID, contentType, body, reqEditors
func (_m *ClientInterface) UpdateExperienceTagWithBody(ctx context.Context, projectID uuid.UUID, experienceTagID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, experienceTagID, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateExperienceTagWithBody")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, experienceTagID, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, experienceTagID, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, experienceTagID, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_UpdateExperienceTagWithBody_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateExperienceTagWithBody'
type ClientInterface_UpdateExperienceTagWithBody_Call struct {
	*mock.Call
}

// UpdateExperienceTagWithBody is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - experienceTagID uuid.UUID
//   - contentType string
//   - body io.Reader
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) UpdateExperienceTagWithBody(ctx interface{}, projectID interface{}, experienceTagID interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *ClientInterface_UpdateExperienceTagWithBody_Call {
	return &ClientInterface_UpdateExperienceTagWithBody_Call{Call: _e.mock.On("UpdateExperienceTagWithBody",
		append([]interface{}{ctx, projectID, experienceTagID, contentType, body}, reqEditors...)...)}
}

func (_c *ClientInterface_UpdateExperienceTagWithBody_Call) Run(run func(ctx context.Context, projectID uuid.UUID, experienceTagID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn)) *ClientInterface_UpdateExperienceTagWithBody_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(string), args[4].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_UpdateExperienceTagWithBody_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_UpdateExperienceTagWithBody_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_UpdateExperienceTagWithBody_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_UpdateExperienceTagWithBody_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateExperienceWithBody provides a mock function with given fields: ctx, projectID, experienceID, contentType, body, reqEditors
func (_m *ClientInterface) UpdateExperienceWithBody(ctx context.Context, projectID uuid.UUID, experienceID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, experienceID, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateExperienceWithBody")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, experienceID, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, experienceID, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, experienceID, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_UpdateExperienceWithBody_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateExperienceWithBody'
type ClientInterface_UpdateExperienceWithBody_Call struct {
	*mock.Call
}

// UpdateExperienceWithBody is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - experienceID uuid.UUID
//   - contentType string
//   - body io.Reader
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) UpdateExperienceWithBody(ctx interface{}, projectID interface{}, experienceID interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *ClientInterface_UpdateExperienceWithBody_Call {
	return &ClientInterface_UpdateExperienceWithBody_Call{Call: _e.mock.On("UpdateExperienceWithBody",
		append([]interface{}{ctx, projectID, experienceID, contentType, body}, reqEditors...)...)}
}

func (_c *ClientInterface_UpdateExperienceWithBody_Call) Run(run func(ctx context.Context, projectID uuid.UUID, experienceID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn)) *ClientInterface_UpdateExperienceWithBody_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(string), args[4].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_UpdateExperienceWithBody_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_UpdateExperienceWithBody_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_UpdateExperienceWithBody_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_UpdateExperienceWithBody_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateJob provides a mock function with given fields: ctx, projectID, batchID, jobID, body, reqEditors
func (_m *ClientInterface) UpdateJob(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, jobID uuid.UUID, body api.UpdateJobInput, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, batchID, jobID, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateJob")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, api.UpdateJobInput, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, batchID, jobID, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, api.UpdateJobInput, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, batchID, jobID, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, api.UpdateJobInput, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, batchID, jobID, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_UpdateJob_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateJob'
type ClientInterface_UpdateJob_Call struct {
	*mock.Call
}

// UpdateJob is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - batchID uuid.UUID
//   - jobID uuid.UUID
//   - body api.UpdateJobInput
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) UpdateJob(ctx interface{}, projectID interface{}, batchID interface{}, jobID interface{}, body interface{}, reqEditors ...interface{}) *ClientInterface_UpdateJob_Call {
	return &ClientInterface_UpdateJob_Call{Call: _e.mock.On("UpdateJob",
		append([]interface{}{ctx, projectID, batchID, jobID, body}, reqEditors...)...)}
}

func (_c *ClientInterface_UpdateJob_Call) Run(run func(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, jobID uuid.UUID, body api.UpdateJobInput, reqEditors ...api.RequestEditorFn)) *ClientInterface_UpdateJob_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(uuid.UUID), args[4].(api.UpdateJobInput), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_UpdateJob_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_UpdateJob_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_UpdateJob_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, api.UpdateJobInput, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_UpdateJob_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateJobWithBody provides a mock function with given fields: ctx, projectID, batchID, jobID, contentType, body, reqEditors
func (_m *ClientInterface) UpdateJobWithBody(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, jobID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, batchID, jobID, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateJobWithBody")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, batchID, jobID, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, batchID, jobID, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, batchID, jobID, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_UpdateJobWithBody_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateJobWithBody'
type ClientInterface_UpdateJobWithBody_Call struct {
	*mock.Call
}

// UpdateJobWithBody is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - batchID uuid.UUID
//   - jobID uuid.UUID
//   - contentType string
//   - body io.Reader
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) UpdateJobWithBody(ctx interface{}, projectID interface{}, batchID interface{}, jobID interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *ClientInterface_UpdateJobWithBody_Call {
	return &ClientInterface_UpdateJobWithBody_Call{Call: _e.mock.On("UpdateJobWithBody",
		append([]interface{}{ctx, projectID, batchID, jobID, contentType, body}, reqEditors...)...)}
}

func (_c *ClientInterface_UpdateJobWithBody_Call) Run(run func(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, jobID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn)) *ClientInterface_UpdateJobWithBody_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-6)
		for i, a := range args[6:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(uuid.UUID), args[4].(string), args[5].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_UpdateJobWithBody_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_UpdateJobWithBody_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_UpdateJobWithBody_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_UpdateJobWithBody_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateProject provides a mock function with given fields: ctx, projectID, body, reqEditors
func (_m *ClientInterface) UpdateProject(ctx context.Context, projectID uuid.UUID, body api.UpdateProjectInput, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateProject")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, api.UpdateProjectInput, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, api.UpdateProjectInput, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, api.UpdateProjectInput, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_UpdateProject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateProject'
type ClientInterface_UpdateProject_Call struct {
	*mock.Call
}

// UpdateProject is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - body api.UpdateProjectInput
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) UpdateProject(ctx interface{}, projectID interface{}, body interface{}, reqEditors ...interface{}) *ClientInterface_UpdateProject_Call {
	return &ClientInterface_UpdateProject_Call{Call: _e.mock.On("UpdateProject",
		append([]interface{}{ctx, projectID, body}, reqEditors...)...)}
}

func (_c *ClientInterface_UpdateProject_Call) Run(run func(ctx context.Context, projectID uuid.UUID, body api.UpdateProjectInput, reqEditors ...api.RequestEditorFn)) *ClientInterface_UpdateProject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(api.UpdateProjectInput), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_UpdateProject_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_UpdateProject_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_UpdateProject_Call) RunAndReturn(run func(context.Context, uuid.UUID, api.UpdateProjectInput, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_UpdateProject_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateProjectWithBody provides a mock function with given fields: ctx, projectID, contentType, body, reqEditors
func (_m *ClientInterface) UpdateProjectWithBody(ctx context.Context, projectID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateProjectWithBody")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_UpdateProjectWithBody_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateProjectWithBody'
type ClientInterface_UpdateProjectWithBody_Call struct {
	*mock.Call
}

// UpdateProjectWithBody is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - contentType string
//   - body io.Reader
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) UpdateProjectWithBody(ctx interface{}, projectID interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *ClientInterface_UpdateProjectWithBody_Call {
	return &ClientInterface_UpdateProjectWithBody_Call{Call: _e.mock.On("UpdateProjectWithBody",
		append([]interface{}{ctx, projectID, contentType, body}, reqEditors...)...)}
}

func (_c *ClientInterface_UpdateProjectWithBody_Call) Run(run func(ctx context.Context, projectID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn)) *ClientInterface_UpdateProjectWithBody_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(string), args[3].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_UpdateProjectWithBody_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_UpdateProjectWithBody_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_UpdateProjectWithBody_Call) RunAndReturn(run func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_UpdateProjectWithBody_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateSystem provides a mock function with given fields: ctx, projectID, systemID, body, reqEditors
func (_m *ClientInterface) UpdateSystem(ctx context.Context, projectID uuid.UUID, systemID uuid.UUID, body api.UpdateSystemInput, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, systemID, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateSystem")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, api.UpdateSystemInput, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, systemID, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, api.UpdateSystemInput, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, systemID, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, api.UpdateSystemInput, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, systemID, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_UpdateSystem_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateSystem'
type ClientInterface_UpdateSystem_Call struct {
	*mock.Call
}

// UpdateSystem is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - systemID uuid.UUID
//   - body api.UpdateSystemInput
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) UpdateSystem(ctx interface{}, projectID interface{}, systemID interface{}, body interface{}, reqEditors ...interface{}) *ClientInterface_UpdateSystem_Call {
	return &ClientInterface_UpdateSystem_Call{Call: _e.mock.On("UpdateSystem",
		append([]interface{}{ctx, projectID, systemID, body}, reqEditors...)...)}
}

func (_c *ClientInterface_UpdateSystem_Call) Run(run func(ctx context.Context, projectID uuid.UUID, systemID uuid.UUID, body api.UpdateSystemInput, reqEditors ...api.RequestEditorFn)) *ClientInterface_UpdateSystem_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(api.UpdateSystemInput), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_UpdateSystem_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_UpdateSystem_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_UpdateSystem_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, api.UpdateSystemInput, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_UpdateSystem_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateSystemWithBody provides a mock function with given fields: ctx, projectID, systemID, contentType, body, reqEditors
func (_m *ClientInterface) UpdateSystemWithBody(ctx context.Context, projectID uuid.UUID, systemID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, systemID, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateSystemWithBody")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, systemID, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, systemID, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, systemID, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_UpdateSystemWithBody_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateSystemWithBody'
type ClientInterface_UpdateSystemWithBody_Call struct {
	*mock.Call
}

// UpdateSystemWithBody is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - systemID uuid.UUID
//   - contentType string
//   - body io.Reader
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) UpdateSystemWithBody(ctx interface{}, projectID interface{}, systemID interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *ClientInterface_UpdateSystemWithBody_Call {
	return &ClientInterface_UpdateSystemWithBody_Call{Call: _e.mock.On("UpdateSystemWithBody",
		append([]interface{}{ctx, projectID, systemID, contentType, body}, reqEditors...)...)}
}

func (_c *ClientInterface_UpdateSystemWithBody_Call) Run(run func(ctx context.Context, projectID uuid.UUID, systemID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn)) *ClientInterface_UpdateSystemWithBody_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(string), args[4].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_UpdateSystemWithBody_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_UpdateSystemWithBody_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_UpdateSystemWithBody_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_UpdateSystemWithBody_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateWorkflow provides a mock function with given fields: ctx, projectID, workflowID, body, reqEditors
func (_m *ClientInterface) UpdateWorkflow(ctx context.Context, projectID uuid.UUID, workflowID uuid.UUID, body api.UpdateWorkflowInput, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, workflowID, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateWorkflow")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, api.UpdateWorkflowInput, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, workflowID, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, api.UpdateWorkflowInput, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, workflowID, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, api.UpdateWorkflowInput, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, workflowID, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_UpdateWorkflow_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateWorkflow'
type ClientInterface_UpdateWorkflow_Call struct {
	*mock.Call
}

// UpdateWorkflow is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - workflowID uuid.UUID
//   - body api.UpdateWorkflowInput
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) UpdateWorkflow(ctx interface{}, projectID interface{}, workflowID interface{}, body interface{}, reqEditors ...interface{}) *ClientInterface_UpdateWorkflow_Call {
	return &ClientInterface_UpdateWorkflow_Call{Call: _e.mock.On("UpdateWorkflow",
		append([]interface{}{ctx, projectID, workflowID, body}, reqEditors...)...)}
}

func (_c *ClientInterface_UpdateWorkflow_Call) Run(run func(ctx context.Context, projectID uuid.UUID, workflowID uuid.UUID, body api.UpdateWorkflowInput, reqEditors ...api.RequestEditorFn)) *ClientInterface_UpdateWorkflow_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(api.UpdateWorkflowInput), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_UpdateWorkflow_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_UpdateWorkflow_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_UpdateWorkflow_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, api.UpdateWorkflowInput, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_UpdateWorkflow_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateWorkflowSuites provides a mock function with given fields: ctx, projectID, workflowID, body, reqEditors
func (_m *ClientInterface) UpdateWorkflowSuites(ctx context.Context, projectID uuid.UUID, workflowID uuid.UUID, body api.UpdateWorkflowSuitesInput, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, workflowID, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateWorkflowSuites")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, api.UpdateWorkflowSuitesInput, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, workflowID, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, api.UpdateWorkflowSuitesInput, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, workflowID, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, api.UpdateWorkflowSuitesInput, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, workflowID, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_UpdateWorkflowSuites_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateWorkflowSuites'
type ClientInterface_UpdateWorkflowSuites_Call struct {
	*mock.Call
}

// UpdateWorkflowSuites is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - workflowID uuid.UUID
//   - body api.UpdateWorkflowSuitesInput
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) UpdateWorkflowSuites(ctx interface{}, projectID interface{}, workflowID interface{}, body interface{}, reqEditors ...interface{}) *ClientInterface_UpdateWorkflowSuites_Call {
	return &ClientInterface_UpdateWorkflowSuites_Call{Call: _e.mock.On("UpdateWorkflowSuites",
		append([]interface{}{ctx, projectID, workflowID, body}, reqEditors...)...)}
}

func (_c *ClientInterface_UpdateWorkflowSuites_Call) Run(run func(ctx context.Context, projectID uuid.UUID, workflowID uuid.UUID, body api.UpdateWorkflowSuitesInput, reqEditors ...api.RequestEditorFn)) *ClientInterface_UpdateWorkflowSuites_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(api.UpdateWorkflowSuitesInput), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_UpdateWorkflowSuites_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_UpdateWorkflowSuites_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_UpdateWorkflowSuites_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, api.UpdateWorkflowSuitesInput, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_UpdateWorkflowSuites_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateWorkflowSuitesWithBody provides a mock function with given fields: ctx, projectID, workflowID, contentType, body, reqEditors
func (_m *ClientInterface) UpdateWorkflowSuitesWithBody(ctx context.Context, projectID uuid.UUID, workflowID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, workflowID, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateWorkflowSuitesWithBody")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, workflowID, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, workflowID, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, workflowID, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_UpdateWorkflowSuitesWithBody_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateWorkflowSuitesWithBody'
type ClientInterface_UpdateWorkflowSuitesWithBody_Call struct {
	*mock.Call
}

// UpdateWorkflowSuitesWithBody is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - workflowID uuid.UUID
//   - contentType string
//   - body io.Reader
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) UpdateWorkflowSuitesWithBody(ctx interface{}, projectID interface{}, workflowID interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *ClientInterface_UpdateWorkflowSuitesWithBody_Call {
	return &ClientInterface_UpdateWorkflowSuitesWithBody_Call{Call: _e.mock.On("UpdateWorkflowSuitesWithBody",
		append([]interface{}{ctx, projectID, workflowID, contentType, body}, reqEditors...)...)}
}

func (_c *ClientInterface_UpdateWorkflowSuitesWithBody_Call) Run(run func(ctx context.Context, projectID uuid.UUID, workflowID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn)) *ClientInterface_UpdateWorkflowSuitesWithBody_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(string), args[4].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_UpdateWorkflowSuitesWithBody_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_UpdateWorkflowSuitesWithBody_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_UpdateWorkflowSuitesWithBody_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_UpdateWorkflowSuitesWithBody_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateWorkflowWithBody provides a mock function with given fields: ctx, projectID, workflowID, contentType, body, reqEditors
func (_m *ClientInterface) UpdateWorkflowWithBody(ctx context.Context, projectID uuid.UUID, workflowID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, workflowID, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateWorkflowWithBody")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, projectID, workflowID, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, projectID, workflowID, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, workflowID, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_UpdateWorkflowWithBody_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateWorkflowWithBody'
type ClientInterface_UpdateWorkflowWithBody_Call struct {
	*mock.Call
}

// UpdateWorkflowWithBody is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - workflowID uuid.UUID
//   - contentType string
//   - body io.Reader
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) UpdateWorkflowWithBody(ctx interface{}, projectID interface{}, workflowID interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *ClientInterface_UpdateWorkflowWithBody_Call {
	return &ClientInterface_UpdateWorkflowWithBody_Call{Call: _e.mock.On("UpdateWorkflowWithBody",
		append([]interface{}{ctx, projectID, workflowID, contentType, body}, reqEditors...)...)}
}

func (_c *ClientInterface_UpdateWorkflowWithBody_Call) Run(run func(ctx context.Context, projectID uuid.UUID, workflowID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn)) *ClientInterface_UpdateWorkflowWithBody_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(string), args[4].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_UpdateWorkflowWithBody_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_UpdateWorkflowWithBody_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_UpdateWorkflowWithBody_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_UpdateWorkflowWithBody_Call {
	_c.Call.Return(run)
	return _c
}

// ValidateExperienceLocation provides a mock function with given fields: ctx, body, reqEditors
func (_m *ClientInterface) ValidateExperienceLocation(ctx context.Context, body api.ExperienceLocation, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ValidateExperienceLocation")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, api.ExperienceLocation, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, api.ExperienceLocation, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, api.ExperienceLocation, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_ValidateExperienceLocation_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ValidateExperienceLocation'
type ClientInterface_ValidateExperienceLocation_Call struct {
	*mock.Call
}

// ValidateExperienceLocation is a helper method to define mock.On call
//   - ctx context.Context
//   - body api.ExperienceLocation
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) ValidateExperienceLocation(ctx interface{}, body interface{}, reqEditors ...interface{}) *ClientInterface_ValidateExperienceLocation_Call {
	return &ClientInterface_ValidateExperienceLocation_Call{Call: _e.mock.On("ValidateExperienceLocation",
		append([]interface{}{ctx, body}, reqEditors...)...)}
}

func (_c *ClientInterface_ValidateExperienceLocation_Call) Run(run func(ctx context.Context, body api.ExperienceLocation, reqEditors ...api.RequestEditorFn)) *ClientInterface_ValidateExperienceLocation_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(api.ExperienceLocation), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_ValidateExperienceLocation_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_ValidateExperienceLocation_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_ValidateExperienceLocation_Call) RunAndReturn(run func(context.Context, api.ExperienceLocation, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_ValidateExperienceLocation_Call {
	_c.Call.Return(run)
	return _c
}

// ValidateExperienceLocationWithBody provides a mock function with given fields: ctx, contentType, body, reqEditors
func (_m *ClientInterface) ValidateExperienceLocationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ValidateExperienceLocationWithBody")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, io.Reader, ...api.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, io.Reader, ...api.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, io.Reader, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientInterface_ValidateExperienceLocationWithBody_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ValidateExperienceLocationWithBody'
type ClientInterface_ValidateExperienceLocationWithBody_Call struct {
	*mock.Call
}

// ValidateExperienceLocationWithBody is a helper method to define mock.On call
//   - ctx context.Context
//   - contentType string
//   - body io.Reader
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientInterface_Expecter) ValidateExperienceLocationWithBody(ctx interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *ClientInterface_ValidateExperienceLocationWithBody_Call {
	return &ClientInterface_ValidateExperienceLocationWithBody_Call{Call: _e.mock.On("ValidateExperienceLocationWithBody",
		append([]interface{}{ctx, contentType, body}, reqEditors...)...)}
}

func (_c *ClientInterface_ValidateExperienceLocationWithBody_Call) Run(run func(ctx context.Context, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn)) *ClientInterface_ValidateExperienceLocationWithBody_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(string), args[2].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *ClientInterface_ValidateExperienceLocationWithBody_Call) Return(_a0 *http.Response, _a1 error) *ClientInterface_ValidateExperienceLocationWithBody_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientInterface_ValidateExperienceLocationWithBody_Call) RunAndReturn(run func(context.Context, string, io.Reader, ...api.RequestEditorFn) (*http.Response, error)) *ClientInterface_ValidateExperienceLocationWithBody_Call {
	_c.Call.Return(run)
	return _c
}

// NewClientInterface creates a new instance of ClientInterface. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewClientInterface(t interface {
	mock.TestingT
	Cleanup(func())
}) *ClientInterface {
	mock := &ClientInterface{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
