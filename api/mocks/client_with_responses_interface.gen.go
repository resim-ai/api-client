// Code generated by mockery v2.53.4. DO NOT EDIT.

package mockapiclient

import (
	context "context"

	api "github.com/resim-ai/api-client/api"

	io "io"

	mock "github.com/stretchr/testify/mock"

	uuid "github.com/google/uuid"
)

// ClientWithResponsesInterface is an autogenerated mock type for the ClientWithResponsesInterface type
type ClientWithResponsesInterface struct {
	mock.Mock
}

type ClientWithResponsesInterface_Expecter struct {
	mock *mock.Mock
}

func (_m *ClientWithResponsesInterface) EXPECT() *ClientWithResponsesInterface_Expecter {
	return &ClientWithResponsesInterface_Expecter{mock: &_m.Mock}
}

// AddExperienceTagToExperienceWithResponse provides a mock function with given fields: ctx, projectID, experienceTagID, experienceID, reqEditors
func (_m *ClientWithResponsesInterface) AddExperienceTagToExperienceWithResponse(ctx context.Context, projectID uuid.UUID, experienceTagID uuid.UUID, experienceID uuid.UUID, reqEditors ...api.RequestEditorFn) (*api.AddExperienceTagToExperienceResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, experienceTagID, experienceID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddExperienceTagToExperienceWithResponse")
	}

	var r0 *api.AddExperienceTagToExperienceResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*api.AddExperienceTagToExperienceResponse, error)); ok {
		return rf(ctx, projectID, experienceTagID, experienceID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) *api.AddExperienceTagToExperienceResponse); ok {
		r0 = rf(ctx, projectID, experienceTagID, experienceID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.AddExperienceTagToExperienceResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, experienceTagID, experienceID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_AddExperienceTagToExperienceWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddExperienceTagToExperienceWithResponse'
type ClientWithResponsesInterface_AddExperienceTagToExperienceWithResponse_Call struct {
	*mock.Call
}

// AddExperienceTagToExperienceWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - experienceTagID uuid.UUID
//   - experienceID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) AddExperienceTagToExperienceWithResponse(ctx interface{}, projectID interface{}, experienceTagID interface{}, experienceID interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_AddExperienceTagToExperienceWithResponse_Call {
	return &ClientWithResponsesInterface_AddExperienceTagToExperienceWithResponse_Call{Call: _e.mock.On("AddExperienceTagToExperienceWithResponse",
		append([]interface{}{ctx, projectID, experienceTagID, experienceID}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_AddExperienceTagToExperienceWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, experienceTagID uuid.UUID, experienceID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_AddExperienceTagToExperienceWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_AddExperienceTagToExperienceWithResponse_Call) Return(_a0 *api.AddExperienceTagToExperienceResponse, _a1 error) *ClientWithResponsesInterface_AddExperienceTagToExperienceWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_AddExperienceTagToExperienceWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*api.AddExperienceTagToExperienceResponse, error)) *ClientWithResponsesInterface_AddExperienceTagToExperienceWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// AddExperiencesToTestSuiteWithBodyWithResponse provides a mock function with given fields: ctx, projectID, testSuiteID, contentType, body, reqEditors
func (_m *ClientWithResponsesInterface) AddExperiencesToTestSuiteWithBodyWithResponse(ctx context.Context, projectID uuid.UUID, testSuiteID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn) (*api.AddExperiencesToTestSuiteResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, testSuiteID, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddExperiencesToTestSuiteWithBodyWithResponse")
	}

	var r0 *api.AddExperiencesToTestSuiteResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*api.AddExperiencesToTestSuiteResponse, error)); ok {
		return rf(ctx, projectID, testSuiteID, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) *api.AddExperiencesToTestSuiteResponse); ok {
		r0 = rf(ctx, projectID, testSuiteID, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.AddExperiencesToTestSuiteResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, testSuiteID, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_AddExperiencesToTestSuiteWithBodyWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddExperiencesToTestSuiteWithBodyWithResponse'
type ClientWithResponsesInterface_AddExperiencesToTestSuiteWithBodyWithResponse_Call struct {
	*mock.Call
}

// AddExperiencesToTestSuiteWithBodyWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - testSuiteID uuid.UUID
//   - contentType string
//   - body io.Reader
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) AddExperiencesToTestSuiteWithBodyWithResponse(ctx interface{}, projectID interface{}, testSuiteID interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_AddExperiencesToTestSuiteWithBodyWithResponse_Call {
	return &ClientWithResponsesInterface_AddExperiencesToTestSuiteWithBodyWithResponse_Call{Call: _e.mock.On("AddExperiencesToTestSuiteWithBodyWithResponse",
		append([]interface{}{ctx, projectID, testSuiteID, contentType, body}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_AddExperiencesToTestSuiteWithBodyWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, testSuiteID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_AddExperiencesToTestSuiteWithBodyWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(string), args[4].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_AddExperiencesToTestSuiteWithBodyWithResponse_Call) Return(_a0 *api.AddExperiencesToTestSuiteResponse, _a1 error) *ClientWithResponsesInterface_AddExperiencesToTestSuiteWithBodyWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_AddExperiencesToTestSuiteWithBodyWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*api.AddExperiencesToTestSuiteResponse, error)) *ClientWithResponsesInterface_AddExperiencesToTestSuiteWithBodyWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// AddExperiencesToTestSuiteWithResponse provides a mock function with given fields: ctx, projectID, testSuiteID, body, reqEditors
func (_m *ClientWithResponsesInterface) AddExperiencesToTestSuiteWithResponse(ctx context.Context, projectID uuid.UUID, testSuiteID uuid.UUID, body api.SelectExperiencesInput, reqEditors ...api.RequestEditorFn) (*api.AddExperiencesToTestSuiteResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, testSuiteID, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddExperiencesToTestSuiteWithResponse")
	}

	var r0 *api.AddExperiencesToTestSuiteResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, api.SelectExperiencesInput, ...api.RequestEditorFn) (*api.AddExperiencesToTestSuiteResponse, error)); ok {
		return rf(ctx, projectID, testSuiteID, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, api.SelectExperiencesInput, ...api.RequestEditorFn) *api.AddExperiencesToTestSuiteResponse); ok {
		r0 = rf(ctx, projectID, testSuiteID, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.AddExperiencesToTestSuiteResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, api.SelectExperiencesInput, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, testSuiteID, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_AddExperiencesToTestSuiteWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddExperiencesToTestSuiteWithResponse'
type ClientWithResponsesInterface_AddExperiencesToTestSuiteWithResponse_Call struct {
	*mock.Call
}

// AddExperiencesToTestSuiteWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - testSuiteID uuid.UUID
//   - body api.SelectExperiencesInput
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) AddExperiencesToTestSuiteWithResponse(ctx interface{}, projectID interface{}, testSuiteID interface{}, body interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_AddExperiencesToTestSuiteWithResponse_Call {
	return &ClientWithResponsesInterface_AddExperiencesToTestSuiteWithResponse_Call{Call: _e.mock.On("AddExperiencesToTestSuiteWithResponse",
		append([]interface{}{ctx, projectID, testSuiteID, body}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_AddExperiencesToTestSuiteWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, testSuiteID uuid.UUID, body api.SelectExperiencesInput, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_AddExperiencesToTestSuiteWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(api.SelectExperiencesInput), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_AddExperiencesToTestSuiteWithResponse_Call) Return(_a0 *api.AddExperiencesToTestSuiteResponse, _a1 error) *ClientWithResponsesInterface_AddExperiencesToTestSuiteWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_AddExperiencesToTestSuiteWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, api.SelectExperiencesInput, ...api.RequestEditorFn) (*api.AddExperiencesToTestSuiteResponse, error)) *ClientWithResponsesInterface_AddExperiencesToTestSuiteWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// AddSystemToExperienceWithResponse provides a mock function with given fields: ctx, projectID, systemID, experienceID, reqEditors
func (_m *ClientWithResponsesInterface) AddSystemToExperienceWithResponse(ctx context.Context, projectID uuid.UUID, systemID uuid.UUID, experienceID uuid.UUID, reqEditors ...api.RequestEditorFn) (*api.AddSystemToExperienceResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, systemID, experienceID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddSystemToExperienceWithResponse")
	}

	var r0 *api.AddSystemToExperienceResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*api.AddSystemToExperienceResponse, error)); ok {
		return rf(ctx, projectID, systemID, experienceID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) *api.AddSystemToExperienceResponse); ok {
		r0 = rf(ctx, projectID, systemID, experienceID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.AddSystemToExperienceResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, systemID, experienceID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_AddSystemToExperienceWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddSystemToExperienceWithResponse'
type ClientWithResponsesInterface_AddSystemToExperienceWithResponse_Call struct {
	*mock.Call
}

// AddSystemToExperienceWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - systemID uuid.UUID
//   - experienceID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) AddSystemToExperienceWithResponse(ctx interface{}, projectID interface{}, systemID interface{}, experienceID interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_AddSystemToExperienceWithResponse_Call {
	return &ClientWithResponsesInterface_AddSystemToExperienceWithResponse_Call{Call: _e.mock.On("AddSystemToExperienceWithResponse",
		append([]interface{}{ctx, projectID, systemID, experienceID}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_AddSystemToExperienceWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, systemID uuid.UUID, experienceID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_AddSystemToExperienceWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_AddSystemToExperienceWithResponse_Call) Return(_a0 *api.AddSystemToExperienceResponse, _a1 error) *ClientWithResponsesInterface_AddSystemToExperienceWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_AddSystemToExperienceWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*api.AddSystemToExperienceResponse, error)) *ClientWithResponsesInterface_AddSystemToExperienceWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// AddSystemToMetricsBuildWithResponse provides a mock function with given fields: ctx, projectID, systemID, metricsBuildID, reqEditors
func (_m *ClientWithResponsesInterface) AddSystemToMetricsBuildWithResponse(ctx context.Context, projectID uuid.UUID, systemID uuid.UUID, metricsBuildID uuid.UUID, reqEditors ...api.RequestEditorFn) (*api.AddSystemToMetricsBuildResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, systemID, metricsBuildID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddSystemToMetricsBuildWithResponse")
	}

	var r0 *api.AddSystemToMetricsBuildResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*api.AddSystemToMetricsBuildResponse, error)); ok {
		return rf(ctx, projectID, systemID, metricsBuildID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) *api.AddSystemToMetricsBuildResponse); ok {
		r0 = rf(ctx, projectID, systemID, metricsBuildID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.AddSystemToMetricsBuildResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, systemID, metricsBuildID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_AddSystemToMetricsBuildWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddSystemToMetricsBuildWithResponse'
type ClientWithResponsesInterface_AddSystemToMetricsBuildWithResponse_Call struct {
	*mock.Call
}

// AddSystemToMetricsBuildWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - systemID uuid.UUID
//   - metricsBuildID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) AddSystemToMetricsBuildWithResponse(ctx interface{}, projectID interface{}, systemID interface{}, metricsBuildID interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_AddSystemToMetricsBuildWithResponse_Call {
	return &ClientWithResponsesInterface_AddSystemToMetricsBuildWithResponse_Call{Call: _e.mock.On("AddSystemToMetricsBuildWithResponse",
		append([]interface{}{ctx, projectID, systemID, metricsBuildID}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_AddSystemToMetricsBuildWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, systemID uuid.UUID, metricsBuildID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_AddSystemToMetricsBuildWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_AddSystemToMetricsBuildWithResponse_Call) Return(_a0 *api.AddSystemToMetricsBuildResponse, _a1 error) *ClientWithResponsesInterface_AddSystemToMetricsBuildWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_AddSystemToMetricsBuildWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*api.AddSystemToMetricsBuildResponse, error)) *ClientWithResponsesInterface_AddSystemToMetricsBuildWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// AddSystemsToExperiencesWithBodyWithResponse provides a mock function with given fields: ctx, projectID, contentType, body, reqEditors
func (_m *ClientWithResponsesInterface) AddSystemsToExperiencesWithBodyWithResponse(ctx context.Context, projectID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn) (*api.AddSystemsToExperiencesResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddSystemsToExperiencesWithBodyWithResponse")
	}

	var r0 *api.AddSystemsToExperiencesResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*api.AddSystemsToExperiencesResponse, error)); ok {
		return rf(ctx, projectID, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) *api.AddSystemsToExperiencesResponse); ok {
		r0 = rf(ctx, projectID, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.AddSystemsToExperiencesResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_AddSystemsToExperiencesWithBodyWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddSystemsToExperiencesWithBodyWithResponse'
type ClientWithResponsesInterface_AddSystemsToExperiencesWithBodyWithResponse_Call struct {
	*mock.Call
}

// AddSystemsToExperiencesWithBodyWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - contentType string
//   - body io.Reader
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) AddSystemsToExperiencesWithBodyWithResponse(ctx interface{}, projectID interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_AddSystemsToExperiencesWithBodyWithResponse_Call {
	return &ClientWithResponsesInterface_AddSystemsToExperiencesWithBodyWithResponse_Call{Call: _e.mock.On("AddSystemsToExperiencesWithBodyWithResponse",
		append([]interface{}{ctx, projectID, contentType, body}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_AddSystemsToExperiencesWithBodyWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_AddSystemsToExperiencesWithBodyWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(string), args[3].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_AddSystemsToExperiencesWithBodyWithResponse_Call) Return(_a0 *api.AddSystemsToExperiencesResponse, _a1 error) *ClientWithResponsesInterface_AddSystemsToExperiencesWithBodyWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_AddSystemsToExperiencesWithBodyWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*api.AddSystemsToExperiencesResponse, error)) *ClientWithResponsesInterface_AddSystemsToExperiencesWithBodyWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// AddSystemsToExperiencesWithResponse provides a mock function with given fields: ctx, projectID, body, reqEditors
func (_m *ClientWithResponsesInterface) AddSystemsToExperiencesWithResponse(ctx context.Context, projectID uuid.UUID, body api.MutateSystemsToExperienceInput, reqEditors ...api.RequestEditorFn) (*api.AddSystemsToExperiencesResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddSystemsToExperiencesWithResponse")
	}

	var r0 *api.AddSystemsToExperiencesResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, api.MutateSystemsToExperienceInput, ...api.RequestEditorFn) (*api.AddSystemsToExperiencesResponse, error)); ok {
		return rf(ctx, projectID, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, api.MutateSystemsToExperienceInput, ...api.RequestEditorFn) *api.AddSystemsToExperiencesResponse); ok {
		r0 = rf(ctx, projectID, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.AddSystemsToExperiencesResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, api.MutateSystemsToExperienceInput, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_AddSystemsToExperiencesWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddSystemsToExperiencesWithResponse'
type ClientWithResponsesInterface_AddSystemsToExperiencesWithResponse_Call struct {
	*mock.Call
}

// AddSystemsToExperiencesWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - body api.MutateSystemsToExperienceInput
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) AddSystemsToExperiencesWithResponse(ctx interface{}, projectID interface{}, body interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_AddSystemsToExperiencesWithResponse_Call {
	return &ClientWithResponsesInterface_AddSystemsToExperiencesWithResponse_Call{Call: _e.mock.On("AddSystemsToExperiencesWithResponse",
		append([]interface{}{ctx, projectID, body}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_AddSystemsToExperiencesWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, body api.MutateSystemsToExperienceInput, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_AddSystemsToExperiencesWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(api.MutateSystemsToExperienceInput), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_AddSystemsToExperiencesWithResponse_Call) Return(_a0 *api.AddSystemsToExperiencesResponse, _a1 error) *ClientWithResponsesInterface_AddSystemsToExperiencesWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_AddSystemsToExperiencesWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, api.MutateSystemsToExperienceInput, ...api.RequestEditorFn) (*api.AddSystemsToExperiencesResponse, error)) *ClientWithResponsesInterface_AddSystemsToExperiencesWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// AddTagsToExperiencesWithBodyWithResponse provides a mock function with given fields: ctx, projectID, contentType, body, reqEditors
func (_m *ClientWithResponsesInterface) AddTagsToExperiencesWithBodyWithResponse(ctx context.Context, projectID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn) (*api.AddTagsToExperiencesResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddTagsToExperiencesWithBodyWithResponse")
	}

	var r0 *api.AddTagsToExperiencesResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*api.AddTagsToExperiencesResponse, error)); ok {
		return rf(ctx, projectID, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) *api.AddTagsToExperiencesResponse); ok {
		r0 = rf(ctx, projectID, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.AddTagsToExperiencesResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_AddTagsToExperiencesWithBodyWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddTagsToExperiencesWithBodyWithResponse'
type ClientWithResponsesInterface_AddTagsToExperiencesWithBodyWithResponse_Call struct {
	*mock.Call
}

// AddTagsToExperiencesWithBodyWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - contentType string
//   - body io.Reader
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) AddTagsToExperiencesWithBodyWithResponse(ctx interface{}, projectID interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_AddTagsToExperiencesWithBodyWithResponse_Call {
	return &ClientWithResponsesInterface_AddTagsToExperiencesWithBodyWithResponse_Call{Call: _e.mock.On("AddTagsToExperiencesWithBodyWithResponse",
		append([]interface{}{ctx, projectID, contentType, body}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_AddTagsToExperiencesWithBodyWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_AddTagsToExperiencesWithBodyWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(string), args[3].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_AddTagsToExperiencesWithBodyWithResponse_Call) Return(_a0 *api.AddTagsToExperiencesResponse, _a1 error) *ClientWithResponsesInterface_AddTagsToExperiencesWithBodyWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_AddTagsToExperiencesWithBodyWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*api.AddTagsToExperiencesResponse, error)) *ClientWithResponsesInterface_AddTagsToExperiencesWithBodyWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// AddTagsToExperiencesWithResponse provides a mock function with given fields: ctx, projectID, body, reqEditors
func (_m *ClientWithResponsesInterface) AddTagsToExperiencesWithResponse(ctx context.Context, projectID uuid.UUID, body api.AddTagsToExperiencesInput, reqEditors ...api.RequestEditorFn) (*api.AddTagsToExperiencesResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddTagsToExperiencesWithResponse")
	}

	var r0 *api.AddTagsToExperiencesResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, api.AddTagsToExperiencesInput, ...api.RequestEditorFn) (*api.AddTagsToExperiencesResponse, error)); ok {
		return rf(ctx, projectID, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, api.AddTagsToExperiencesInput, ...api.RequestEditorFn) *api.AddTagsToExperiencesResponse); ok {
		r0 = rf(ctx, projectID, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.AddTagsToExperiencesResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, api.AddTagsToExperiencesInput, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_AddTagsToExperiencesWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddTagsToExperiencesWithResponse'
type ClientWithResponsesInterface_AddTagsToExperiencesWithResponse_Call struct {
	*mock.Call
}

// AddTagsToExperiencesWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - body api.AddTagsToExperiencesInput
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) AddTagsToExperiencesWithResponse(ctx interface{}, projectID interface{}, body interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_AddTagsToExperiencesWithResponse_Call {
	return &ClientWithResponsesInterface_AddTagsToExperiencesWithResponse_Call{Call: _e.mock.On("AddTagsToExperiencesWithResponse",
		append([]interface{}{ctx, projectID, body}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_AddTagsToExperiencesWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, body api.AddTagsToExperiencesInput, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_AddTagsToExperiencesWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(api.AddTagsToExperiencesInput), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_AddTagsToExperiencesWithResponse_Call) Return(_a0 *api.AddTagsToExperiencesResponse, _a1 error) *ClientWithResponsesInterface_AddTagsToExperiencesWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_AddTagsToExperiencesWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, api.AddTagsToExperiencesInput, ...api.RequestEditorFn) (*api.AddTagsToExperiencesResponse, error)) *ClientWithResponsesInterface_AddTagsToExperiencesWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// AddTestSuitesToExperiencesWithBodyWithResponse provides a mock function with given fields: ctx, projectID, contentType, body, reqEditors
func (_m *ClientWithResponsesInterface) AddTestSuitesToExperiencesWithBodyWithResponse(ctx context.Context, projectID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn) (*api.AddTestSuitesToExperiencesResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddTestSuitesToExperiencesWithBodyWithResponse")
	}

	var r0 *api.AddTestSuitesToExperiencesResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*api.AddTestSuitesToExperiencesResponse, error)); ok {
		return rf(ctx, projectID, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) *api.AddTestSuitesToExperiencesResponse); ok {
		r0 = rf(ctx, projectID, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.AddTestSuitesToExperiencesResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_AddTestSuitesToExperiencesWithBodyWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddTestSuitesToExperiencesWithBodyWithResponse'
type ClientWithResponsesInterface_AddTestSuitesToExperiencesWithBodyWithResponse_Call struct {
	*mock.Call
}

// AddTestSuitesToExperiencesWithBodyWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - contentType string
//   - body io.Reader
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) AddTestSuitesToExperiencesWithBodyWithResponse(ctx interface{}, projectID interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_AddTestSuitesToExperiencesWithBodyWithResponse_Call {
	return &ClientWithResponsesInterface_AddTestSuitesToExperiencesWithBodyWithResponse_Call{Call: _e.mock.On("AddTestSuitesToExperiencesWithBodyWithResponse",
		append([]interface{}{ctx, projectID, contentType, body}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_AddTestSuitesToExperiencesWithBodyWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_AddTestSuitesToExperiencesWithBodyWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(string), args[3].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_AddTestSuitesToExperiencesWithBodyWithResponse_Call) Return(_a0 *api.AddTestSuitesToExperiencesResponse, _a1 error) *ClientWithResponsesInterface_AddTestSuitesToExperiencesWithBodyWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_AddTestSuitesToExperiencesWithBodyWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*api.AddTestSuitesToExperiencesResponse, error)) *ClientWithResponsesInterface_AddTestSuitesToExperiencesWithBodyWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// AddTestSuitesToExperiencesWithResponse provides a mock function with given fields: ctx, projectID, body, reqEditors
func (_m *ClientWithResponsesInterface) AddTestSuitesToExperiencesWithResponse(ctx context.Context, projectID uuid.UUID, body api.AddSuitesToExperiencesInput, reqEditors ...api.RequestEditorFn) (*api.AddTestSuitesToExperiencesResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddTestSuitesToExperiencesWithResponse")
	}

	var r0 *api.AddTestSuitesToExperiencesResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, api.AddSuitesToExperiencesInput, ...api.RequestEditorFn) (*api.AddTestSuitesToExperiencesResponse, error)); ok {
		return rf(ctx, projectID, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, api.AddSuitesToExperiencesInput, ...api.RequestEditorFn) *api.AddTestSuitesToExperiencesResponse); ok {
		r0 = rf(ctx, projectID, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.AddTestSuitesToExperiencesResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, api.AddSuitesToExperiencesInput, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_AddTestSuitesToExperiencesWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddTestSuitesToExperiencesWithResponse'
type ClientWithResponsesInterface_AddTestSuitesToExperiencesWithResponse_Call struct {
	*mock.Call
}

// AddTestSuitesToExperiencesWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - body api.AddSuitesToExperiencesInput
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) AddTestSuitesToExperiencesWithResponse(ctx interface{}, projectID interface{}, body interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_AddTestSuitesToExperiencesWithResponse_Call {
	return &ClientWithResponsesInterface_AddTestSuitesToExperiencesWithResponse_Call{Call: _e.mock.On("AddTestSuitesToExperiencesWithResponse",
		append([]interface{}{ctx, projectID, body}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_AddTestSuitesToExperiencesWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, body api.AddSuitesToExperiencesInput, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_AddTestSuitesToExperiencesWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(api.AddSuitesToExperiencesInput), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_AddTestSuitesToExperiencesWithResponse_Call) Return(_a0 *api.AddTestSuitesToExperiencesResponse, _a1 error) *ClientWithResponsesInterface_AddTestSuitesToExperiencesWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_AddTestSuitesToExperiencesWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, api.AddSuitesToExperiencesInput, ...api.RequestEditorFn) (*api.AddTestSuitesToExperiencesResponse, error)) *ClientWithResponsesInterface_AddTestSuitesToExperiencesWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// ArchiveExperienceWithResponse provides a mock function with given fields: ctx, projectID, experienceID, reqEditors
func (_m *ClientWithResponsesInterface) ArchiveExperienceWithResponse(ctx context.Context, projectID uuid.UUID, experienceID uuid.UUID, reqEditors ...api.RequestEditorFn) (*api.ArchiveExperienceResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, experienceID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ArchiveExperienceWithResponse")
	}

	var r0 *api.ArchiveExperienceResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*api.ArchiveExperienceResponse, error)); ok {
		return rf(ctx, projectID, experienceID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) *api.ArchiveExperienceResponse); ok {
		r0 = rf(ctx, projectID, experienceID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ArchiveExperienceResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, experienceID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_ArchiveExperienceWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ArchiveExperienceWithResponse'
type ClientWithResponsesInterface_ArchiveExperienceWithResponse_Call struct {
	*mock.Call
}

// ArchiveExperienceWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - experienceID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) ArchiveExperienceWithResponse(ctx interface{}, projectID interface{}, experienceID interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_ArchiveExperienceWithResponse_Call {
	return &ClientWithResponsesInterface_ArchiveExperienceWithResponse_Call{Call: _e.mock.On("ArchiveExperienceWithResponse",
		append([]interface{}{ctx, projectID, experienceID}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_ArchiveExperienceWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, experienceID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_ArchiveExperienceWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_ArchiveExperienceWithResponse_Call) Return(_a0 *api.ArchiveExperienceResponse, _a1 error) *ClientWithResponsesInterface_ArchiveExperienceWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_ArchiveExperienceWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*api.ArchiveExperienceResponse, error)) *ClientWithResponsesInterface_ArchiveExperienceWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// ArchiveProjectWithResponse provides a mock function with given fields: ctx, projectID, reqEditors
func (_m *ClientWithResponsesInterface) ArchiveProjectWithResponse(ctx context.Context, projectID uuid.UUID, reqEditors ...api.RequestEditorFn) (*api.ArchiveProjectResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ArchiveProjectWithResponse")
	}

	var r0 *api.ArchiveProjectResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, ...api.RequestEditorFn) (*api.ArchiveProjectResponse, error)); ok {
		return rf(ctx, projectID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, ...api.RequestEditorFn) *api.ArchiveProjectResponse); ok {
		r0 = rf(ctx, projectID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ArchiveProjectResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_ArchiveProjectWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ArchiveProjectWithResponse'
type ClientWithResponsesInterface_ArchiveProjectWithResponse_Call struct {
	*mock.Call
}

// ArchiveProjectWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) ArchiveProjectWithResponse(ctx interface{}, projectID interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_ArchiveProjectWithResponse_Call {
	return &ClientWithResponsesInterface_ArchiveProjectWithResponse_Call{Call: _e.mock.On("ArchiveProjectWithResponse",
		append([]interface{}{ctx, projectID}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_ArchiveProjectWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_ArchiveProjectWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_ArchiveProjectWithResponse_Call) Return(_a0 *api.ArchiveProjectResponse, _a1 error) *ClientWithResponsesInterface_ArchiveProjectWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_ArchiveProjectWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, ...api.RequestEditorFn) (*api.ArchiveProjectResponse, error)) *ClientWithResponsesInterface_ArchiveProjectWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// ArchiveSystemWithResponse provides a mock function with given fields: ctx, projectID, systemID, reqEditors
func (_m *ClientWithResponsesInterface) ArchiveSystemWithResponse(ctx context.Context, projectID uuid.UUID, systemID uuid.UUID, reqEditors ...api.RequestEditorFn) (*api.ArchiveSystemResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, systemID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ArchiveSystemWithResponse")
	}

	var r0 *api.ArchiveSystemResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*api.ArchiveSystemResponse, error)); ok {
		return rf(ctx, projectID, systemID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) *api.ArchiveSystemResponse); ok {
		r0 = rf(ctx, projectID, systemID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ArchiveSystemResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, systemID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_ArchiveSystemWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ArchiveSystemWithResponse'
type ClientWithResponsesInterface_ArchiveSystemWithResponse_Call struct {
	*mock.Call
}

// ArchiveSystemWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - systemID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) ArchiveSystemWithResponse(ctx interface{}, projectID interface{}, systemID interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_ArchiveSystemWithResponse_Call {
	return &ClientWithResponsesInterface_ArchiveSystemWithResponse_Call{Call: _e.mock.On("ArchiveSystemWithResponse",
		append([]interface{}{ctx, projectID, systemID}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_ArchiveSystemWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, systemID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_ArchiveSystemWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_ArchiveSystemWithResponse_Call) Return(_a0 *api.ArchiveSystemResponse, _a1 error) *ClientWithResponsesInterface_ArchiveSystemWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_ArchiveSystemWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*api.ArchiveSystemResponse, error)) *ClientWithResponsesInterface_ArchiveSystemWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// ArchiveTestSuiteWithResponse provides a mock function with given fields: ctx, projectID, testSuiteID, reqEditors
func (_m *ClientWithResponsesInterface) ArchiveTestSuiteWithResponse(ctx context.Context, projectID uuid.UUID, testSuiteID uuid.UUID, reqEditors ...api.RequestEditorFn) (*api.ArchiveTestSuiteResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, testSuiteID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ArchiveTestSuiteWithResponse")
	}

	var r0 *api.ArchiveTestSuiteResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*api.ArchiveTestSuiteResponse, error)); ok {
		return rf(ctx, projectID, testSuiteID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) *api.ArchiveTestSuiteResponse); ok {
		r0 = rf(ctx, projectID, testSuiteID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ArchiveTestSuiteResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, testSuiteID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_ArchiveTestSuiteWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ArchiveTestSuiteWithResponse'
type ClientWithResponsesInterface_ArchiveTestSuiteWithResponse_Call struct {
	*mock.Call
}

// ArchiveTestSuiteWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - testSuiteID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) ArchiveTestSuiteWithResponse(ctx interface{}, projectID interface{}, testSuiteID interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_ArchiveTestSuiteWithResponse_Call {
	return &ClientWithResponsesInterface_ArchiveTestSuiteWithResponse_Call{Call: _e.mock.On("ArchiveTestSuiteWithResponse",
		append([]interface{}{ctx, projectID, testSuiteID}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_ArchiveTestSuiteWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, testSuiteID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_ArchiveTestSuiteWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_ArchiveTestSuiteWithResponse_Call) Return(_a0 *api.ArchiveTestSuiteResponse, _a1 error) *ClientWithResponsesInterface_ArchiveTestSuiteWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_ArchiveTestSuiteWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*api.ArchiveTestSuiteResponse, error)) *ClientWithResponsesInterface_ArchiveTestSuiteWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// BulkArchiveExperiencesWithBodyWithResponse provides a mock function with given fields: ctx, projectID, contentType, body, reqEditors
func (_m *ClientWithResponsesInterface) BulkArchiveExperiencesWithBodyWithResponse(ctx context.Context, projectID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn) (*api.BulkArchiveExperiencesResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BulkArchiveExperiencesWithBodyWithResponse")
	}

	var r0 *api.BulkArchiveExperiencesResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*api.BulkArchiveExperiencesResponse, error)); ok {
		return rf(ctx, projectID, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) *api.BulkArchiveExperiencesResponse); ok {
		r0 = rf(ctx, projectID, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.BulkArchiveExperiencesResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_BulkArchiveExperiencesWithBodyWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BulkArchiveExperiencesWithBodyWithResponse'
type ClientWithResponsesInterface_BulkArchiveExperiencesWithBodyWithResponse_Call struct {
	*mock.Call
}

// BulkArchiveExperiencesWithBodyWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - contentType string
//   - body io.Reader
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) BulkArchiveExperiencesWithBodyWithResponse(ctx interface{}, projectID interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_BulkArchiveExperiencesWithBodyWithResponse_Call {
	return &ClientWithResponsesInterface_BulkArchiveExperiencesWithBodyWithResponse_Call{Call: _e.mock.On("BulkArchiveExperiencesWithBodyWithResponse",
		append([]interface{}{ctx, projectID, contentType, body}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_BulkArchiveExperiencesWithBodyWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_BulkArchiveExperiencesWithBodyWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(string), args[3].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_BulkArchiveExperiencesWithBodyWithResponse_Call) Return(_a0 *api.BulkArchiveExperiencesResponse, _a1 error) *ClientWithResponsesInterface_BulkArchiveExperiencesWithBodyWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_BulkArchiveExperiencesWithBodyWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*api.BulkArchiveExperiencesResponse, error)) *ClientWithResponsesInterface_BulkArchiveExperiencesWithBodyWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// BulkArchiveExperiencesWithResponse provides a mock function with given fields: ctx, projectID, body, reqEditors
func (_m *ClientWithResponsesInterface) BulkArchiveExperiencesWithResponse(ctx context.Context, projectID uuid.UUID, body api.BulkArchiveExperiencesInput, reqEditors ...api.RequestEditorFn) (*api.BulkArchiveExperiencesResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BulkArchiveExperiencesWithResponse")
	}

	var r0 *api.BulkArchiveExperiencesResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, api.BulkArchiveExperiencesInput, ...api.RequestEditorFn) (*api.BulkArchiveExperiencesResponse, error)); ok {
		return rf(ctx, projectID, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, api.BulkArchiveExperiencesInput, ...api.RequestEditorFn) *api.BulkArchiveExperiencesResponse); ok {
		r0 = rf(ctx, projectID, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.BulkArchiveExperiencesResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, api.BulkArchiveExperiencesInput, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_BulkArchiveExperiencesWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BulkArchiveExperiencesWithResponse'
type ClientWithResponsesInterface_BulkArchiveExperiencesWithResponse_Call struct {
	*mock.Call
}

// BulkArchiveExperiencesWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - body api.BulkArchiveExperiencesInput
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) BulkArchiveExperiencesWithResponse(ctx interface{}, projectID interface{}, body interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_BulkArchiveExperiencesWithResponse_Call {
	return &ClientWithResponsesInterface_BulkArchiveExperiencesWithResponse_Call{Call: _e.mock.On("BulkArchiveExperiencesWithResponse",
		append([]interface{}{ctx, projectID, body}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_BulkArchiveExperiencesWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, body api.BulkArchiveExperiencesInput, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_BulkArchiveExperiencesWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(api.BulkArchiveExperiencesInput), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_BulkArchiveExperiencesWithResponse_Call) Return(_a0 *api.BulkArchiveExperiencesResponse, _a1 error) *ClientWithResponsesInterface_BulkArchiveExperiencesWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_BulkArchiveExperiencesWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, api.BulkArchiveExperiencesInput, ...api.RequestEditorFn) (*api.BulkArchiveExperiencesResponse, error)) *ClientWithResponsesInterface_BulkArchiveExperiencesWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// CancelBatchWithResponse provides a mock function with given fields: ctx, projectID, batchID, reqEditors
func (_m *ClientWithResponsesInterface) CancelBatchWithResponse(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, reqEditors ...api.RequestEditorFn) (*api.CancelBatchResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, batchID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CancelBatchWithResponse")
	}

	var r0 *api.CancelBatchResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*api.CancelBatchResponse, error)); ok {
		return rf(ctx, projectID, batchID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) *api.CancelBatchResponse); ok {
		r0 = rf(ctx, projectID, batchID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.CancelBatchResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, batchID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_CancelBatchWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CancelBatchWithResponse'
type ClientWithResponsesInterface_CancelBatchWithResponse_Call struct {
	*mock.Call
}

// CancelBatchWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - batchID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) CancelBatchWithResponse(ctx interface{}, projectID interface{}, batchID interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_CancelBatchWithResponse_Call {
	return &ClientWithResponsesInterface_CancelBatchWithResponse_Call{Call: _e.mock.On("CancelBatchWithResponse",
		append([]interface{}{ctx, projectID, batchID}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_CancelBatchWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_CancelBatchWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_CancelBatchWithResponse_Call) Return(_a0 *api.CancelBatchResponse, _a1 error) *ClientWithResponsesInterface_CancelBatchWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_CancelBatchWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*api.CancelBatchResponse, error)) *ClientWithResponsesInterface_CancelBatchWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// CancelParameterSweepWithResponse provides a mock function with given fields: ctx, projectID, sweepID, reqEditors
func (_m *ClientWithResponsesInterface) CancelParameterSweepWithResponse(ctx context.Context, projectID uuid.UUID, sweepID uuid.UUID, reqEditors ...api.RequestEditorFn) (*api.CancelParameterSweepResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, sweepID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CancelParameterSweepWithResponse")
	}

	var r0 *api.CancelParameterSweepResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*api.CancelParameterSweepResponse, error)); ok {
		return rf(ctx, projectID, sweepID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) *api.CancelParameterSweepResponse); ok {
		r0 = rf(ctx, projectID, sweepID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.CancelParameterSweepResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, sweepID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_CancelParameterSweepWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CancelParameterSweepWithResponse'
type ClientWithResponsesInterface_CancelParameterSweepWithResponse_Call struct {
	*mock.Call
}

// CancelParameterSweepWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - sweepID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) CancelParameterSweepWithResponse(ctx interface{}, projectID interface{}, sweepID interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_CancelParameterSweepWithResponse_Call {
	return &ClientWithResponsesInterface_CancelParameterSweepWithResponse_Call{Call: _e.mock.On("CancelParameterSweepWithResponse",
		append([]interface{}{ctx, projectID, sweepID}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_CancelParameterSweepWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, sweepID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_CancelParameterSweepWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_CancelParameterSweepWithResponse_Call) Return(_a0 *api.CancelParameterSweepResponse, _a1 error) *ClientWithResponsesInterface_CancelParameterSweepWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_CancelParameterSweepWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*api.CancelParameterSweepResponse, error)) *ClientWithResponsesInterface_CancelParameterSweepWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// CompareBatchesWithResponse provides a mock function with given fields: ctx, projectID, batchID, otherBatchID, params, reqEditors
func (_m *ClientWithResponsesInterface) CompareBatchesWithResponse(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, otherBatchID uuid.UUID, params *api.CompareBatchesParams, reqEditors ...api.RequestEditorFn) (*api.CompareBatchesResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, batchID, otherBatchID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CompareBatchesWithResponse")
	}

	var r0 *api.CompareBatchesResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, *api.CompareBatchesParams, ...api.RequestEditorFn) (*api.CompareBatchesResponse, error)); ok {
		return rf(ctx, projectID, batchID, otherBatchID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, *api.CompareBatchesParams, ...api.RequestEditorFn) *api.CompareBatchesResponse); ok {
		r0 = rf(ctx, projectID, batchID, otherBatchID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.CompareBatchesResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, *api.CompareBatchesParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, batchID, otherBatchID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_CompareBatchesWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CompareBatchesWithResponse'
type ClientWithResponsesInterface_CompareBatchesWithResponse_Call struct {
	*mock.Call
}

// CompareBatchesWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - batchID uuid.UUID
//   - otherBatchID uuid.UUID
//   - params *api.CompareBatchesParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) CompareBatchesWithResponse(ctx interface{}, projectID interface{}, batchID interface{}, otherBatchID interface{}, params interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_CompareBatchesWithResponse_Call {
	return &ClientWithResponsesInterface_CompareBatchesWithResponse_Call{Call: _e.mock.On("CompareBatchesWithResponse",
		append([]interface{}{ctx, projectID, batchID, otherBatchID, params}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_CompareBatchesWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, otherBatchID uuid.UUID, params *api.CompareBatchesParams, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_CompareBatchesWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(uuid.UUID), args[4].(*api.CompareBatchesParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_CompareBatchesWithResponse_Call) Return(_a0 *api.CompareBatchesResponse, _a1 error) *ClientWithResponsesInterface_CompareBatchesWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_CompareBatchesWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, *api.CompareBatchesParams, ...api.RequestEditorFn) (*api.CompareBatchesResponse, error)) *ClientWithResponsesInterface_CompareBatchesWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// CreateBatchForTestSuiteRevisionWithBodyWithResponse provides a mock function with given fields: ctx, projectID, testSuiteID, revision, contentType, body, reqEditors
func (_m *ClientWithResponsesInterface) CreateBatchForTestSuiteRevisionWithBodyWithResponse(ctx context.Context, projectID uuid.UUID, testSuiteID uuid.UUID, revision int32, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn) (*api.CreateBatchForTestSuiteRevisionResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, testSuiteID, revision, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateBatchForTestSuiteRevisionWithBodyWithResponse")
	}

	var r0 *api.CreateBatchForTestSuiteRevisionResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, int32, string, io.Reader, ...api.RequestEditorFn) (*api.CreateBatchForTestSuiteRevisionResponse, error)); ok {
		return rf(ctx, projectID, testSuiteID, revision, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, int32, string, io.Reader, ...api.RequestEditorFn) *api.CreateBatchForTestSuiteRevisionResponse); ok {
		r0 = rf(ctx, projectID, testSuiteID, revision, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.CreateBatchForTestSuiteRevisionResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, int32, string, io.Reader, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, testSuiteID, revision, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_CreateBatchForTestSuiteRevisionWithBodyWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateBatchForTestSuiteRevisionWithBodyWithResponse'
type ClientWithResponsesInterface_CreateBatchForTestSuiteRevisionWithBodyWithResponse_Call struct {
	*mock.Call
}

// CreateBatchForTestSuiteRevisionWithBodyWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - testSuiteID uuid.UUID
//   - revision int32
//   - contentType string
//   - body io.Reader
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) CreateBatchForTestSuiteRevisionWithBodyWithResponse(ctx interface{}, projectID interface{}, testSuiteID interface{}, revision interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_CreateBatchForTestSuiteRevisionWithBodyWithResponse_Call {
	return &ClientWithResponsesInterface_CreateBatchForTestSuiteRevisionWithBodyWithResponse_Call{Call: _e.mock.On("CreateBatchForTestSuiteRevisionWithBodyWithResponse",
		append([]interface{}{ctx, projectID, testSuiteID, revision, contentType, body}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_CreateBatchForTestSuiteRevisionWithBodyWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, testSuiteID uuid.UUID, revision int32, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_CreateBatchForTestSuiteRevisionWithBodyWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-6)
		for i, a := range args[6:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(int32), args[4].(string), args[5].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_CreateBatchForTestSuiteRevisionWithBodyWithResponse_Call) Return(_a0 *api.CreateBatchForTestSuiteRevisionResponse, _a1 error) *ClientWithResponsesInterface_CreateBatchForTestSuiteRevisionWithBodyWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_CreateBatchForTestSuiteRevisionWithBodyWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, int32, string, io.Reader, ...api.RequestEditorFn) (*api.CreateBatchForTestSuiteRevisionResponse, error)) *ClientWithResponsesInterface_CreateBatchForTestSuiteRevisionWithBodyWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// CreateBatchForTestSuiteRevisionWithResponse provides a mock function with given fields: ctx, projectID, testSuiteID, revision, body, reqEditors
func (_m *ClientWithResponsesInterface) CreateBatchForTestSuiteRevisionWithResponse(ctx context.Context, projectID uuid.UUID, testSuiteID uuid.UUID, revision int32, body api.TestSuiteBatchInput, reqEditors ...api.RequestEditorFn) (*api.CreateBatchForTestSuiteRevisionResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, testSuiteID, revision, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateBatchForTestSuiteRevisionWithResponse")
	}

	var r0 *api.CreateBatchForTestSuiteRevisionResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, int32, api.TestSuiteBatchInput, ...api.RequestEditorFn) (*api.CreateBatchForTestSuiteRevisionResponse, error)); ok {
		return rf(ctx, projectID, testSuiteID, revision, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, int32, api.TestSuiteBatchInput, ...api.RequestEditorFn) *api.CreateBatchForTestSuiteRevisionResponse); ok {
		r0 = rf(ctx, projectID, testSuiteID, revision, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.CreateBatchForTestSuiteRevisionResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, int32, api.TestSuiteBatchInput, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, testSuiteID, revision, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_CreateBatchForTestSuiteRevisionWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateBatchForTestSuiteRevisionWithResponse'
type ClientWithResponsesInterface_CreateBatchForTestSuiteRevisionWithResponse_Call struct {
	*mock.Call
}

// CreateBatchForTestSuiteRevisionWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - testSuiteID uuid.UUID
//   - revision int32
//   - body api.TestSuiteBatchInput
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) CreateBatchForTestSuiteRevisionWithResponse(ctx interface{}, projectID interface{}, testSuiteID interface{}, revision interface{}, body interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_CreateBatchForTestSuiteRevisionWithResponse_Call {
	return &ClientWithResponsesInterface_CreateBatchForTestSuiteRevisionWithResponse_Call{Call: _e.mock.On("CreateBatchForTestSuiteRevisionWithResponse",
		append([]interface{}{ctx, projectID, testSuiteID, revision, body}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_CreateBatchForTestSuiteRevisionWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, testSuiteID uuid.UUID, revision int32, body api.TestSuiteBatchInput, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_CreateBatchForTestSuiteRevisionWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(int32), args[4].(api.TestSuiteBatchInput), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_CreateBatchForTestSuiteRevisionWithResponse_Call) Return(_a0 *api.CreateBatchForTestSuiteRevisionResponse, _a1 error) *ClientWithResponsesInterface_CreateBatchForTestSuiteRevisionWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_CreateBatchForTestSuiteRevisionWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, int32, api.TestSuiteBatchInput, ...api.RequestEditorFn) (*api.CreateBatchForTestSuiteRevisionResponse, error)) *ClientWithResponsesInterface_CreateBatchForTestSuiteRevisionWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// CreateBatchForTestSuiteWithBodyWithResponse provides a mock function with given fields: ctx, projectID, testSuiteID, contentType, body, reqEditors
func (_m *ClientWithResponsesInterface) CreateBatchForTestSuiteWithBodyWithResponse(ctx context.Context, projectID uuid.UUID, testSuiteID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn) (*api.CreateBatchForTestSuiteResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, testSuiteID, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateBatchForTestSuiteWithBodyWithResponse")
	}

	var r0 *api.CreateBatchForTestSuiteResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*api.CreateBatchForTestSuiteResponse, error)); ok {
		return rf(ctx, projectID, testSuiteID, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) *api.CreateBatchForTestSuiteResponse); ok {
		r0 = rf(ctx, projectID, testSuiteID, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.CreateBatchForTestSuiteResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, testSuiteID, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_CreateBatchForTestSuiteWithBodyWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateBatchForTestSuiteWithBodyWithResponse'
type ClientWithResponsesInterface_CreateBatchForTestSuiteWithBodyWithResponse_Call struct {
	*mock.Call
}

// CreateBatchForTestSuiteWithBodyWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - testSuiteID uuid.UUID
//   - contentType string
//   - body io.Reader
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) CreateBatchForTestSuiteWithBodyWithResponse(ctx interface{}, projectID interface{}, testSuiteID interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_CreateBatchForTestSuiteWithBodyWithResponse_Call {
	return &ClientWithResponsesInterface_CreateBatchForTestSuiteWithBodyWithResponse_Call{Call: _e.mock.On("CreateBatchForTestSuiteWithBodyWithResponse",
		append([]interface{}{ctx, projectID, testSuiteID, contentType, body}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_CreateBatchForTestSuiteWithBodyWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, testSuiteID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_CreateBatchForTestSuiteWithBodyWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(string), args[4].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_CreateBatchForTestSuiteWithBodyWithResponse_Call) Return(_a0 *api.CreateBatchForTestSuiteResponse, _a1 error) *ClientWithResponsesInterface_CreateBatchForTestSuiteWithBodyWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_CreateBatchForTestSuiteWithBodyWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*api.CreateBatchForTestSuiteResponse, error)) *ClientWithResponsesInterface_CreateBatchForTestSuiteWithBodyWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// CreateBatchForTestSuiteWithResponse provides a mock function with given fields: ctx, projectID, testSuiteID, body, reqEditors
func (_m *ClientWithResponsesInterface) CreateBatchForTestSuiteWithResponse(ctx context.Context, projectID uuid.UUID, testSuiteID uuid.UUID, body api.TestSuiteBatchInput, reqEditors ...api.RequestEditorFn) (*api.CreateBatchForTestSuiteResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, testSuiteID, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateBatchForTestSuiteWithResponse")
	}

	var r0 *api.CreateBatchForTestSuiteResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, api.TestSuiteBatchInput, ...api.RequestEditorFn) (*api.CreateBatchForTestSuiteResponse, error)); ok {
		return rf(ctx, projectID, testSuiteID, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, api.TestSuiteBatchInput, ...api.RequestEditorFn) *api.CreateBatchForTestSuiteResponse); ok {
		r0 = rf(ctx, projectID, testSuiteID, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.CreateBatchForTestSuiteResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, api.TestSuiteBatchInput, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, testSuiteID, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_CreateBatchForTestSuiteWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateBatchForTestSuiteWithResponse'
type ClientWithResponsesInterface_CreateBatchForTestSuiteWithResponse_Call struct {
	*mock.Call
}

// CreateBatchForTestSuiteWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - testSuiteID uuid.UUID
//   - body api.TestSuiteBatchInput
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) CreateBatchForTestSuiteWithResponse(ctx interface{}, projectID interface{}, testSuiteID interface{}, body interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_CreateBatchForTestSuiteWithResponse_Call {
	return &ClientWithResponsesInterface_CreateBatchForTestSuiteWithResponse_Call{Call: _e.mock.On("CreateBatchForTestSuiteWithResponse",
		append([]interface{}{ctx, projectID, testSuiteID, body}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_CreateBatchForTestSuiteWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, testSuiteID uuid.UUID, body api.TestSuiteBatchInput, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_CreateBatchForTestSuiteWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(api.TestSuiteBatchInput), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_CreateBatchForTestSuiteWithResponse_Call) Return(_a0 *api.CreateBatchForTestSuiteResponse, _a1 error) *ClientWithResponsesInterface_CreateBatchForTestSuiteWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_CreateBatchForTestSuiteWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, api.TestSuiteBatchInput, ...api.RequestEditorFn) (*api.CreateBatchForTestSuiteResponse, error)) *ClientWithResponsesInterface_CreateBatchForTestSuiteWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// CreateBatchWithBodyWithResponse provides a mock function with given fields: ctx, projectID, contentType, body, reqEditors
func (_m *ClientWithResponsesInterface) CreateBatchWithBodyWithResponse(ctx context.Context, projectID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn) (*api.CreateBatchResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateBatchWithBodyWithResponse")
	}

	var r0 *api.CreateBatchResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*api.CreateBatchResponse, error)); ok {
		return rf(ctx, projectID, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) *api.CreateBatchResponse); ok {
		r0 = rf(ctx, projectID, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.CreateBatchResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_CreateBatchWithBodyWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateBatchWithBodyWithResponse'
type ClientWithResponsesInterface_CreateBatchWithBodyWithResponse_Call struct {
	*mock.Call
}

// CreateBatchWithBodyWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - contentType string
//   - body io.Reader
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) CreateBatchWithBodyWithResponse(ctx interface{}, projectID interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_CreateBatchWithBodyWithResponse_Call {
	return &ClientWithResponsesInterface_CreateBatchWithBodyWithResponse_Call{Call: _e.mock.On("CreateBatchWithBodyWithResponse",
		append([]interface{}{ctx, projectID, contentType, body}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_CreateBatchWithBodyWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_CreateBatchWithBodyWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(string), args[3].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_CreateBatchWithBodyWithResponse_Call) Return(_a0 *api.CreateBatchResponse, _a1 error) *ClientWithResponsesInterface_CreateBatchWithBodyWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_CreateBatchWithBodyWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*api.CreateBatchResponse, error)) *ClientWithResponsesInterface_CreateBatchWithBodyWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// CreateBatchWithResponse provides a mock function with given fields: ctx, projectID, body, reqEditors
func (_m *ClientWithResponsesInterface) CreateBatchWithResponse(ctx context.Context, projectID uuid.UUID, body api.BatchInput, reqEditors ...api.RequestEditorFn) (*api.CreateBatchResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateBatchWithResponse")
	}

	var r0 *api.CreateBatchResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, api.BatchInput, ...api.RequestEditorFn) (*api.CreateBatchResponse, error)); ok {
		return rf(ctx, projectID, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, api.BatchInput, ...api.RequestEditorFn) *api.CreateBatchResponse); ok {
		r0 = rf(ctx, projectID, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.CreateBatchResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, api.BatchInput, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_CreateBatchWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateBatchWithResponse'
type ClientWithResponsesInterface_CreateBatchWithResponse_Call struct {
	*mock.Call
}

// CreateBatchWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - body api.BatchInput
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) CreateBatchWithResponse(ctx interface{}, projectID interface{}, body interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_CreateBatchWithResponse_Call {
	return &ClientWithResponsesInterface_CreateBatchWithResponse_Call{Call: _e.mock.On("CreateBatchWithResponse",
		append([]interface{}{ctx, projectID, body}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_CreateBatchWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, body api.BatchInput, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_CreateBatchWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(api.BatchInput), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_CreateBatchWithResponse_Call) Return(_a0 *api.CreateBatchResponse, _a1 error) *ClientWithResponsesInterface_CreateBatchWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_CreateBatchWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, api.BatchInput, ...api.RequestEditorFn) (*api.CreateBatchResponse, error)) *ClientWithResponsesInterface_CreateBatchWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// CreateBranchForProjectWithBodyWithResponse provides a mock function with given fields: ctx, projectID, contentType, body, reqEditors
func (_m *ClientWithResponsesInterface) CreateBranchForProjectWithBodyWithResponse(ctx context.Context, projectID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn) (*api.CreateBranchForProjectResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateBranchForProjectWithBodyWithResponse")
	}

	var r0 *api.CreateBranchForProjectResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*api.CreateBranchForProjectResponse, error)); ok {
		return rf(ctx, projectID, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) *api.CreateBranchForProjectResponse); ok {
		r0 = rf(ctx, projectID, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.CreateBranchForProjectResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_CreateBranchForProjectWithBodyWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateBranchForProjectWithBodyWithResponse'
type ClientWithResponsesInterface_CreateBranchForProjectWithBodyWithResponse_Call struct {
	*mock.Call
}

// CreateBranchForProjectWithBodyWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - contentType string
//   - body io.Reader
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) CreateBranchForProjectWithBodyWithResponse(ctx interface{}, projectID interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_CreateBranchForProjectWithBodyWithResponse_Call {
	return &ClientWithResponsesInterface_CreateBranchForProjectWithBodyWithResponse_Call{Call: _e.mock.On("CreateBranchForProjectWithBodyWithResponse",
		append([]interface{}{ctx, projectID, contentType, body}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_CreateBranchForProjectWithBodyWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_CreateBranchForProjectWithBodyWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(string), args[3].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_CreateBranchForProjectWithBodyWithResponse_Call) Return(_a0 *api.CreateBranchForProjectResponse, _a1 error) *ClientWithResponsesInterface_CreateBranchForProjectWithBodyWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_CreateBranchForProjectWithBodyWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*api.CreateBranchForProjectResponse, error)) *ClientWithResponsesInterface_CreateBranchForProjectWithBodyWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// CreateBranchForProjectWithResponse provides a mock function with given fields: ctx, projectID, body, reqEditors
func (_m *ClientWithResponsesInterface) CreateBranchForProjectWithResponse(ctx context.Context, projectID uuid.UUID, body api.CreateBranchInput, reqEditors ...api.RequestEditorFn) (*api.CreateBranchForProjectResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateBranchForProjectWithResponse")
	}

	var r0 *api.CreateBranchForProjectResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, api.CreateBranchInput, ...api.RequestEditorFn) (*api.CreateBranchForProjectResponse, error)); ok {
		return rf(ctx, projectID, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, api.CreateBranchInput, ...api.RequestEditorFn) *api.CreateBranchForProjectResponse); ok {
		r0 = rf(ctx, projectID, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.CreateBranchForProjectResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, api.CreateBranchInput, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_CreateBranchForProjectWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateBranchForProjectWithResponse'
type ClientWithResponsesInterface_CreateBranchForProjectWithResponse_Call struct {
	*mock.Call
}

// CreateBranchForProjectWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - body api.CreateBranchInput
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) CreateBranchForProjectWithResponse(ctx interface{}, projectID interface{}, body interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_CreateBranchForProjectWithResponse_Call {
	return &ClientWithResponsesInterface_CreateBranchForProjectWithResponse_Call{Call: _e.mock.On("CreateBranchForProjectWithResponse",
		append([]interface{}{ctx, projectID, body}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_CreateBranchForProjectWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, body api.CreateBranchInput, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_CreateBranchForProjectWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(api.CreateBranchInput), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_CreateBranchForProjectWithResponse_Call) Return(_a0 *api.CreateBranchForProjectResponse, _a1 error) *ClientWithResponsesInterface_CreateBranchForProjectWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_CreateBranchForProjectWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, api.CreateBranchInput, ...api.RequestEditorFn) (*api.CreateBranchForProjectResponse, error)) *ClientWithResponsesInterface_CreateBranchForProjectWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// CreateBuildForBranchWithBodyWithResponse provides a mock function with given fields: ctx, projectID, branchID, contentType, body, reqEditors
func (_m *ClientWithResponsesInterface) CreateBuildForBranchWithBodyWithResponse(ctx context.Context, projectID uuid.UUID, branchID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn) (*api.CreateBuildForBranchResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, branchID, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateBuildForBranchWithBodyWithResponse")
	}

	var r0 *api.CreateBuildForBranchResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*api.CreateBuildForBranchResponse, error)); ok {
		return rf(ctx, projectID, branchID, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) *api.CreateBuildForBranchResponse); ok {
		r0 = rf(ctx, projectID, branchID, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.CreateBuildForBranchResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, branchID, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_CreateBuildForBranchWithBodyWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateBuildForBranchWithBodyWithResponse'
type ClientWithResponsesInterface_CreateBuildForBranchWithBodyWithResponse_Call struct {
	*mock.Call
}

// CreateBuildForBranchWithBodyWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - branchID uuid.UUID
//   - contentType string
//   - body io.Reader
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) CreateBuildForBranchWithBodyWithResponse(ctx interface{}, projectID interface{}, branchID interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_CreateBuildForBranchWithBodyWithResponse_Call {
	return &ClientWithResponsesInterface_CreateBuildForBranchWithBodyWithResponse_Call{Call: _e.mock.On("CreateBuildForBranchWithBodyWithResponse",
		append([]interface{}{ctx, projectID, branchID, contentType, body}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_CreateBuildForBranchWithBodyWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, branchID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_CreateBuildForBranchWithBodyWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(string), args[4].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_CreateBuildForBranchWithBodyWithResponse_Call) Return(_a0 *api.CreateBuildForBranchResponse, _a1 error) *ClientWithResponsesInterface_CreateBuildForBranchWithBodyWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_CreateBuildForBranchWithBodyWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*api.CreateBuildForBranchResponse, error)) *ClientWithResponsesInterface_CreateBuildForBranchWithBodyWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// CreateBuildForBranchWithResponse provides a mock function with given fields: ctx, projectID, branchID, body, reqEditors
func (_m *ClientWithResponsesInterface) CreateBuildForBranchWithResponse(ctx context.Context, projectID uuid.UUID, branchID uuid.UUID, body api.CreateBuildForBranchInput, reqEditors ...api.RequestEditorFn) (*api.CreateBuildForBranchResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, branchID, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateBuildForBranchWithResponse")
	}

	var r0 *api.CreateBuildForBranchResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, api.CreateBuildForBranchInput, ...api.RequestEditorFn) (*api.CreateBuildForBranchResponse, error)); ok {
		return rf(ctx, projectID, branchID, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, api.CreateBuildForBranchInput, ...api.RequestEditorFn) *api.CreateBuildForBranchResponse); ok {
		r0 = rf(ctx, projectID, branchID, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.CreateBuildForBranchResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, api.CreateBuildForBranchInput, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, branchID, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_CreateBuildForBranchWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateBuildForBranchWithResponse'
type ClientWithResponsesInterface_CreateBuildForBranchWithResponse_Call struct {
	*mock.Call
}

// CreateBuildForBranchWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - branchID uuid.UUID
//   - body api.CreateBuildForBranchInput
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) CreateBuildForBranchWithResponse(ctx interface{}, projectID interface{}, branchID interface{}, body interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_CreateBuildForBranchWithResponse_Call {
	return &ClientWithResponsesInterface_CreateBuildForBranchWithResponse_Call{Call: _e.mock.On("CreateBuildForBranchWithResponse",
		append([]interface{}{ctx, projectID, branchID, body}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_CreateBuildForBranchWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, branchID uuid.UUID, body api.CreateBuildForBranchInput, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_CreateBuildForBranchWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(api.CreateBuildForBranchInput), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_CreateBuildForBranchWithResponse_Call) Return(_a0 *api.CreateBuildForBranchResponse, _a1 error) *ClientWithResponsesInterface_CreateBuildForBranchWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_CreateBuildForBranchWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, api.CreateBuildForBranchInput, ...api.RequestEditorFn) (*api.CreateBuildForBranchResponse, error)) *ClientWithResponsesInterface_CreateBuildForBranchWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// CreateBuildForSystemWithBodyWithResponse provides a mock function with given fields: ctx, projectID, systemID, contentType, body, reqEditors
func (_m *ClientWithResponsesInterface) CreateBuildForSystemWithBodyWithResponse(ctx context.Context, projectID uuid.UUID, systemID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn) (*api.CreateBuildForSystemResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, systemID, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateBuildForSystemWithBodyWithResponse")
	}

	var r0 *api.CreateBuildForSystemResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*api.CreateBuildForSystemResponse, error)); ok {
		return rf(ctx, projectID, systemID, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) *api.CreateBuildForSystemResponse); ok {
		r0 = rf(ctx, projectID, systemID, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.CreateBuildForSystemResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, systemID, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_CreateBuildForSystemWithBodyWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateBuildForSystemWithBodyWithResponse'
type ClientWithResponsesInterface_CreateBuildForSystemWithBodyWithResponse_Call struct {
	*mock.Call
}

// CreateBuildForSystemWithBodyWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - systemID uuid.UUID
//   - contentType string
//   - body io.Reader
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) CreateBuildForSystemWithBodyWithResponse(ctx interface{}, projectID interface{}, systemID interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_CreateBuildForSystemWithBodyWithResponse_Call {
	return &ClientWithResponsesInterface_CreateBuildForSystemWithBodyWithResponse_Call{Call: _e.mock.On("CreateBuildForSystemWithBodyWithResponse",
		append([]interface{}{ctx, projectID, systemID, contentType, body}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_CreateBuildForSystemWithBodyWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, systemID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_CreateBuildForSystemWithBodyWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(string), args[4].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_CreateBuildForSystemWithBodyWithResponse_Call) Return(_a0 *api.CreateBuildForSystemResponse, _a1 error) *ClientWithResponsesInterface_CreateBuildForSystemWithBodyWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_CreateBuildForSystemWithBodyWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*api.CreateBuildForSystemResponse, error)) *ClientWithResponsesInterface_CreateBuildForSystemWithBodyWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// CreateBuildForSystemWithResponse provides a mock function with given fields: ctx, projectID, systemID, body, reqEditors
func (_m *ClientWithResponsesInterface) CreateBuildForSystemWithResponse(ctx context.Context, projectID uuid.UUID, systemID uuid.UUID, body api.CreateBuildForSystemInput, reqEditors ...api.RequestEditorFn) (*api.CreateBuildForSystemResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, systemID, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateBuildForSystemWithResponse")
	}

	var r0 *api.CreateBuildForSystemResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, api.CreateBuildForSystemInput, ...api.RequestEditorFn) (*api.CreateBuildForSystemResponse, error)); ok {
		return rf(ctx, projectID, systemID, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, api.CreateBuildForSystemInput, ...api.RequestEditorFn) *api.CreateBuildForSystemResponse); ok {
		r0 = rf(ctx, projectID, systemID, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.CreateBuildForSystemResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, api.CreateBuildForSystemInput, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, systemID, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_CreateBuildForSystemWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateBuildForSystemWithResponse'
type ClientWithResponsesInterface_CreateBuildForSystemWithResponse_Call struct {
	*mock.Call
}

// CreateBuildForSystemWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - systemID uuid.UUID
//   - body api.CreateBuildForSystemInput
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) CreateBuildForSystemWithResponse(ctx interface{}, projectID interface{}, systemID interface{}, body interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_CreateBuildForSystemWithResponse_Call {
	return &ClientWithResponsesInterface_CreateBuildForSystemWithResponse_Call{Call: _e.mock.On("CreateBuildForSystemWithResponse",
		append([]interface{}{ctx, projectID, systemID, body}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_CreateBuildForSystemWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, systemID uuid.UUID, body api.CreateBuildForSystemInput, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_CreateBuildForSystemWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(api.CreateBuildForSystemInput), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_CreateBuildForSystemWithResponse_Call) Return(_a0 *api.CreateBuildForSystemResponse, _a1 error) *ClientWithResponsesInterface_CreateBuildForSystemWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_CreateBuildForSystemWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, api.CreateBuildForSystemInput, ...api.RequestEditorFn) (*api.CreateBuildForSystemResponse, error)) *ClientWithResponsesInterface_CreateBuildForSystemWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// CreateExperienceTagWithBodyWithResponse provides a mock function with given fields: ctx, projectID, contentType, body, reqEditors
func (_m *ClientWithResponsesInterface) CreateExperienceTagWithBodyWithResponse(ctx context.Context, projectID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn) (*api.CreateExperienceTagResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateExperienceTagWithBodyWithResponse")
	}

	var r0 *api.CreateExperienceTagResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*api.CreateExperienceTagResponse, error)); ok {
		return rf(ctx, projectID, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) *api.CreateExperienceTagResponse); ok {
		r0 = rf(ctx, projectID, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.CreateExperienceTagResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_CreateExperienceTagWithBodyWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateExperienceTagWithBodyWithResponse'
type ClientWithResponsesInterface_CreateExperienceTagWithBodyWithResponse_Call struct {
	*mock.Call
}

// CreateExperienceTagWithBodyWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - contentType string
//   - body io.Reader
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) CreateExperienceTagWithBodyWithResponse(ctx interface{}, projectID interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_CreateExperienceTagWithBodyWithResponse_Call {
	return &ClientWithResponsesInterface_CreateExperienceTagWithBodyWithResponse_Call{Call: _e.mock.On("CreateExperienceTagWithBodyWithResponse",
		append([]interface{}{ctx, projectID, contentType, body}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_CreateExperienceTagWithBodyWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_CreateExperienceTagWithBodyWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(string), args[3].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_CreateExperienceTagWithBodyWithResponse_Call) Return(_a0 *api.CreateExperienceTagResponse, _a1 error) *ClientWithResponsesInterface_CreateExperienceTagWithBodyWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_CreateExperienceTagWithBodyWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*api.CreateExperienceTagResponse, error)) *ClientWithResponsesInterface_CreateExperienceTagWithBodyWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// CreateExperienceTagWithResponse provides a mock function with given fields: ctx, projectID, body, reqEditors
func (_m *ClientWithResponsesInterface) CreateExperienceTagWithResponse(ctx context.Context, projectID uuid.UUID, body api.CreateExperienceTagInput, reqEditors ...api.RequestEditorFn) (*api.CreateExperienceTagResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateExperienceTagWithResponse")
	}

	var r0 *api.CreateExperienceTagResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, api.CreateExperienceTagInput, ...api.RequestEditorFn) (*api.CreateExperienceTagResponse, error)); ok {
		return rf(ctx, projectID, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, api.CreateExperienceTagInput, ...api.RequestEditorFn) *api.CreateExperienceTagResponse); ok {
		r0 = rf(ctx, projectID, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.CreateExperienceTagResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, api.CreateExperienceTagInput, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_CreateExperienceTagWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateExperienceTagWithResponse'
type ClientWithResponsesInterface_CreateExperienceTagWithResponse_Call struct {
	*mock.Call
}

// CreateExperienceTagWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - body api.CreateExperienceTagInput
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) CreateExperienceTagWithResponse(ctx interface{}, projectID interface{}, body interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_CreateExperienceTagWithResponse_Call {
	return &ClientWithResponsesInterface_CreateExperienceTagWithResponse_Call{Call: _e.mock.On("CreateExperienceTagWithResponse",
		append([]interface{}{ctx, projectID, body}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_CreateExperienceTagWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, body api.CreateExperienceTagInput, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_CreateExperienceTagWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(api.CreateExperienceTagInput), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_CreateExperienceTagWithResponse_Call) Return(_a0 *api.CreateExperienceTagResponse, _a1 error) *ClientWithResponsesInterface_CreateExperienceTagWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_CreateExperienceTagWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, api.CreateExperienceTagInput, ...api.RequestEditorFn) (*api.CreateExperienceTagResponse, error)) *ClientWithResponsesInterface_CreateExperienceTagWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// CreateExperienceWithBodyWithResponse provides a mock function with given fields: ctx, projectID, contentType, body, reqEditors
func (_m *ClientWithResponsesInterface) CreateExperienceWithBodyWithResponse(ctx context.Context, projectID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn) (*api.CreateExperienceResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateExperienceWithBodyWithResponse")
	}

	var r0 *api.CreateExperienceResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*api.CreateExperienceResponse, error)); ok {
		return rf(ctx, projectID, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) *api.CreateExperienceResponse); ok {
		r0 = rf(ctx, projectID, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.CreateExperienceResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_CreateExperienceWithBodyWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateExperienceWithBodyWithResponse'
type ClientWithResponsesInterface_CreateExperienceWithBodyWithResponse_Call struct {
	*mock.Call
}

// CreateExperienceWithBodyWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - contentType string
//   - body io.Reader
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) CreateExperienceWithBodyWithResponse(ctx interface{}, projectID interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_CreateExperienceWithBodyWithResponse_Call {
	return &ClientWithResponsesInterface_CreateExperienceWithBodyWithResponse_Call{Call: _e.mock.On("CreateExperienceWithBodyWithResponse",
		append([]interface{}{ctx, projectID, contentType, body}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_CreateExperienceWithBodyWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_CreateExperienceWithBodyWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(string), args[3].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_CreateExperienceWithBodyWithResponse_Call) Return(_a0 *api.CreateExperienceResponse, _a1 error) *ClientWithResponsesInterface_CreateExperienceWithBodyWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_CreateExperienceWithBodyWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*api.CreateExperienceResponse, error)) *ClientWithResponsesInterface_CreateExperienceWithBodyWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// CreateExperienceWithResponse provides a mock function with given fields: ctx, projectID, body, reqEditors
func (_m *ClientWithResponsesInterface) CreateExperienceWithResponse(ctx context.Context, projectID uuid.UUID, body api.CreateExperienceInput, reqEditors ...api.RequestEditorFn) (*api.CreateExperienceResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateExperienceWithResponse")
	}

	var r0 *api.CreateExperienceResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, api.CreateExperienceInput, ...api.RequestEditorFn) (*api.CreateExperienceResponse, error)); ok {
		return rf(ctx, projectID, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, api.CreateExperienceInput, ...api.RequestEditorFn) *api.CreateExperienceResponse); ok {
		r0 = rf(ctx, projectID, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.CreateExperienceResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, api.CreateExperienceInput, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_CreateExperienceWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateExperienceWithResponse'
type ClientWithResponsesInterface_CreateExperienceWithResponse_Call struct {
	*mock.Call
}

// CreateExperienceWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - body api.CreateExperienceInput
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) CreateExperienceWithResponse(ctx interface{}, projectID interface{}, body interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_CreateExperienceWithResponse_Call {
	return &ClientWithResponsesInterface_CreateExperienceWithResponse_Call{Call: _e.mock.On("CreateExperienceWithResponse",
		append([]interface{}{ctx, projectID, body}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_CreateExperienceWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, body api.CreateExperienceInput, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_CreateExperienceWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(api.CreateExperienceInput), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_CreateExperienceWithResponse_Call) Return(_a0 *api.CreateExperienceResponse, _a1 error) *ClientWithResponsesInterface_CreateExperienceWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_CreateExperienceWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, api.CreateExperienceInput, ...api.RequestEditorFn) (*api.CreateExperienceResponse, error)) *ClientWithResponsesInterface_CreateExperienceWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// CreateMetricsBuildWithBodyWithResponse provides a mock function with given fields: ctx, projectID, contentType, body, reqEditors
func (_m *ClientWithResponsesInterface) CreateMetricsBuildWithBodyWithResponse(ctx context.Context, projectID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn) (*api.CreateMetricsBuildResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateMetricsBuildWithBodyWithResponse")
	}

	var r0 *api.CreateMetricsBuildResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*api.CreateMetricsBuildResponse, error)); ok {
		return rf(ctx, projectID, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) *api.CreateMetricsBuildResponse); ok {
		r0 = rf(ctx, projectID, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.CreateMetricsBuildResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_CreateMetricsBuildWithBodyWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateMetricsBuildWithBodyWithResponse'
type ClientWithResponsesInterface_CreateMetricsBuildWithBodyWithResponse_Call struct {
	*mock.Call
}

// CreateMetricsBuildWithBodyWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - contentType string
//   - body io.Reader
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) CreateMetricsBuildWithBodyWithResponse(ctx interface{}, projectID interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_CreateMetricsBuildWithBodyWithResponse_Call {
	return &ClientWithResponsesInterface_CreateMetricsBuildWithBodyWithResponse_Call{Call: _e.mock.On("CreateMetricsBuildWithBodyWithResponse",
		append([]interface{}{ctx, projectID, contentType, body}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_CreateMetricsBuildWithBodyWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_CreateMetricsBuildWithBodyWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(string), args[3].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_CreateMetricsBuildWithBodyWithResponse_Call) Return(_a0 *api.CreateMetricsBuildResponse, _a1 error) *ClientWithResponsesInterface_CreateMetricsBuildWithBodyWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_CreateMetricsBuildWithBodyWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*api.CreateMetricsBuildResponse, error)) *ClientWithResponsesInterface_CreateMetricsBuildWithBodyWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// CreateMetricsBuildWithResponse provides a mock function with given fields: ctx, projectID, body, reqEditors
func (_m *ClientWithResponsesInterface) CreateMetricsBuildWithResponse(ctx context.Context, projectID uuid.UUID, body api.CreateMetricsBuildInput, reqEditors ...api.RequestEditorFn) (*api.CreateMetricsBuildResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateMetricsBuildWithResponse")
	}

	var r0 *api.CreateMetricsBuildResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, api.CreateMetricsBuildInput, ...api.RequestEditorFn) (*api.CreateMetricsBuildResponse, error)); ok {
		return rf(ctx, projectID, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, api.CreateMetricsBuildInput, ...api.RequestEditorFn) *api.CreateMetricsBuildResponse); ok {
		r0 = rf(ctx, projectID, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.CreateMetricsBuildResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, api.CreateMetricsBuildInput, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_CreateMetricsBuildWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateMetricsBuildWithResponse'
type ClientWithResponsesInterface_CreateMetricsBuildWithResponse_Call struct {
	*mock.Call
}

// CreateMetricsBuildWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - body api.CreateMetricsBuildInput
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) CreateMetricsBuildWithResponse(ctx interface{}, projectID interface{}, body interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_CreateMetricsBuildWithResponse_Call {
	return &ClientWithResponsesInterface_CreateMetricsBuildWithResponse_Call{Call: _e.mock.On("CreateMetricsBuildWithResponse",
		append([]interface{}{ctx, projectID, body}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_CreateMetricsBuildWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, body api.CreateMetricsBuildInput, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_CreateMetricsBuildWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(api.CreateMetricsBuildInput), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_CreateMetricsBuildWithResponse_Call) Return(_a0 *api.CreateMetricsBuildResponse, _a1 error) *ClientWithResponsesInterface_CreateMetricsBuildWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_CreateMetricsBuildWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, api.CreateMetricsBuildInput, ...api.RequestEditorFn) (*api.CreateMetricsBuildResponse, error)) *ClientWithResponsesInterface_CreateMetricsBuildWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// CreateParameterSweepWithBodyWithResponse provides a mock function with given fields: ctx, projectID, contentType, body, reqEditors
func (_m *ClientWithResponsesInterface) CreateParameterSweepWithBodyWithResponse(ctx context.Context, projectID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn) (*api.CreateParameterSweepResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateParameterSweepWithBodyWithResponse")
	}

	var r0 *api.CreateParameterSweepResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*api.CreateParameterSweepResponse, error)); ok {
		return rf(ctx, projectID, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) *api.CreateParameterSweepResponse); ok {
		r0 = rf(ctx, projectID, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.CreateParameterSweepResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_CreateParameterSweepWithBodyWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateParameterSweepWithBodyWithResponse'
type ClientWithResponsesInterface_CreateParameterSweepWithBodyWithResponse_Call struct {
	*mock.Call
}

// CreateParameterSweepWithBodyWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - contentType string
//   - body io.Reader
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) CreateParameterSweepWithBodyWithResponse(ctx interface{}, projectID interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_CreateParameterSweepWithBodyWithResponse_Call {
	return &ClientWithResponsesInterface_CreateParameterSweepWithBodyWithResponse_Call{Call: _e.mock.On("CreateParameterSweepWithBodyWithResponse",
		append([]interface{}{ctx, projectID, contentType, body}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_CreateParameterSweepWithBodyWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_CreateParameterSweepWithBodyWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(string), args[3].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_CreateParameterSweepWithBodyWithResponse_Call) Return(_a0 *api.CreateParameterSweepResponse, _a1 error) *ClientWithResponsesInterface_CreateParameterSweepWithBodyWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_CreateParameterSweepWithBodyWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*api.CreateParameterSweepResponse, error)) *ClientWithResponsesInterface_CreateParameterSweepWithBodyWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// CreateParameterSweepWithResponse provides a mock function with given fields: ctx, projectID, body, reqEditors
func (_m *ClientWithResponsesInterface) CreateParameterSweepWithResponse(ctx context.Context, projectID uuid.UUID, body api.ParameterSweepInput, reqEditors ...api.RequestEditorFn) (*api.CreateParameterSweepResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateParameterSweepWithResponse")
	}

	var r0 *api.CreateParameterSweepResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, api.ParameterSweepInput, ...api.RequestEditorFn) (*api.CreateParameterSweepResponse, error)); ok {
		return rf(ctx, projectID, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, api.ParameterSweepInput, ...api.RequestEditorFn) *api.CreateParameterSweepResponse); ok {
		r0 = rf(ctx, projectID, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.CreateParameterSweepResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, api.ParameterSweepInput, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_CreateParameterSweepWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateParameterSweepWithResponse'
type ClientWithResponsesInterface_CreateParameterSweepWithResponse_Call struct {
	*mock.Call
}

// CreateParameterSweepWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - body api.ParameterSweepInput
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) CreateParameterSweepWithResponse(ctx interface{}, projectID interface{}, body interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_CreateParameterSweepWithResponse_Call {
	return &ClientWithResponsesInterface_CreateParameterSweepWithResponse_Call{Call: _e.mock.On("CreateParameterSweepWithResponse",
		append([]interface{}{ctx, projectID, body}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_CreateParameterSweepWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, body api.ParameterSweepInput, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_CreateParameterSweepWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(api.ParameterSweepInput), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_CreateParameterSweepWithResponse_Call) Return(_a0 *api.CreateParameterSweepResponse, _a1 error) *ClientWithResponsesInterface_CreateParameterSweepWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_CreateParameterSweepWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, api.ParameterSweepInput, ...api.RequestEditorFn) (*api.CreateParameterSweepResponse, error)) *ClientWithResponsesInterface_CreateParameterSweepWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// CreateProjectWithBodyWithResponse provides a mock function with given fields: ctx, contentType, body, reqEditors
func (_m *ClientWithResponsesInterface) CreateProjectWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn) (*api.CreateProjectResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateProjectWithBodyWithResponse")
	}

	var r0 *api.CreateProjectResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, io.Reader, ...api.RequestEditorFn) (*api.CreateProjectResponse, error)); ok {
		return rf(ctx, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, io.Reader, ...api.RequestEditorFn) *api.CreateProjectResponse); ok {
		r0 = rf(ctx, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.CreateProjectResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, io.Reader, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_CreateProjectWithBodyWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateProjectWithBodyWithResponse'
type ClientWithResponsesInterface_CreateProjectWithBodyWithResponse_Call struct {
	*mock.Call
}

// CreateProjectWithBodyWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - contentType string
//   - body io.Reader
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) CreateProjectWithBodyWithResponse(ctx interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_CreateProjectWithBodyWithResponse_Call {
	return &ClientWithResponsesInterface_CreateProjectWithBodyWithResponse_Call{Call: _e.mock.On("CreateProjectWithBodyWithResponse",
		append([]interface{}{ctx, contentType, body}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_CreateProjectWithBodyWithResponse_Call) Run(run func(ctx context.Context, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_CreateProjectWithBodyWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(string), args[2].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_CreateProjectWithBodyWithResponse_Call) Return(_a0 *api.CreateProjectResponse, _a1 error) *ClientWithResponsesInterface_CreateProjectWithBodyWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_CreateProjectWithBodyWithResponse_Call) RunAndReturn(run func(context.Context, string, io.Reader, ...api.RequestEditorFn) (*api.CreateProjectResponse, error)) *ClientWithResponsesInterface_CreateProjectWithBodyWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// CreateProjectWithResponse provides a mock function with given fields: ctx, body, reqEditors
func (_m *ClientWithResponsesInterface) CreateProjectWithResponse(ctx context.Context, body api.CreateProjectInput, reqEditors ...api.RequestEditorFn) (*api.CreateProjectResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateProjectWithResponse")
	}

	var r0 *api.CreateProjectResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, api.CreateProjectInput, ...api.RequestEditorFn) (*api.CreateProjectResponse, error)); ok {
		return rf(ctx, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, api.CreateProjectInput, ...api.RequestEditorFn) *api.CreateProjectResponse); ok {
		r0 = rf(ctx, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.CreateProjectResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, api.CreateProjectInput, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_CreateProjectWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateProjectWithResponse'
type ClientWithResponsesInterface_CreateProjectWithResponse_Call struct {
	*mock.Call
}

// CreateProjectWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - body api.CreateProjectInput
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) CreateProjectWithResponse(ctx interface{}, body interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_CreateProjectWithResponse_Call {
	return &ClientWithResponsesInterface_CreateProjectWithResponse_Call{Call: _e.mock.On("CreateProjectWithResponse",
		append([]interface{}{ctx, body}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_CreateProjectWithResponse_Call) Run(run func(ctx context.Context, body api.CreateProjectInput, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_CreateProjectWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(api.CreateProjectInput), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_CreateProjectWithResponse_Call) Return(_a0 *api.CreateProjectResponse, _a1 error) *ClientWithResponsesInterface_CreateProjectWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_CreateProjectWithResponse_Call) RunAndReturn(run func(context.Context, api.CreateProjectInput, ...api.RequestEditorFn) (*api.CreateProjectResponse, error)) *ClientWithResponsesInterface_CreateProjectWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// CreateReportWithBodyWithResponse provides a mock function with given fields: ctx, projectID, contentType, body, reqEditors
func (_m *ClientWithResponsesInterface) CreateReportWithBodyWithResponse(ctx context.Context, projectID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn) (*api.CreateReportResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateReportWithBodyWithResponse")
	}

	var r0 *api.CreateReportResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*api.CreateReportResponse, error)); ok {
		return rf(ctx, projectID, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) *api.CreateReportResponse); ok {
		r0 = rf(ctx, projectID, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.CreateReportResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_CreateReportWithBodyWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateReportWithBodyWithResponse'
type ClientWithResponsesInterface_CreateReportWithBodyWithResponse_Call struct {
	*mock.Call
}

// CreateReportWithBodyWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - contentType string
//   - body io.Reader
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) CreateReportWithBodyWithResponse(ctx interface{}, projectID interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_CreateReportWithBodyWithResponse_Call {
	return &ClientWithResponsesInterface_CreateReportWithBodyWithResponse_Call{Call: _e.mock.On("CreateReportWithBodyWithResponse",
		append([]interface{}{ctx, projectID, contentType, body}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_CreateReportWithBodyWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_CreateReportWithBodyWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(string), args[3].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_CreateReportWithBodyWithResponse_Call) Return(_a0 *api.CreateReportResponse, _a1 error) *ClientWithResponsesInterface_CreateReportWithBodyWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_CreateReportWithBodyWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*api.CreateReportResponse, error)) *ClientWithResponsesInterface_CreateReportWithBodyWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// CreateReportWithResponse provides a mock function with given fields: ctx, projectID, body, reqEditors
func (_m *ClientWithResponsesInterface) CreateReportWithResponse(ctx context.Context, projectID uuid.UUID, body api.ReportInput, reqEditors ...api.RequestEditorFn) (*api.CreateReportResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateReportWithResponse")
	}

	var r0 *api.CreateReportResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, api.ReportInput, ...api.RequestEditorFn) (*api.CreateReportResponse, error)); ok {
		return rf(ctx, projectID, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, api.ReportInput, ...api.RequestEditorFn) *api.CreateReportResponse); ok {
		r0 = rf(ctx, projectID, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.CreateReportResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, api.ReportInput, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_CreateReportWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateReportWithResponse'
type ClientWithResponsesInterface_CreateReportWithResponse_Call struct {
	*mock.Call
}

// CreateReportWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - body api.ReportInput
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) CreateReportWithResponse(ctx interface{}, projectID interface{}, body interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_CreateReportWithResponse_Call {
	return &ClientWithResponsesInterface_CreateReportWithResponse_Call{Call: _e.mock.On("CreateReportWithResponse",
		append([]interface{}{ctx, projectID, body}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_CreateReportWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, body api.ReportInput, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_CreateReportWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(api.ReportInput), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_CreateReportWithResponse_Call) Return(_a0 *api.CreateReportResponse, _a1 error) *ClientWithResponsesInterface_CreateReportWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_CreateReportWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, api.ReportInput, ...api.RequestEditorFn) (*api.CreateReportResponse, error)) *ClientWithResponsesInterface_CreateReportWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// CreateSystemWithBodyWithResponse provides a mock function with given fields: ctx, projectID, contentType, body, reqEditors
func (_m *ClientWithResponsesInterface) CreateSystemWithBodyWithResponse(ctx context.Context, projectID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn) (*api.CreateSystemResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateSystemWithBodyWithResponse")
	}

	var r0 *api.CreateSystemResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*api.CreateSystemResponse, error)); ok {
		return rf(ctx, projectID, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) *api.CreateSystemResponse); ok {
		r0 = rf(ctx, projectID, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.CreateSystemResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_CreateSystemWithBodyWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateSystemWithBodyWithResponse'
type ClientWithResponsesInterface_CreateSystemWithBodyWithResponse_Call struct {
	*mock.Call
}

// CreateSystemWithBodyWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - contentType string
//   - body io.Reader
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) CreateSystemWithBodyWithResponse(ctx interface{}, projectID interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_CreateSystemWithBodyWithResponse_Call {
	return &ClientWithResponsesInterface_CreateSystemWithBodyWithResponse_Call{Call: _e.mock.On("CreateSystemWithBodyWithResponse",
		append([]interface{}{ctx, projectID, contentType, body}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_CreateSystemWithBodyWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_CreateSystemWithBodyWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(string), args[3].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_CreateSystemWithBodyWithResponse_Call) Return(_a0 *api.CreateSystemResponse, _a1 error) *ClientWithResponsesInterface_CreateSystemWithBodyWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_CreateSystemWithBodyWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*api.CreateSystemResponse, error)) *ClientWithResponsesInterface_CreateSystemWithBodyWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// CreateSystemWithResponse provides a mock function with given fields: ctx, projectID, body, reqEditors
func (_m *ClientWithResponsesInterface) CreateSystemWithResponse(ctx context.Context, projectID uuid.UUID, body api.CreateSystemInput, reqEditors ...api.RequestEditorFn) (*api.CreateSystemResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateSystemWithResponse")
	}

	var r0 *api.CreateSystemResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, api.CreateSystemInput, ...api.RequestEditorFn) (*api.CreateSystemResponse, error)); ok {
		return rf(ctx, projectID, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, api.CreateSystemInput, ...api.RequestEditorFn) *api.CreateSystemResponse); ok {
		r0 = rf(ctx, projectID, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.CreateSystemResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, api.CreateSystemInput, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_CreateSystemWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateSystemWithResponse'
type ClientWithResponsesInterface_CreateSystemWithResponse_Call struct {
	*mock.Call
}

// CreateSystemWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - body api.CreateSystemInput
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) CreateSystemWithResponse(ctx interface{}, projectID interface{}, body interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_CreateSystemWithResponse_Call {
	return &ClientWithResponsesInterface_CreateSystemWithResponse_Call{Call: _e.mock.On("CreateSystemWithResponse",
		append([]interface{}{ctx, projectID, body}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_CreateSystemWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, body api.CreateSystemInput, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_CreateSystemWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(api.CreateSystemInput), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_CreateSystemWithResponse_Call) Return(_a0 *api.CreateSystemResponse, _a1 error) *ClientWithResponsesInterface_CreateSystemWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_CreateSystemWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, api.CreateSystemInput, ...api.RequestEditorFn) (*api.CreateSystemResponse, error)) *ClientWithResponsesInterface_CreateSystemWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// CreateTestSuiteWithBodyWithResponse provides a mock function with given fields: ctx, projectID, contentType, body, reqEditors
func (_m *ClientWithResponsesInterface) CreateTestSuiteWithBodyWithResponse(ctx context.Context, projectID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn) (*api.CreateTestSuiteResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateTestSuiteWithBodyWithResponse")
	}

	var r0 *api.CreateTestSuiteResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*api.CreateTestSuiteResponse, error)); ok {
		return rf(ctx, projectID, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) *api.CreateTestSuiteResponse); ok {
		r0 = rf(ctx, projectID, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.CreateTestSuiteResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_CreateTestSuiteWithBodyWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateTestSuiteWithBodyWithResponse'
type ClientWithResponsesInterface_CreateTestSuiteWithBodyWithResponse_Call struct {
	*mock.Call
}

// CreateTestSuiteWithBodyWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - contentType string
//   - body io.Reader
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) CreateTestSuiteWithBodyWithResponse(ctx interface{}, projectID interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_CreateTestSuiteWithBodyWithResponse_Call {
	return &ClientWithResponsesInterface_CreateTestSuiteWithBodyWithResponse_Call{Call: _e.mock.On("CreateTestSuiteWithBodyWithResponse",
		append([]interface{}{ctx, projectID, contentType, body}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_CreateTestSuiteWithBodyWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_CreateTestSuiteWithBodyWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(string), args[3].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_CreateTestSuiteWithBodyWithResponse_Call) Return(_a0 *api.CreateTestSuiteResponse, _a1 error) *ClientWithResponsesInterface_CreateTestSuiteWithBodyWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_CreateTestSuiteWithBodyWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*api.CreateTestSuiteResponse, error)) *ClientWithResponsesInterface_CreateTestSuiteWithBodyWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// CreateTestSuiteWithResponse provides a mock function with given fields: ctx, projectID, body, reqEditors
func (_m *ClientWithResponsesInterface) CreateTestSuiteWithResponse(ctx context.Context, projectID uuid.UUID, body api.CreateTestSuiteInput, reqEditors ...api.RequestEditorFn) (*api.CreateTestSuiteResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateTestSuiteWithResponse")
	}

	var r0 *api.CreateTestSuiteResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, api.CreateTestSuiteInput, ...api.RequestEditorFn) (*api.CreateTestSuiteResponse, error)); ok {
		return rf(ctx, projectID, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, api.CreateTestSuiteInput, ...api.RequestEditorFn) *api.CreateTestSuiteResponse); ok {
		r0 = rf(ctx, projectID, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.CreateTestSuiteResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, api.CreateTestSuiteInput, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_CreateTestSuiteWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateTestSuiteWithResponse'
type ClientWithResponsesInterface_CreateTestSuiteWithResponse_Call struct {
	*mock.Call
}

// CreateTestSuiteWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - body api.CreateTestSuiteInput
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) CreateTestSuiteWithResponse(ctx interface{}, projectID interface{}, body interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_CreateTestSuiteWithResponse_Call {
	return &ClientWithResponsesInterface_CreateTestSuiteWithResponse_Call{Call: _e.mock.On("CreateTestSuiteWithResponse",
		append([]interface{}{ctx, projectID, body}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_CreateTestSuiteWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, body api.CreateTestSuiteInput, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_CreateTestSuiteWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(api.CreateTestSuiteInput), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_CreateTestSuiteWithResponse_Call) Return(_a0 *api.CreateTestSuiteResponse, _a1 error) *ClientWithResponsesInterface_CreateTestSuiteWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_CreateTestSuiteWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, api.CreateTestSuiteInput, ...api.RequestEditorFn) (*api.CreateTestSuiteResponse, error)) *ClientWithResponsesInterface_CreateTestSuiteWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// CreateViewSessionWithResponse provides a mock function with given fields: ctx, reqEditors
func (_m *ClientWithResponsesInterface) CreateViewSessionWithResponse(ctx context.Context, reqEditors ...api.RequestEditorFn) (*api.CreateViewSessionResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateViewSessionWithResponse")
	}

	var r0 *api.CreateViewSessionResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, ...api.RequestEditorFn) (*api.CreateViewSessionResponse, error)); ok {
		return rf(ctx, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, ...api.RequestEditorFn) *api.CreateViewSessionResponse); ok {
		r0 = rf(ctx, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.CreateViewSessionResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_CreateViewSessionWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateViewSessionWithResponse'
type ClientWithResponsesInterface_CreateViewSessionWithResponse_Call struct {
	*mock.Call
}

// CreateViewSessionWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) CreateViewSessionWithResponse(ctx interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_CreateViewSessionWithResponse_Call {
	return &ClientWithResponsesInterface_CreateViewSessionWithResponse_Call{Call: _e.mock.On("CreateViewSessionWithResponse",
		append([]interface{}{ctx}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_CreateViewSessionWithResponse_Call) Run(run func(ctx context.Context, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_CreateViewSessionWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_CreateViewSessionWithResponse_Call) Return(_a0 *api.CreateViewSessionResponse, _a1 error) *ClientWithResponsesInterface_CreateViewSessionWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_CreateViewSessionWithResponse_Call) RunAndReturn(run func(context.Context, ...api.RequestEditorFn) (*api.CreateViewSessionResponse, error)) *ClientWithResponsesInterface_CreateViewSessionWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// CreateViewUpdateWithBodyWithResponse provides a mock function with given fields: ctx, viewSessionID, viewUpdateID, contentType, body, reqEditors
func (_m *ClientWithResponsesInterface) CreateViewUpdateWithBodyWithResponse(ctx context.Context, viewSessionID uuid.UUID, viewUpdateID int, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn) (*api.CreateViewUpdateResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, viewSessionID, viewUpdateID, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateViewUpdateWithBodyWithResponse")
	}

	var r0 *api.CreateViewUpdateResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, int, string, io.Reader, ...api.RequestEditorFn) (*api.CreateViewUpdateResponse, error)); ok {
		return rf(ctx, viewSessionID, viewUpdateID, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, int, string, io.Reader, ...api.RequestEditorFn) *api.CreateViewUpdateResponse); ok {
		r0 = rf(ctx, viewSessionID, viewUpdateID, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.CreateViewUpdateResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, int, string, io.Reader, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, viewSessionID, viewUpdateID, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_CreateViewUpdateWithBodyWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateViewUpdateWithBodyWithResponse'
type ClientWithResponsesInterface_CreateViewUpdateWithBodyWithResponse_Call struct {
	*mock.Call
}

// CreateViewUpdateWithBodyWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - viewSessionID uuid.UUID
//   - viewUpdateID int
//   - contentType string
//   - body io.Reader
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) CreateViewUpdateWithBodyWithResponse(ctx interface{}, viewSessionID interface{}, viewUpdateID interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_CreateViewUpdateWithBodyWithResponse_Call {
	return &ClientWithResponsesInterface_CreateViewUpdateWithBodyWithResponse_Call{Call: _e.mock.On("CreateViewUpdateWithBodyWithResponse",
		append([]interface{}{ctx, viewSessionID, viewUpdateID, contentType, body}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_CreateViewUpdateWithBodyWithResponse_Call) Run(run func(ctx context.Context, viewSessionID uuid.UUID, viewUpdateID int, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_CreateViewUpdateWithBodyWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(int), args[3].(string), args[4].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_CreateViewUpdateWithBodyWithResponse_Call) Return(_a0 *api.CreateViewUpdateResponse, _a1 error) *ClientWithResponsesInterface_CreateViewUpdateWithBodyWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_CreateViewUpdateWithBodyWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, int, string, io.Reader, ...api.RequestEditorFn) (*api.CreateViewUpdateResponse, error)) *ClientWithResponsesInterface_CreateViewUpdateWithBodyWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// CreateWorkflowRunWithBodyWithResponse provides a mock function with given fields: ctx, projectID, workflowID, contentType, body, reqEditors
func (_m *ClientWithResponsesInterface) CreateWorkflowRunWithBodyWithResponse(ctx context.Context, projectID uuid.UUID, workflowID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn) (*api.CreateWorkflowRunResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, workflowID, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateWorkflowRunWithBodyWithResponse")
	}

	var r0 *api.CreateWorkflowRunResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*api.CreateWorkflowRunResponse, error)); ok {
		return rf(ctx, projectID, workflowID, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) *api.CreateWorkflowRunResponse); ok {
		r0 = rf(ctx, projectID, workflowID, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.CreateWorkflowRunResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, workflowID, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_CreateWorkflowRunWithBodyWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateWorkflowRunWithBodyWithResponse'
type ClientWithResponsesInterface_CreateWorkflowRunWithBodyWithResponse_Call struct {
	*mock.Call
}

// CreateWorkflowRunWithBodyWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - workflowID uuid.UUID
//   - contentType string
//   - body io.Reader
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) CreateWorkflowRunWithBodyWithResponse(ctx interface{}, projectID interface{}, workflowID interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_CreateWorkflowRunWithBodyWithResponse_Call {
	return &ClientWithResponsesInterface_CreateWorkflowRunWithBodyWithResponse_Call{Call: _e.mock.On("CreateWorkflowRunWithBodyWithResponse",
		append([]interface{}{ctx, projectID, workflowID, contentType, body}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_CreateWorkflowRunWithBodyWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, workflowID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_CreateWorkflowRunWithBodyWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(string), args[4].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_CreateWorkflowRunWithBodyWithResponse_Call) Return(_a0 *api.CreateWorkflowRunResponse, _a1 error) *ClientWithResponsesInterface_CreateWorkflowRunWithBodyWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_CreateWorkflowRunWithBodyWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*api.CreateWorkflowRunResponse, error)) *ClientWithResponsesInterface_CreateWorkflowRunWithBodyWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// CreateWorkflowRunWithResponse provides a mock function with given fields: ctx, projectID, workflowID, body, reqEditors
func (_m *ClientWithResponsesInterface) CreateWorkflowRunWithResponse(ctx context.Context, projectID uuid.UUID, workflowID uuid.UUID, body api.CreateWorkflowRunInput, reqEditors ...api.RequestEditorFn) (*api.CreateWorkflowRunResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, workflowID, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateWorkflowRunWithResponse")
	}

	var r0 *api.CreateWorkflowRunResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, api.CreateWorkflowRunInput, ...api.RequestEditorFn) (*api.CreateWorkflowRunResponse, error)); ok {
		return rf(ctx, projectID, workflowID, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, api.CreateWorkflowRunInput, ...api.RequestEditorFn) *api.CreateWorkflowRunResponse); ok {
		r0 = rf(ctx, projectID, workflowID, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.CreateWorkflowRunResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, api.CreateWorkflowRunInput, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, workflowID, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_CreateWorkflowRunWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateWorkflowRunWithResponse'
type ClientWithResponsesInterface_CreateWorkflowRunWithResponse_Call struct {
	*mock.Call
}

// CreateWorkflowRunWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - workflowID uuid.UUID
//   - body api.CreateWorkflowRunInput
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) CreateWorkflowRunWithResponse(ctx interface{}, projectID interface{}, workflowID interface{}, body interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_CreateWorkflowRunWithResponse_Call {
	return &ClientWithResponsesInterface_CreateWorkflowRunWithResponse_Call{Call: _e.mock.On("CreateWorkflowRunWithResponse",
		append([]interface{}{ctx, projectID, workflowID, body}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_CreateWorkflowRunWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, workflowID uuid.UUID, body api.CreateWorkflowRunInput, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_CreateWorkflowRunWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(api.CreateWorkflowRunInput), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_CreateWorkflowRunWithResponse_Call) Return(_a0 *api.CreateWorkflowRunResponse, _a1 error) *ClientWithResponsesInterface_CreateWorkflowRunWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_CreateWorkflowRunWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, api.CreateWorkflowRunInput, ...api.RequestEditorFn) (*api.CreateWorkflowRunResponse, error)) *ClientWithResponsesInterface_CreateWorkflowRunWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// CreateWorkflowSuitesWithBodyWithResponse provides a mock function with given fields: ctx, projectID, workflowID, contentType, body, reqEditors
func (_m *ClientWithResponsesInterface) CreateWorkflowSuitesWithBodyWithResponse(ctx context.Context, projectID uuid.UUID, workflowID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn) (*api.CreateWorkflowSuitesResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, workflowID, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateWorkflowSuitesWithBodyWithResponse")
	}

	var r0 *api.CreateWorkflowSuitesResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*api.CreateWorkflowSuitesResponse, error)); ok {
		return rf(ctx, projectID, workflowID, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) *api.CreateWorkflowSuitesResponse); ok {
		r0 = rf(ctx, projectID, workflowID, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.CreateWorkflowSuitesResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, workflowID, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_CreateWorkflowSuitesWithBodyWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateWorkflowSuitesWithBodyWithResponse'
type ClientWithResponsesInterface_CreateWorkflowSuitesWithBodyWithResponse_Call struct {
	*mock.Call
}

// CreateWorkflowSuitesWithBodyWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - workflowID uuid.UUID
//   - contentType string
//   - body io.Reader
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) CreateWorkflowSuitesWithBodyWithResponse(ctx interface{}, projectID interface{}, workflowID interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_CreateWorkflowSuitesWithBodyWithResponse_Call {
	return &ClientWithResponsesInterface_CreateWorkflowSuitesWithBodyWithResponse_Call{Call: _e.mock.On("CreateWorkflowSuitesWithBodyWithResponse",
		append([]interface{}{ctx, projectID, workflowID, contentType, body}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_CreateWorkflowSuitesWithBodyWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, workflowID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_CreateWorkflowSuitesWithBodyWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(string), args[4].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_CreateWorkflowSuitesWithBodyWithResponse_Call) Return(_a0 *api.CreateWorkflowSuitesResponse, _a1 error) *ClientWithResponsesInterface_CreateWorkflowSuitesWithBodyWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_CreateWorkflowSuitesWithBodyWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*api.CreateWorkflowSuitesResponse, error)) *ClientWithResponsesInterface_CreateWorkflowSuitesWithBodyWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// CreateWorkflowSuitesWithResponse provides a mock function with given fields: ctx, projectID, workflowID, body, reqEditors
func (_m *ClientWithResponsesInterface) CreateWorkflowSuitesWithResponse(ctx context.Context, projectID uuid.UUID, workflowID uuid.UUID, body api.CreateWorkflowSuitesInput, reqEditors ...api.RequestEditorFn) (*api.CreateWorkflowSuitesResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, workflowID, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateWorkflowSuitesWithResponse")
	}

	var r0 *api.CreateWorkflowSuitesResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, api.CreateWorkflowSuitesInput, ...api.RequestEditorFn) (*api.CreateWorkflowSuitesResponse, error)); ok {
		return rf(ctx, projectID, workflowID, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, api.CreateWorkflowSuitesInput, ...api.RequestEditorFn) *api.CreateWorkflowSuitesResponse); ok {
		r0 = rf(ctx, projectID, workflowID, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.CreateWorkflowSuitesResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, api.CreateWorkflowSuitesInput, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, workflowID, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_CreateWorkflowSuitesWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateWorkflowSuitesWithResponse'
type ClientWithResponsesInterface_CreateWorkflowSuitesWithResponse_Call struct {
	*mock.Call
}

// CreateWorkflowSuitesWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - workflowID uuid.UUID
//   - body api.CreateWorkflowSuitesInput
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) CreateWorkflowSuitesWithResponse(ctx interface{}, projectID interface{}, workflowID interface{}, body interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_CreateWorkflowSuitesWithResponse_Call {
	return &ClientWithResponsesInterface_CreateWorkflowSuitesWithResponse_Call{Call: _e.mock.On("CreateWorkflowSuitesWithResponse",
		append([]interface{}{ctx, projectID, workflowID, body}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_CreateWorkflowSuitesWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, workflowID uuid.UUID, body api.CreateWorkflowSuitesInput, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_CreateWorkflowSuitesWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(api.CreateWorkflowSuitesInput), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_CreateWorkflowSuitesWithResponse_Call) Return(_a0 *api.CreateWorkflowSuitesResponse, _a1 error) *ClientWithResponsesInterface_CreateWorkflowSuitesWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_CreateWorkflowSuitesWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, api.CreateWorkflowSuitesInput, ...api.RequestEditorFn) (*api.CreateWorkflowSuitesResponse, error)) *ClientWithResponsesInterface_CreateWorkflowSuitesWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// CreateWorkflowWithBodyWithResponse provides a mock function with given fields: ctx, projectID, contentType, body, reqEditors
func (_m *ClientWithResponsesInterface) CreateWorkflowWithBodyWithResponse(ctx context.Context, projectID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn) (*api.CreateWorkflowResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateWorkflowWithBodyWithResponse")
	}

	var r0 *api.CreateWorkflowResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*api.CreateWorkflowResponse, error)); ok {
		return rf(ctx, projectID, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) *api.CreateWorkflowResponse); ok {
		r0 = rf(ctx, projectID, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.CreateWorkflowResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_CreateWorkflowWithBodyWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateWorkflowWithBodyWithResponse'
type ClientWithResponsesInterface_CreateWorkflowWithBodyWithResponse_Call struct {
	*mock.Call
}

// CreateWorkflowWithBodyWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - contentType string
//   - body io.Reader
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) CreateWorkflowWithBodyWithResponse(ctx interface{}, projectID interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_CreateWorkflowWithBodyWithResponse_Call {
	return &ClientWithResponsesInterface_CreateWorkflowWithBodyWithResponse_Call{Call: _e.mock.On("CreateWorkflowWithBodyWithResponse",
		append([]interface{}{ctx, projectID, contentType, body}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_CreateWorkflowWithBodyWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_CreateWorkflowWithBodyWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(string), args[3].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_CreateWorkflowWithBodyWithResponse_Call) Return(_a0 *api.CreateWorkflowResponse, _a1 error) *ClientWithResponsesInterface_CreateWorkflowWithBodyWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_CreateWorkflowWithBodyWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*api.CreateWorkflowResponse, error)) *ClientWithResponsesInterface_CreateWorkflowWithBodyWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// CreateWorkflowWithResponse provides a mock function with given fields: ctx, projectID, body, reqEditors
func (_m *ClientWithResponsesInterface) CreateWorkflowWithResponse(ctx context.Context, projectID uuid.UUID, body api.CreateWorkflowInput, reqEditors ...api.RequestEditorFn) (*api.CreateWorkflowResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateWorkflowWithResponse")
	}

	var r0 *api.CreateWorkflowResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, api.CreateWorkflowInput, ...api.RequestEditorFn) (*api.CreateWorkflowResponse, error)); ok {
		return rf(ctx, projectID, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, api.CreateWorkflowInput, ...api.RequestEditorFn) *api.CreateWorkflowResponse); ok {
		r0 = rf(ctx, projectID, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.CreateWorkflowResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, api.CreateWorkflowInput, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_CreateWorkflowWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateWorkflowWithResponse'
type ClientWithResponsesInterface_CreateWorkflowWithResponse_Call struct {
	*mock.Call
}

// CreateWorkflowWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - body api.CreateWorkflowInput
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) CreateWorkflowWithResponse(ctx interface{}, projectID interface{}, body interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_CreateWorkflowWithResponse_Call {
	return &ClientWithResponsesInterface_CreateWorkflowWithResponse_Call{Call: _e.mock.On("CreateWorkflowWithResponse",
		append([]interface{}{ctx, projectID, body}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_CreateWorkflowWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, body api.CreateWorkflowInput, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_CreateWorkflowWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(api.CreateWorkflowInput), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_CreateWorkflowWithResponse_Call) Return(_a0 *api.CreateWorkflowResponse, _a1 error) *ClientWithResponsesInterface_CreateWorkflowWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_CreateWorkflowWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, api.CreateWorkflowInput, ...api.RequestEditorFn) (*api.CreateWorkflowResponse, error)) *ClientWithResponsesInterface_CreateWorkflowWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// DebugExperienceWithBodyWithResponse provides a mock function with given fields: ctx, projectID, experienceID, contentType, body, reqEditors
func (_m *ClientWithResponsesInterface) DebugExperienceWithBodyWithResponse(ctx context.Context, projectID uuid.UUID, experienceID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn) (*api.DebugExperienceResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, experienceID, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DebugExperienceWithBodyWithResponse")
	}

	var r0 *api.DebugExperienceResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*api.DebugExperienceResponse, error)); ok {
		return rf(ctx, projectID, experienceID, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) *api.DebugExperienceResponse); ok {
		r0 = rf(ctx, projectID, experienceID, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.DebugExperienceResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, experienceID, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_DebugExperienceWithBodyWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DebugExperienceWithBodyWithResponse'
type ClientWithResponsesInterface_DebugExperienceWithBodyWithResponse_Call struct {
	*mock.Call
}

// DebugExperienceWithBodyWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - experienceID uuid.UUID
//   - contentType string
//   - body io.Reader
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) DebugExperienceWithBodyWithResponse(ctx interface{}, projectID interface{}, experienceID interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_DebugExperienceWithBodyWithResponse_Call {
	return &ClientWithResponsesInterface_DebugExperienceWithBodyWithResponse_Call{Call: _e.mock.On("DebugExperienceWithBodyWithResponse",
		append([]interface{}{ctx, projectID, experienceID, contentType, body}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_DebugExperienceWithBodyWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, experienceID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_DebugExperienceWithBodyWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(string), args[4].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_DebugExperienceWithBodyWithResponse_Call) Return(_a0 *api.DebugExperienceResponse, _a1 error) *ClientWithResponsesInterface_DebugExperienceWithBodyWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_DebugExperienceWithBodyWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*api.DebugExperienceResponse, error)) *ClientWithResponsesInterface_DebugExperienceWithBodyWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// DebugExperienceWithResponse provides a mock function with given fields: ctx, projectID, experienceID, body, reqEditors
func (_m *ClientWithResponsesInterface) DebugExperienceWithResponse(ctx context.Context, projectID uuid.UUID, experienceID uuid.UUID, body api.DebugExperienceInput, reqEditors ...api.RequestEditorFn) (*api.DebugExperienceResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, experienceID, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DebugExperienceWithResponse")
	}

	var r0 *api.DebugExperienceResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, api.DebugExperienceInput, ...api.RequestEditorFn) (*api.DebugExperienceResponse, error)); ok {
		return rf(ctx, projectID, experienceID, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, api.DebugExperienceInput, ...api.RequestEditorFn) *api.DebugExperienceResponse); ok {
		r0 = rf(ctx, projectID, experienceID, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.DebugExperienceResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, api.DebugExperienceInput, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, experienceID, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_DebugExperienceWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DebugExperienceWithResponse'
type ClientWithResponsesInterface_DebugExperienceWithResponse_Call struct {
	*mock.Call
}

// DebugExperienceWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - experienceID uuid.UUID
//   - body api.DebugExperienceInput
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) DebugExperienceWithResponse(ctx interface{}, projectID interface{}, experienceID interface{}, body interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_DebugExperienceWithResponse_Call {
	return &ClientWithResponsesInterface_DebugExperienceWithResponse_Call{Call: _e.mock.On("DebugExperienceWithResponse",
		append([]interface{}{ctx, projectID, experienceID, body}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_DebugExperienceWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, experienceID uuid.UUID, body api.DebugExperienceInput, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_DebugExperienceWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(api.DebugExperienceInput), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_DebugExperienceWithResponse_Call) Return(_a0 *api.DebugExperienceResponse, _a1 error) *ClientWithResponsesInterface_DebugExperienceWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_DebugExperienceWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, api.DebugExperienceInput, ...api.RequestEditorFn) (*api.DebugExperienceResponse, error)) *ClientWithResponsesInterface_DebugExperienceWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteBatchLogWithResponse provides a mock function with given fields: ctx, projectID, batchID, logID, reqEditors
func (_m *ClientWithResponsesInterface) DeleteBatchLogWithResponse(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, logID uuid.UUID, reqEditors ...api.RequestEditorFn) (*api.DeleteBatchLogResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, batchID, logID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteBatchLogWithResponse")
	}

	var r0 *api.DeleteBatchLogResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*api.DeleteBatchLogResponse, error)); ok {
		return rf(ctx, projectID, batchID, logID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) *api.DeleteBatchLogResponse); ok {
		r0 = rf(ctx, projectID, batchID, logID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.DeleteBatchLogResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, batchID, logID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_DeleteBatchLogWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteBatchLogWithResponse'
type ClientWithResponsesInterface_DeleteBatchLogWithResponse_Call struct {
	*mock.Call
}

// DeleteBatchLogWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - batchID uuid.UUID
//   - logID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) DeleteBatchLogWithResponse(ctx interface{}, projectID interface{}, batchID interface{}, logID interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_DeleteBatchLogWithResponse_Call {
	return &ClientWithResponsesInterface_DeleteBatchLogWithResponse_Call{Call: _e.mock.On("DeleteBatchLogWithResponse",
		append([]interface{}{ctx, projectID, batchID, logID}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_DeleteBatchLogWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, logID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_DeleteBatchLogWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_DeleteBatchLogWithResponse_Call) Return(_a0 *api.DeleteBatchLogResponse, _a1 error) *ClientWithResponsesInterface_DeleteBatchLogWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_DeleteBatchLogWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*api.DeleteBatchLogResponse, error)) *ClientWithResponsesInterface_DeleteBatchLogWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteBranchForProjectWithResponse provides a mock function with given fields: ctx, projectID, branchID, reqEditors
func (_m *ClientWithResponsesInterface) DeleteBranchForProjectWithResponse(ctx context.Context, projectID uuid.UUID, branchID uuid.UUID, reqEditors ...api.RequestEditorFn) (*api.DeleteBranchForProjectResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, branchID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteBranchForProjectWithResponse")
	}

	var r0 *api.DeleteBranchForProjectResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*api.DeleteBranchForProjectResponse, error)); ok {
		return rf(ctx, projectID, branchID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) *api.DeleteBranchForProjectResponse); ok {
		r0 = rf(ctx, projectID, branchID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.DeleteBranchForProjectResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, branchID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_DeleteBranchForProjectWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteBranchForProjectWithResponse'
type ClientWithResponsesInterface_DeleteBranchForProjectWithResponse_Call struct {
	*mock.Call
}

// DeleteBranchForProjectWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - branchID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) DeleteBranchForProjectWithResponse(ctx interface{}, projectID interface{}, branchID interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_DeleteBranchForProjectWithResponse_Call {
	return &ClientWithResponsesInterface_DeleteBranchForProjectWithResponse_Call{Call: _e.mock.On("DeleteBranchForProjectWithResponse",
		append([]interface{}{ctx, projectID, branchID}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_DeleteBranchForProjectWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, branchID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_DeleteBranchForProjectWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_DeleteBranchForProjectWithResponse_Call) Return(_a0 *api.DeleteBranchForProjectResponse, _a1 error) *ClientWithResponsesInterface_DeleteBranchForProjectWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_DeleteBranchForProjectWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*api.DeleteBranchForProjectResponse, error)) *ClientWithResponsesInterface_DeleteBranchForProjectWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteBuildForBranchWithResponse provides a mock function with given fields: ctx, projectID, branchID, buildID, reqEditors
func (_m *ClientWithResponsesInterface) DeleteBuildForBranchWithResponse(ctx context.Context, projectID uuid.UUID, branchID uuid.UUID, buildID uuid.UUID, reqEditors ...api.RequestEditorFn) (*api.DeleteBuildForBranchResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, branchID, buildID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteBuildForBranchWithResponse")
	}

	var r0 *api.DeleteBuildForBranchResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*api.DeleteBuildForBranchResponse, error)); ok {
		return rf(ctx, projectID, branchID, buildID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) *api.DeleteBuildForBranchResponse); ok {
		r0 = rf(ctx, projectID, branchID, buildID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.DeleteBuildForBranchResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, branchID, buildID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_DeleteBuildForBranchWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteBuildForBranchWithResponse'
type ClientWithResponsesInterface_DeleteBuildForBranchWithResponse_Call struct {
	*mock.Call
}

// DeleteBuildForBranchWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - branchID uuid.UUID
//   - buildID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) DeleteBuildForBranchWithResponse(ctx interface{}, projectID interface{}, branchID interface{}, buildID interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_DeleteBuildForBranchWithResponse_Call {
	return &ClientWithResponsesInterface_DeleteBuildForBranchWithResponse_Call{Call: _e.mock.On("DeleteBuildForBranchWithResponse",
		append([]interface{}{ctx, projectID, branchID, buildID}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_DeleteBuildForBranchWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, branchID uuid.UUID, buildID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_DeleteBuildForBranchWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_DeleteBuildForBranchWithResponse_Call) Return(_a0 *api.DeleteBuildForBranchResponse, _a1 error) *ClientWithResponsesInterface_DeleteBuildForBranchWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_DeleteBuildForBranchWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*api.DeleteBuildForBranchResponse, error)) *ClientWithResponsesInterface_DeleteBuildForBranchWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteExperienceTagWithResponse provides a mock function with given fields: ctx, projectID, experienceTagID, reqEditors
func (_m *ClientWithResponsesInterface) DeleteExperienceTagWithResponse(ctx context.Context, projectID uuid.UUID, experienceTagID uuid.UUID, reqEditors ...api.RequestEditorFn) (*api.DeleteExperienceTagResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, experienceTagID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteExperienceTagWithResponse")
	}

	var r0 *api.DeleteExperienceTagResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*api.DeleteExperienceTagResponse, error)); ok {
		return rf(ctx, projectID, experienceTagID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) *api.DeleteExperienceTagResponse); ok {
		r0 = rf(ctx, projectID, experienceTagID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.DeleteExperienceTagResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, experienceTagID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_DeleteExperienceTagWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteExperienceTagWithResponse'
type ClientWithResponsesInterface_DeleteExperienceTagWithResponse_Call struct {
	*mock.Call
}

// DeleteExperienceTagWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - experienceTagID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) DeleteExperienceTagWithResponse(ctx interface{}, projectID interface{}, experienceTagID interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_DeleteExperienceTagWithResponse_Call {
	return &ClientWithResponsesInterface_DeleteExperienceTagWithResponse_Call{Call: _e.mock.On("DeleteExperienceTagWithResponse",
		append([]interface{}{ctx, projectID, experienceTagID}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_DeleteExperienceTagWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, experienceTagID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_DeleteExperienceTagWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_DeleteExperienceTagWithResponse_Call) Return(_a0 *api.DeleteExperienceTagResponse, _a1 error) *ClientWithResponsesInterface_DeleteExperienceTagWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_DeleteExperienceTagWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*api.DeleteExperienceTagResponse, error)) *ClientWithResponsesInterface_DeleteExperienceTagWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteJobLogWithResponse provides a mock function with given fields: ctx, projectID, batchID, jobID, logID, reqEditors
func (_m *ClientWithResponsesInterface) DeleteJobLogWithResponse(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, jobID uuid.UUID, logID uuid.UUID, reqEditors ...api.RequestEditorFn) (*api.DeleteJobLogResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, batchID, jobID, logID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteJobLogWithResponse")
	}

	var r0 *api.DeleteJobLogResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*api.DeleteJobLogResponse, error)); ok {
		return rf(ctx, projectID, batchID, jobID, logID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) *api.DeleteJobLogResponse); ok {
		r0 = rf(ctx, projectID, batchID, jobID, logID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.DeleteJobLogResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, batchID, jobID, logID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_DeleteJobLogWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteJobLogWithResponse'
type ClientWithResponsesInterface_DeleteJobLogWithResponse_Call struct {
	*mock.Call
}

// DeleteJobLogWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - batchID uuid.UUID
//   - jobID uuid.UUID
//   - logID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) DeleteJobLogWithResponse(ctx interface{}, projectID interface{}, batchID interface{}, jobID interface{}, logID interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_DeleteJobLogWithResponse_Call {
	return &ClientWithResponsesInterface_DeleteJobLogWithResponse_Call{Call: _e.mock.On("DeleteJobLogWithResponse",
		append([]interface{}{ctx, projectID, batchID, jobID, logID}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_DeleteJobLogWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, jobID uuid.UUID, logID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_DeleteJobLogWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(uuid.UUID), args[4].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_DeleteJobLogWithResponse_Call) Return(_a0 *api.DeleteJobLogResponse, _a1 error) *ClientWithResponsesInterface_DeleteJobLogWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_DeleteJobLogWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*api.DeleteJobLogResponse, error)) *ClientWithResponsesInterface_DeleteJobLogWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteWorkflowSuitesWithBodyWithResponse provides a mock function with given fields: ctx, projectID, workflowID, contentType, body, reqEditors
func (_m *ClientWithResponsesInterface) DeleteWorkflowSuitesWithBodyWithResponse(ctx context.Context, projectID uuid.UUID, workflowID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn) (*api.DeleteWorkflowSuitesResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, workflowID, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteWorkflowSuitesWithBodyWithResponse")
	}

	var r0 *api.DeleteWorkflowSuitesResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*api.DeleteWorkflowSuitesResponse, error)); ok {
		return rf(ctx, projectID, workflowID, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) *api.DeleteWorkflowSuitesResponse); ok {
		r0 = rf(ctx, projectID, workflowID, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.DeleteWorkflowSuitesResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, workflowID, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_DeleteWorkflowSuitesWithBodyWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteWorkflowSuitesWithBodyWithResponse'
type ClientWithResponsesInterface_DeleteWorkflowSuitesWithBodyWithResponse_Call struct {
	*mock.Call
}

// DeleteWorkflowSuitesWithBodyWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - workflowID uuid.UUID
//   - contentType string
//   - body io.Reader
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) DeleteWorkflowSuitesWithBodyWithResponse(ctx interface{}, projectID interface{}, workflowID interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_DeleteWorkflowSuitesWithBodyWithResponse_Call {
	return &ClientWithResponsesInterface_DeleteWorkflowSuitesWithBodyWithResponse_Call{Call: _e.mock.On("DeleteWorkflowSuitesWithBodyWithResponse",
		append([]interface{}{ctx, projectID, workflowID, contentType, body}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_DeleteWorkflowSuitesWithBodyWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, workflowID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_DeleteWorkflowSuitesWithBodyWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(string), args[4].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_DeleteWorkflowSuitesWithBodyWithResponse_Call) Return(_a0 *api.DeleteWorkflowSuitesResponse, _a1 error) *ClientWithResponsesInterface_DeleteWorkflowSuitesWithBodyWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_DeleteWorkflowSuitesWithBodyWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*api.DeleteWorkflowSuitesResponse, error)) *ClientWithResponsesInterface_DeleteWorkflowSuitesWithBodyWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteWorkflowSuitesWithResponse provides a mock function with given fields: ctx, projectID, workflowID, body, reqEditors
func (_m *ClientWithResponsesInterface) DeleteWorkflowSuitesWithResponse(ctx context.Context, projectID uuid.UUID, workflowID uuid.UUID, body api.DeleteWorkflowSuitesInput, reqEditors ...api.RequestEditorFn) (*api.DeleteWorkflowSuitesResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, workflowID, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteWorkflowSuitesWithResponse")
	}

	var r0 *api.DeleteWorkflowSuitesResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, api.DeleteWorkflowSuitesInput, ...api.RequestEditorFn) (*api.DeleteWorkflowSuitesResponse, error)); ok {
		return rf(ctx, projectID, workflowID, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, api.DeleteWorkflowSuitesInput, ...api.RequestEditorFn) *api.DeleteWorkflowSuitesResponse); ok {
		r0 = rf(ctx, projectID, workflowID, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.DeleteWorkflowSuitesResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, api.DeleteWorkflowSuitesInput, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, workflowID, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_DeleteWorkflowSuitesWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteWorkflowSuitesWithResponse'
type ClientWithResponsesInterface_DeleteWorkflowSuitesWithResponse_Call struct {
	*mock.Call
}

// DeleteWorkflowSuitesWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - workflowID uuid.UUID
//   - body api.DeleteWorkflowSuitesInput
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) DeleteWorkflowSuitesWithResponse(ctx interface{}, projectID interface{}, workflowID interface{}, body interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_DeleteWorkflowSuitesWithResponse_Call {
	return &ClientWithResponsesInterface_DeleteWorkflowSuitesWithResponse_Call{Call: _e.mock.On("DeleteWorkflowSuitesWithResponse",
		append([]interface{}{ctx, projectID, workflowID, body}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_DeleteWorkflowSuitesWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, workflowID uuid.UUID, body api.DeleteWorkflowSuitesInput, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_DeleteWorkflowSuitesWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(api.DeleteWorkflowSuitesInput), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_DeleteWorkflowSuitesWithResponse_Call) Return(_a0 *api.DeleteWorkflowSuitesResponse, _a1 error) *ClientWithResponsesInterface_DeleteWorkflowSuitesWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_DeleteWorkflowSuitesWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, api.DeleteWorkflowSuitesInput, ...api.RequestEditorFn) (*api.DeleteWorkflowSuitesResponse, error)) *ClientWithResponsesInterface_DeleteWorkflowSuitesWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// GetBatchLogWithResponse provides a mock function with given fields: ctx, projectID, batchID, logID, reqEditors
func (_m *ClientWithResponsesInterface) GetBatchLogWithResponse(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, logID uuid.UUID, reqEditors ...api.RequestEditorFn) (*api.GetBatchLogResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, batchID, logID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetBatchLogWithResponse")
	}

	var r0 *api.GetBatchLogResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*api.GetBatchLogResponse, error)); ok {
		return rf(ctx, projectID, batchID, logID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) *api.GetBatchLogResponse); ok {
		r0 = rf(ctx, projectID, batchID, logID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.GetBatchLogResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, batchID, logID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_GetBatchLogWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBatchLogWithResponse'
type ClientWithResponsesInterface_GetBatchLogWithResponse_Call struct {
	*mock.Call
}

// GetBatchLogWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - batchID uuid.UUID
//   - logID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) GetBatchLogWithResponse(ctx interface{}, projectID interface{}, batchID interface{}, logID interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_GetBatchLogWithResponse_Call {
	return &ClientWithResponsesInterface_GetBatchLogWithResponse_Call{Call: _e.mock.On("GetBatchLogWithResponse",
		append([]interface{}{ctx, projectID, batchID, logID}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_GetBatchLogWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, logID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_GetBatchLogWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_GetBatchLogWithResponse_Call) Return(_a0 *api.GetBatchLogResponse, _a1 error) *ClientWithResponsesInterface_GetBatchLogWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_GetBatchLogWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*api.GetBatchLogResponse, error)) *ClientWithResponsesInterface_GetBatchLogWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// GetBatchSuggestionsWithResponse provides a mock function with given fields: ctx, projectID, batchID, reqEditors
func (_m *ClientWithResponsesInterface) GetBatchSuggestionsWithResponse(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, reqEditors ...api.RequestEditorFn) (*api.GetBatchSuggestionsResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, batchID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetBatchSuggestionsWithResponse")
	}

	var r0 *api.GetBatchSuggestionsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*api.GetBatchSuggestionsResponse, error)); ok {
		return rf(ctx, projectID, batchID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) *api.GetBatchSuggestionsResponse); ok {
		r0 = rf(ctx, projectID, batchID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.GetBatchSuggestionsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, batchID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_GetBatchSuggestionsWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBatchSuggestionsWithResponse'
type ClientWithResponsesInterface_GetBatchSuggestionsWithResponse_Call struct {
	*mock.Call
}

// GetBatchSuggestionsWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - batchID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) GetBatchSuggestionsWithResponse(ctx interface{}, projectID interface{}, batchID interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_GetBatchSuggestionsWithResponse_Call {
	return &ClientWithResponsesInterface_GetBatchSuggestionsWithResponse_Call{Call: _e.mock.On("GetBatchSuggestionsWithResponse",
		append([]interface{}{ctx, projectID, batchID}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_GetBatchSuggestionsWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_GetBatchSuggestionsWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_GetBatchSuggestionsWithResponse_Call) Return(_a0 *api.GetBatchSuggestionsResponse, _a1 error) *ClientWithResponsesInterface_GetBatchSuggestionsWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_GetBatchSuggestionsWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*api.GetBatchSuggestionsResponse, error)) *ClientWithResponsesInterface_GetBatchSuggestionsWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// GetBatchWithResponse provides a mock function with given fields: ctx, projectID, batchID, reqEditors
func (_m *ClientWithResponsesInterface) GetBatchWithResponse(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, reqEditors ...api.RequestEditorFn) (*api.GetBatchResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, batchID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetBatchWithResponse")
	}

	var r0 *api.GetBatchResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*api.GetBatchResponse, error)); ok {
		return rf(ctx, projectID, batchID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) *api.GetBatchResponse); ok {
		r0 = rf(ctx, projectID, batchID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.GetBatchResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, batchID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_GetBatchWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBatchWithResponse'
type ClientWithResponsesInterface_GetBatchWithResponse_Call struct {
	*mock.Call
}

// GetBatchWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - batchID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) GetBatchWithResponse(ctx interface{}, projectID interface{}, batchID interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_GetBatchWithResponse_Call {
	return &ClientWithResponsesInterface_GetBatchWithResponse_Call{Call: _e.mock.On("GetBatchWithResponse",
		append([]interface{}{ctx, projectID, batchID}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_GetBatchWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_GetBatchWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_GetBatchWithResponse_Call) Return(_a0 *api.GetBatchResponse, _a1 error) *ClientWithResponsesInterface_GetBatchWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_GetBatchWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*api.GetBatchResponse, error)) *ClientWithResponsesInterface_GetBatchWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// GetBranchForProjectWithResponse provides a mock function with given fields: ctx, projectID, branchID, reqEditors
func (_m *ClientWithResponsesInterface) GetBranchForProjectWithResponse(ctx context.Context, projectID uuid.UUID, branchID uuid.UUID, reqEditors ...api.RequestEditorFn) (*api.GetBranchForProjectResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, branchID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetBranchForProjectWithResponse")
	}

	var r0 *api.GetBranchForProjectResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*api.GetBranchForProjectResponse, error)); ok {
		return rf(ctx, projectID, branchID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) *api.GetBranchForProjectResponse); ok {
		r0 = rf(ctx, projectID, branchID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.GetBranchForProjectResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, branchID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_GetBranchForProjectWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBranchForProjectWithResponse'
type ClientWithResponsesInterface_GetBranchForProjectWithResponse_Call struct {
	*mock.Call
}

// GetBranchForProjectWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - branchID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) GetBranchForProjectWithResponse(ctx interface{}, projectID interface{}, branchID interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_GetBranchForProjectWithResponse_Call {
	return &ClientWithResponsesInterface_GetBranchForProjectWithResponse_Call{Call: _e.mock.On("GetBranchForProjectWithResponse",
		append([]interface{}{ctx, projectID, branchID}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_GetBranchForProjectWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, branchID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_GetBranchForProjectWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_GetBranchForProjectWithResponse_Call) Return(_a0 *api.GetBranchForProjectResponse, _a1 error) *ClientWithResponsesInterface_GetBranchForProjectWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_GetBranchForProjectWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*api.GetBranchForProjectResponse, error)) *ClientWithResponsesInterface_GetBranchForProjectWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// GetBuildForBranchWithResponse provides a mock function with given fields: ctx, projectID, branchID, buildID, reqEditors
func (_m *ClientWithResponsesInterface) GetBuildForBranchWithResponse(ctx context.Context, projectID uuid.UUID, branchID uuid.UUID, buildID uuid.UUID, reqEditors ...api.RequestEditorFn) (*api.GetBuildForBranchResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, branchID, buildID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetBuildForBranchWithResponse")
	}

	var r0 *api.GetBuildForBranchResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*api.GetBuildForBranchResponse, error)); ok {
		return rf(ctx, projectID, branchID, buildID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) *api.GetBuildForBranchResponse); ok {
		r0 = rf(ctx, projectID, branchID, buildID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.GetBuildForBranchResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, branchID, buildID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_GetBuildForBranchWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBuildForBranchWithResponse'
type ClientWithResponsesInterface_GetBuildForBranchWithResponse_Call struct {
	*mock.Call
}

// GetBuildForBranchWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - branchID uuid.UUID
//   - buildID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) GetBuildForBranchWithResponse(ctx interface{}, projectID interface{}, branchID interface{}, buildID interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_GetBuildForBranchWithResponse_Call {
	return &ClientWithResponsesInterface_GetBuildForBranchWithResponse_Call{Call: _e.mock.On("GetBuildForBranchWithResponse",
		append([]interface{}{ctx, projectID, branchID, buildID}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_GetBuildForBranchWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, branchID uuid.UUID, buildID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_GetBuildForBranchWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_GetBuildForBranchWithResponse_Call) Return(_a0 *api.GetBuildForBranchResponse, _a1 error) *ClientWithResponsesInterface_GetBuildForBranchWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_GetBuildForBranchWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*api.GetBuildForBranchResponse, error)) *ClientWithResponsesInterface_GetBuildForBranchWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// GetBuildForSystemWithResponse provides a mock function with given fields: ctx, projectID, systemID, buildID, reqEditors
func (_m *ClientWithResponsesInterface) GetBuildForSystemWithResponse(ctx context.Context, projectID uuid.UUID, systemID uuid.UUID, buildID uuid.UUID, reqEditors ...api.RequestEditorFn) (*api.GetBuildForSystemResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, systemID, buildID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetBuildForSystemWithResponse")
	}

	var r0 *api.GetBuildForSystemResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*api.GetBuildForSystemResponse, error)); ok {
		return rf(ctx, projectID, systemID, buildID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) *api.GetBuildForSystemResponse); ok {
		r0 = rf(ctx, projectID, systemID, buildID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.GetBuildForSystemResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, systemID, buildID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_GetBuildForSystemWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBuildForSystemWithResponse'
type ClientWithResponsesInterface_GetBuildForSystemWithResponse_Call struct {
	*mock.Call
}

// GetBuildForSystemWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - systemID uuid.UUID
//   - buildID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) GetBuildForSystemWithResponse(ctx interface{}, projectID interface{}, systemID interface{}, buildID interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_GetBuildForSystemWithResponse_Call {
	return &ClientWithResponsesInterface_GetBuildForSystemWithResponse_Call{Call: _e.mock.On("GetBuildForSystemWithResponse",
		append([]interface{}{ctx, projectID, systemID, buildID}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_GetBuildForSystemWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, systemID uuid.UUID, buildID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_GetBuildForSystemWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_GetBuildForSystemWithResponse_Call) Return(_a0 *api.GetBuildForSystemResponse, _a1 error) *ClientWithResponsesInterface_GetBuildForSystemWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_GetBuildForSystemWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*api.GetBuildForSystemResponse, error)) *ClientWithResponsesInterface_GetBuildForSystemWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// GetBuildWithResponse provides a mock function with given fields: ctx, projectID, buildID, reqEditors
func (_m *ClientWithResponsesInterface) GetBuildWithResponse(ctx context.Context, projectID uuid.UUID, buildID uuid.UUID, reqEditors ...api.RequestEditorFn) (*api.GetBuildResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, buildID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetBuildWithResponse")
	}

	var r0 *api.GetBuildResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*api.GetBuildResponse, error)); ok {
		return rf(ctx, projectID, buildID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) *api.GetBuildResponse); ok {
		r0 = rf(ctx, projectID, buildID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.GetBuildResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, buildID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_GetBuildWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBuildWithResponse'
type ClientWithResponsesInterface_GetBuildWithResponse_Call struct {
	*mock.Call
}

// GetBuildWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - buildID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) GetBuildWithResponse(ctx interface{}, projectID interface{}, buildID interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_GetBuildWithResponse_Call {
	return &ClientWithResponsesInterface_GetBuildWithResponse_Call{Call: _e.mock.On("GetBuildWithResponse",
		append([]interface{}{ctx, projectID, buildID}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_GetBuildWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, buildID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_GetBuildWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_GetBuildWithResponse_Call) Return(_a0 *api.GetBuildResponse, _a1 error) *ClientWithResponsesInterface_GetBuildWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_GetBuildWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*api.GetBuildResponse, error)) *ClientWithResponsesInterface_GetBuildWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// GetEventForJobWithResponse provides a mock function with given fields: ctx, projectID, batchID, jobID, eventID, reqEditors
func (_m *ClientWithResponsesInterface) GetEventForJobWithResponse(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, jobID uuid.UUID, eventID uuid.UUID, reqEditors ...api.RequestEditorFn) (*api.GetEventForJobResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, batchID, jobID, eventID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetEventForJobWithResponse")
	}

	var r0 *api.GetEventForJobResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*api.GetEventForJobResponse, error)); ok {
		return rf(ctx, projectID, batchID, jobID, eventID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) *api.GetEventForJobResponse); ok {
		r0 = rf(ctx, projectID, batchID, jobID, eventID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.GetEventForJobResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, batchID, jobID, eventID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_GetEventForJobWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetEventForJobWithResponse'
type ClientWithResponsesInterface_GetEventForJobWithResponse_Call struct {
	*mock.Call
}

// GetEventForJobWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - batchID uuid.UUID
//   - jobID uuid.UUID
//   - eventID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) GetEventForJobWithResponse(ctx interface{}, projectID interface{}, batchID interface{}, jobID interface{}, eventID interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_GetEventForJobWithResponse_Call {
	return &ClientWithResponsesInterface_GetEventForJobWithResponse_Call{Call: _e.mock.On("GetEventForJobWithResponse",
		append([]interface{}{ctx, projectID, batchID, jobID, eventID}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_GetEventForJobWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, jobID uuid.UUID, eventID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_GetEventForJobWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(uuid.UUID), args[4].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_GetEventForJobWithResponse_Call) Return(_a0 *api.GetEventForJobResponse, _a1 error) *ClientWithResponsesInterface_GetEventForJobWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_GetEventForJobWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*api.GetEventForJobResponse, error)) *ClientWithResponsesInterface_GetEventForJobWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// GetExperienceTagWithResponse provides a mock function with given fields: ctx, projectID, experienceTagID, reqEditors
func (_m *ClientWithResponsesInterface) GetExperienceTagWithResponse(ctx context.Context, projectID uuid.UUID, experienceTagID uuid.UUID, reqEditors ...api.RequestEditorFn) (*api.GetExperienceTagResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, experienceTagID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetExperienceTagWithResponse")
	}

	var r0 *api.GetExperienceTagResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*api.GetExperienceTagResponse, error)); ok {
		return rf(ctx, projectID, experienceTagID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) *api.GetExperienceTagResponse); ok {
		r0 = rf(ctx, projectID, experienceTagID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.GetExperienceTagResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, experienceTagID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_GetExperienceTagWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetExperienceTagWithResponse'
type ClientWithResponsesInterface_GetExperienceTagWithResponse_Call struct {
	*mock.Call
}

// GetExperienceTagWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - experienceTagID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) GetExperienceTagWithResponse(ctx interface{}, projectID interface{}, experienceTagID interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_GetExperienceTagWithResponse_Call {
	return &ClientWithResponsesInterface_GetExperienceTagWithResponse_Call{Call: _e.mock.On("GetExperienceTagWithResponse",
		append([]interface{}{ctx, projectID, experienceTagID}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_GetExperienceTagWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, experienceTagID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_GetExperienceTagWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_GetExperienceTagWithResponse_Call) Return(_a0 *api.GetExperienceTagResponse, _a1 error) *ClientWithResponsesInterface_GetExperienceTagWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_GetExperienceTagWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*api.GetExperienceTagResponse, error)) *ClientWithResponsesInterface_GetExperienceTagWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// GetExperienceWithResponse provides a mock function with given fields: ctx, projectID, experienceID, reqEditors
func (_m *ClientWithResponsesInterface) GetExperienceWithResponse(ctx context.Context, projectID uuid.UUID, experienceID uuid.UUID, reqEditors ...api.RequestEditorFn) (*api.GetExperienceResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, experienceID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetExperienceWithResponse")
	}

	var r0 *api.GetExperienceResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*api.GetExperienceResponse, error)); ok {
		return rf(ctx, projectID, experienceID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) *api.GetExperienceResponse); ok {
		r0 = rf(ctx, projectID, experienceID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.GetExperienceResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, experienceID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_GetExperienceWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetExperienceWithResponse'
type ClientWithResponsesInterface_GetExperienceWithResponse_Call struct {
	*mock.Call
}

// GetExperienceWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - experienceID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) GetExperienceWithResponse(ctx interface{}, projectID interface{}, experienceID interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_GetExperienceWithResponse_Call {
	return &ClientWithResponsesInterface_GetExperienceWithResponse_Call{Call: _e.mock.On("GetExperienceWithResponse",
		append([]interface{}{ctx, projectID, experienceID}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_GetExperienceWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, experienceID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_GetExperienceWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_GetExperienceWithResponse_Call) Return(_a0 *api.GetExperienceResponse, _a1 error) *ClientWithResponsesInterface_GetExperienceWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_GetExperienceWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*api.GetExperienceResponse, error)) *ClientWithResponsesInterface_GetExperienceWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// GetJobLogWithResponse provides a mock function with given fields: ctx, projectID, batchID, jobID, logID, reqEditors
func (_m *ClientWithResponsesInterface) GetJobLogWithResponse(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, jobID uuid.UUID, logID uuid.UUID, reqEditors ...api.RequestEditorFn) (*api.GetJobLogResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, batchID, jobID, logID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetJobLogWithResponse")
	}

	var r0 *api.GetJobLogResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*api.GetJobLogResponse, error)); ok {
		return rf(ctx, projectID, batchID, jobID, logID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) *api.GetJobLogResponse); ok {
		r0 = rf(ctx, projectID, batchID, jobID, logID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.GetJobLogResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, batchID, jobID, logID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_GetJobLogWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetJobLogWithResponse'
type ClientWithResponsesInterface_GetJobLogWithResponse_Call struct {
	*mock.Call
}

// GetJobLogWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - batchID uuid.UUID
//   - jobID uuid.UUID
//   - logID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) GetJobLogWithResponse(ctx interface{}, projectID interface{}, batchID interface{}, jobID interface{}, logID interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_GetJobLogWithResponse_Call {
	return &ClientWithResponsesInterface_GetJobLogWithResponse_Call{Call: _e.mock.On("GetJobLogWithResponse",
		append([]interface{}{ctx, projectID, batchID, jobID, logID}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_GetJobLogWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, jobID uuid.UUID, logID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_GetJobLogWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(uuid.UUID), args[4].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_GetJobLogWithResponse_Call) Return(_a0 *api.GetJobLogResponse, _a1 error) *ClientWithResponsesInterface_GetJobLogWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_GetJobLogWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*api.GetJobLogResponse, error)) *ClientWithResponsesInterface_GetJobLogWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// GetJobWithResponse provides a mock function with given fields: ctx, projectID, batchID, jobID, reqEditors
func (_m *ClientWithResponsesInterface) GetJobWithResponse(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, jobID uuid.UUID, reqEditors ...api.RequestEditorFn) (*api.GetJobResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, batchID, jobID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetJobWithResponse")
	}

	var r0 *api.GetJobResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*api.GetJobResponse, error)); ok {
		return rf(ctx, projectID, batchID, jobID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) *api.GetJobResponse); ok {
		r0 = rf(ctx, projectID, batchID, jobID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.GetJobResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, batchID, jobID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_GetJobWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetJobWithResponse'
type ClientWithResponsesInterface_GetJobWithResponse_Call struct {
	*mock.Call
}

// GetJobWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - batchID uuid.UUID
//   - jobID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) GetJobWithResponse(ctx interface{}, projectID interface{}, batchID interface{}, jobID interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_GetJobWithResponse_Call {
	return &ClientWithResponsesInterface_GetJobWithResponse_Call{Call: _e.mock.On("GetJobWithResponse",
		append([]interface{}{ctx, projectID, batchID, jobID}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_GetJobWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, jobID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_GetJobWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_GetJobWithResponse_Call) Return(_a0 *api.GetJobResponse, _a1 error) *ClientWithResponsesInterface_GetJobWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_GetJobWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*api.GetJobResponse, error)) *ClientWithResponsesInterface_GetJobWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// GetMetricsBuildWithResponse provides a mock function with given fields: ctx, projectID, metricsBuildID, reqEditors
func (_m *ClientWithResponsesInterface) GetMetricsBuildWithResponse(ctx context.Context, projectID uuid.UUID, metricsBuildID uuid.UUID, reqEditors ...api.RequestEditorFn) (*api.GetMetricsBuildResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, metricsBuildID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetMetricsBuildWithResponse")
	}

	var r0 *api.GetMetricsBuildResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*api.GetMetricsBuildResponse, error)); ok {
		return rf(ctx, projectID, metricsBuildID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) *api.GetMetricsBuildResponse); ok {
		r0 = rf(ctx, projectID, metricsBuildID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.GetMetricsBuildResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, metricsBuildID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_GetMetricsBuildWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetMetricsBuildWithResponse'
type ClientWithResponsesInterface_GetMetricsBuildWithResponse_Call struct {
	*mock.Call
}

// GetMetricsBuildWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - metricsBuildID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) GetMetricsBuildWithResponse(ctx interface{}, projectID interface{}, metricsBuildID interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_GetMetricsBuildWithResponse_Call {
	return &ClientWithResponsesInterface_GetMetricsBuildWithResponse_Call{Call: _e.mock.On("GetMetricsBuildWithResponse",
		append([]interface{}{ctx, projectID, metricsBuildID}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_GetMetricsBuildWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, metricsBuildID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_GetMetricsBuildWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_GetMetricsBuildWithResponse_Call) Return(_a0 *api.GetMetricsBuildResponse, _a1 error) *ClientWithResponsesInterface_GetMetricsBuildWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_GetMetricsBuildWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*api.GetMetricsBuildResponse, error)) *ClientWithResponsesInterface_GetMetricsBuildWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// GetParameterSweepWithResponse provides a mock function with given fields: ctx, projectID, sweepID, reqEditors
func (_m *ClientWithResponsesInterface) GetParameterSweepWithResponse(ctx context.Context, projectID uuid.UUID, sweepID uuid.UUID, reqEditors ...api.RequestEditorFn) (*api.GetParameterSweepResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, sweepID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetParameterSweepWithResponse")
	}

	var r0 *api.GetParameterSweepResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*api.GetParameterSweepResponse, error)); ok {
		return rf(ctx, projectID, sweepID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) *api.GetParameterSweepResponse); ok {
		r0 = rf(ctx, projectID, sweepID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.GetParameterSweepResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, sweepID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_GetParameterSweepWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetParameterSweepWithResponse'
type ClientWithResponsesInterface_GetParameterSweepWithResponse_Call struct {
	*mock.Call
}

// GetParameterSweepWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - sweepID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) GetParameterSweepWithResponse(ctx interface{}, projectID interface{}, sweepID interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_GetParameterSweepWithResponse_Call {
	return &ClientWithResponsesInterface_GetParameterSweepWithResponse_Call{Call: _e.mock.On("GetParameterSweepWithResponse",
		append([]interface{}{ctx, projectID, sweepID}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_GetParameterSweepWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, sweepID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_GetParameterSweepWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_GetParameterSweepWithResponse_Call) Return(_a0 *api.GetParameterSweepResponse, _a1 error) *ClientWithResponsesInterface_GetParameterSweepWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_GetParameterSweepWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*api.GetParameterSweepResponse, error)) *ClientWithResponsesInterface_GetParameterSweepWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// GetProjectWithResponse provides a mock function with given fields: ctx, projectID, reqEditors
func (_m *ClientWithResponsesInterface) GetProjectWithResponse(ctx context.Context, projectID uuid.UUID, reqEditors ...api.RequestEditorFn) (*api.GetProjectResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetProjectWithResponse")
	}

	var r0 *api.GetProjectResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, ...api.RequestEditorFn) (*api.GetProjectResponse, error)); ok {
		return rf(ctx, projectID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, ...api.RequestEditorFn) *api.GetProjectResponse); ok {
		r0 = rf(ctx, projectID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.GetProjectResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_GetProjectWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetProjectWithResponse'
type ClientWithResponsesInterface_GetProjectWithResponse_Call struct {
	*mock.Call
}

// GetProjectWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) GetProjectWithResponse(ctx interface{}, projectID interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_GetProjectWithResponse_Call {
	return &ClientWithResponsesInterface_GetProjectWithResponse_Call{Call: _e.mock.On("GetProjectWithResponse",
		append([]interface{}{ctx, projectID}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_GetProjectWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_GetProjectWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_GetProjectWithResponse_Call) Return(_a0 *api.GetProjectResponse, _a1 error) *ClientWithResponsesInterface_GetProjectWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_GetProjectWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, ...api.RequestEditorFn) (*api.GetProjectResponse, error)) *ClientWithResponsesInterface_GetProjectWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// GetQuotaWithResponse provides a mock function with given fields: ctx, reqEditors
func (_m *ClientWithResponsesInterface) GetQuotaWithResponse(ctx context.Context, reqEditors ...api.RequestEditorFn) (*api.GetQuotaResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetQuotaWithResponse")
	}

	var r0 *api.GetQuotaResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, ...api.RequestEditorFn) (*api.GetQuotaResponse, error)); ok {
		return rf(ctx, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, ...api.RequestEditorFn) *api.GetQuotaResponse); ok {
		r0 = rf(ctx, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.GetQuotaResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_GetQuotaWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetQuotaWithResponse'
type ClientWithResponsesInterface_GetQuotaWithResponse_Call struct {
	*mock.Call
}

// GetQuotaWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) GetQuotaWithResponse(ctx interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_GetQuotaWithResponse_Call {
	return &ClientWithResponsesInterface_GetQuotaWithResponse_Call{Call: _e.mock.On("GetQuotaWithResponse",
		append([]interface{}{ctx}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_GetQuotaWithResponse_Call) Run(run func(ctx context.Context, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_GetQuotaWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_GetQuotaWithResponse_Call) Return(_a0 *api.GetQuotaResponse, _a1 error) *ClientWithResponsesInterface_GetQuotaWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_GetQuotaWithResponse_Call) RunAndReturn(run func(context.Context, ...api.RequestEditorFn) (*api.GetQuotaResponse, error)) *ClientWithResponsesInterface_GetQuotaWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// GetReportLogWithResponse provides a mock function with given fields: ctx, projectID, reportID, logID, reqEditors
func (_m *ClientWithResponsesInterface) GetReportLogWithResponse(ctx context.Context, projectID uuid.UUID, reportID uuid.UUID, logID uuid.UUID, reqEditors ...api.RequestEditorFn) (*api.GetReportLogResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, reportID, logID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetReportLogWithResponse")
	}

	var r0 *api.GetReportLogResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*api.GetReportLogResponse, error)); ok {
		return rf(ctx, projectID, reportID, logID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) *api.GetReportLogResponse); ok {
		r0 = rf(ctx, projectID, reportID, logID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.GetReportLogResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, reportID, logID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_GetReportLogWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetReportLogWithResponse'
type ClientWithResponsesInterface_GetReportLogWithResponse_Call struct {
	*mock.Call
}

// GetReportLogWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - reportID uuid.UUID
//   - logID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) GetReportLogWithResponse(ctx interface{}, projectID interface{}, reportID interface{}, logID interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_GetReportLogWithResponse_Call {
	return &ClientWithResponsesInterface_GetReportLogWithResponse_Call{Call: _e.mock.On("GetReportLogWithResponse",
		append([]interface{}{ctx, projectID, reportID, logID}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_GetReportLogWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, reportID uuid.UUID, logID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_GetReportLogWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_GetReportLogWithResponse_Call) Return(_a0 *api.GetReportLogResponse, _a1 error) *ClientWithResponsesInterface_GetReportLogWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_GetReportLogWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*api.GetReportLogResponse, error)) *ClientWithResponsesInterface_GetReportLogWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// GetReportWithResponse provides a mock function with given fields: ctx, projectID, reportID, reqEditors
func (_m *ClientWithResponsesInterface) GetReportWithResponse(ctx context.Context, projectID uuid.UUID, reportID uuid.UUID, reqEditors ...api.RequestEditorFn) (*api.GetReportResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, reportID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetReportWithResponse")
	}

	var r0 *api.GetReportResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*api.GetReportResponse, error)); ok {
		return rf(ctx, projectID, reportID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) *api.GetReportResponse); ok {
		r0 = rf(ctx, projectID, reportID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.GetReportResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, reportID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_GetReportWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetReportWithResponse'
type ClientWithResponsesInterface_GetReportWithResponse_Call struct {
	*mock.Call
}

// GetReportWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - reportID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) GetReportWithResponse(ctx interface{}, projectID interface{}, reportID interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_GetReportWithResponse_Call {
	return &ClientWithResponsesInterface_GetReportWithResponse_Call{Call: _e.mock.On("GetReportWithResponse",
		append([]interface{}{ctx, projectID, reportID}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_GetReportWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, reportID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_GetReportWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_GetReportWithResponse_Call) Return(_a0 *api.GetReportResponse, _a1 error) *ClientWithResponsesInterface_GetReportWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_GetReportWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*api.GetReportResponse, error)) *ClientWithResponsesInterface_GetReportWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// GetSystemWithResponse provides a mock function with given fields: ctx, projectID, systemID, reqEditors
func (_m *ClientWithResponsesInterface) GetSystemWithResponse(ctx context.Context, projectID uuid.UUID, systemID uuid.UUID, reqEditors ...api.RequestEditorFn) (*api.GetSystemResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, systemID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetSystemWithResponse")
	}

	var r0 *api.GetSystemResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*api.GetSystemResponse, error)); ok {
		return rf(ctx, projectID, systemID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) *api.GetSystemResponse); ok {
		r0 = rf(ctx, projectID, systemID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.GetSystemResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, systemID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_GetSystemWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSystemWithResponse'
type ClientWithResponsesInterface_GetSystemWithResponse_Call struct {
	*mock.Call
}

// GetSystemWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - systemID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) GetSystemWithResponse(ctx interface{}, projectID interface{}, systemID interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_GetSystemWithResponse_Call {
	return &ClientWithResponsesInterface_GetSystemWithResponse_Call{Call: _e.mock.On("GetSystemWithResponse",
		append([]interface{}{ctx, projectID, systemID}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_GetSystemWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, systemID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_GetSystemWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_GetSystemWithResponse_Call) Return(_a0 *api.GetSystemResponse, _a1 error) *ClientWithResponsesInterface_GetSystemWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_GetSystemWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*api.GetSystemResponse, error)) *ClientWithResponsesInterface_GetSystemWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// GetSystemsForExperienceWithResponse provides a mock function with given fields: ctx, projectID, experienceID, params, reqEditors
func (_m *ClientWithResponsesInterface) GetSystemsForExperienceWithResponse(ctx context.Context, projectID uuid.UUID, experienceID uuid.UUID, params *api.GetSystemsForExperienceParams, reqEditors ...api.RequestEditorFn) (*api.GetSystemsForExperienceResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, experienceID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetSystemsForExperienceWithResponse")
	}

	var r0 *api.GetSystemsForExperienceResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, *api.GetSystemsForExperienceParams, ...api.RequestEditorFn) (*api.GetSystemsForExperienceResponse, error)); ok {
		return rf(ctx, projectID, experienceID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, *api.GetSystemsForExperienceParams, ...api.RequestEditorFn) *api.GetSystemsForExperienceResponse); ok {
		r0 = rf(ctx, projectID, experienceID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.GetSystemsForExperienceResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, *api.GetSystemsForExperienceParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, experienceID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_GetSystemsForExperienceWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSystemsForExperienceWithResponse'
type ClientWithResponsesInterface_GetSystemsForExperienceWithResponse_Call struct {
	*mock.Call
}

// GetSystemsForExperienceWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - experienceID uuid.UUID
//   - params *api.GetSystemsForExperienceParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) GetSystemsForExperienceWithResponse(ctx interface{}, projectID interface{}, experienceID interface{}, params interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_GetSystemsForExperienceWithResponse_Call {
	return &ClientWithResponsesInterface_GetSystemsForExperienceWithResponse_Call{Call: _e.mock.On("GetSystemsForExperienceWithResponse",
		append([]interface{}{ctx, projectID, experienceID, params}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_GetSystemsForExperienceWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, experienceID uuid.UUID, params *api.GetSystemsForExperienceParams, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_GetSystemsForExperienceWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(*api.GetSystemsForExperienceParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_GetSystemsForExperienceWithResponse_Call) Return(_a0 *api.GetSystemsForExperienceResponse, _a1 error) *ClientWithResponsesInterface_GetSystemsForExperienceWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_GetSystemsForExperienceWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, *api.GetSystemsForExperienceParams, ...api.RequestEditorFn) (*api.GetSystemsForExperienceResponse, error)) *ClientWithResponsesInterface_GetSystemsForExperienceWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// GetSystemsForMetricsBuildWithResponse provides a mock function with given fields: ctx, projectID, metricsBuildID, params, reqEditors
func (_m *ClientWithResponsesInterface) GetSystemsForMetricsBuildWithResponse(ctx context.Context, projectID uuid.UUID, metricsBuildID uuid.UUID, params *api.GetSystemsForMetricsBuildParams, reqEditors ...api.RequestEditorFn) (*api.GetSystemsForMetricsBuildResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, metricsBuildID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetSystemsForMetricsBuildWithResponse")
	}

	var r0 *api.GetSystemsForMetricsBuildResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, *api.GetSystemsForMetricsBuildParams, ...api.RequestEditorFn) (*api.GetSystemsForMetricsBuildResponse, error)); ok {
		return rf(ctx, projectID, metricsBuildID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, *api.GetSystemsForMetricsBuildParams, ...api.RequestEditorFn) *api.GetSystemsForMetricsBuildResponse); ok {
		r0 = rf(ctx, projectID, metricsBuildID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.GetSystemsForMetricsBuildResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, *api.GetSystemsForMetricsBuildParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, metricsBuildID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_GetSystemsForMetricsBuildWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSystemsForMetricsBuildWithResponse'
type ClientWithResponsesInterface_GetSystemsForMetricsBuildWithResponse_Call struct {
	*mock.Call
}

// GetSystemsForMetricsBuildWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - metricsBuildID uuid.UUID
//   - params *api.GetSystemsForMetricsBuildParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) GetSystemsForMetricsBuildWithResponse(ctx interface{}, projectID interface{}, metricsBuildID interface{}, params interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_GetSystemsForMetricsBuildWithResponse_Call {
	return &ClientWithResponsesInterface_GetSystemsForMetricsBuildWithResponse_Call{Call: _e.mock.On("GetSystemsForMetricsBuildWithResponse",
		append([]interface{}{ctx, projectID, metricsBuildID, params}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_GetSystemsForMetricsBuildWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, metricsBuildID uuid.UUID, params *api.GetSystemsForMetricsBuildParams, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_GetSystemsForMetricsBuildWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(*api.GetSystemsForMetricsBuildParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_GetSystemsForMetricsBuildWithResponse_Call) Return(_a0 *api.GetSystemsForMetricsBuildResponse, _a1 error) *ClientWithResponsesInterface_GetSystemsForMetricsBuildWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_GetSystemsForMetricsBuildWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, *api.GetSystemsForMetricsBuildParams, ...api.RequestEditorFn) (*api.GetSystemsForMetricsBuildResponse, error)) *ClientWithResponsesInterface_GetSystemsForMetricsBuildWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// GetTestSuiteRevisionWithResponse provides a mock function with given fields: ctx, projectID, testSuiteID, revision, reqEditors
func (_m *ClientWithResponsesInterface) GetTestSuiteRevisionWithResponse(ctx context.Context, projectID uuid.UUID, testSuiteID uuid.UUID, revision int32, reqEditors ...api.RequestEditorFn) (*api.GetTestSuiteRevisionResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, testSuiteID, revision)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTestSuiteRevisionWithResponse")
	}

	var r0 *api.GetTestSuiteRevisionResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, int32, ...api.RequestEditorFn) (*api.GetTestSuiteRevisionResponse, error)); ok {
		return rf(ctx, projectID, testSuiteID, revision, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, int32, ...api.RequestEditorFn) *api.GetTestSuiteRevisionResponse); ok {
		r0 = rf(ctx, projectID, testSuiteID, revision, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.GetTestSuiteRevisionResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, int32, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, testSuiteID, revision, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_GetTestSuiteRevisionWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTestSuiteRevisionWithResponse'
type ClientWithResponsesInterface_GetTestSuiteRevisionWithResponse_Call struct {
	*mock.Call
}

// GetTestSuiteRevisionWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - testSuiteID uuid.UUID
//   - revision int32
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) GetTestSuiteRevisionWithResponse(ctx interface{}, projectID interface{}, testSuiteID interface{}, revision interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_GetTestSuiteRevisionWithResponse_Call {
	return &ClientWithResponsesInterface_GetTestSuiteRevisionWithResponse_Call{Call: _e.mock.On("GetTestSuiteRevisionWithResponse",
		append([]interface{}{ctx, projectID, testSuiteID, revision}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_GetTestSuiteRevisionWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, testSuiteID uuid.UUID, revision int32, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_GetTestSuiteRevisionWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(int32), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_GetTestSuiteRevisionWithResponse_Call) Return(_a0 *api.GetTestSuiteRevisionResponse, _a1 error) *ClientWithResponsesInterface_GetTestSuiteRevisionWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_GetTestSuiteRevisionWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, int32, ...api.RequestEditorFn) (*api.GetTestSuiteRevisionResponse, error)) *ClientWithResponsesInterface_GetTestSuiteRevisionWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// GetTestSuiteSummaryWithResponse provides a mock function with given fields: ctx, projectID, params, reqEditors
func (_m *ClientWithResponsesInterface) GetTestSuiteSummaryWithResponse(ctx context.Context, projectID uuid.UUID, params *api.GetTestSuiteSummaryParams, reqEditors ...api.RequestEditorFn) (*api.GetTestSuiteSummaryResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTestSuiteSummaryWithResponse")
	}

	var r0 *api.GetTestSuiteSummaryResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, *api.GetTestSuiteSummaryParams, ...api.RequestEditorFn) (*api.GetTestSuiteSummaryResponse, error)); ok {
		return rf(ctx, projectID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, *api.GetTestSuiteSummaryParams, ...api.RequestEditorFn) *api.GetTestSuiteSummaryResponse); ok {
		r0 = rf(ctx, projectID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.GetTestSuiteSummaryResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, *api.GetTestSuiteSummaryParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_GetTestSuiteSummaryWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTestSuiteSummaryWithResponse'
type ClientWithResponsesInterface_GetTestSuiteSummaryWithResponse_Call struct {
	*mock.Call
}

// GetTestSuiteSummaryWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - params *api.GetTestSuiteSummaryParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) GetTestSuiteSummaryWithResponse(ctx interface{}, projectID interface{}, params interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_GetTestSuiteSummaryWithResponse_Call {
	return &ClientWithResponsesInterface_GetTestSuiteSummaryWithResponse_Call{Call: _e.mock.On("GetTestSuiteSummaryWithResponse",
		append([]interface{}{ctx, projectID, params}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_GetTestSuiteSummaryWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, params *api.GetTestSuiteSummaryParams, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_GetTestSuiteSummaryWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(*api.GetTestSuiteSummaryParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_GetTestSuiteSummaryWithResponse_Call) Return(_a0 *api.GetTestSuiteSummaryResponse, _a1 error) *ClientWithResponsesInterface_GetTestSuiteSummaryWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_GetTestSuiteSummaryWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, *api.GetTestSuiteSummaryParams, ...api.RequestEditorFn) (*api.GetTestSuiteSummaryResponse, error)) *ClientWithResponsesInterface_GetTestSuiteSummaryWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// GetTestSuiteWithResponse provides a mock function with given fields: ctx, projectID, testSuiteID, reqEditors
func (_m *ClientWithResponsesInterface) GetTestSuiteWithResponse(ctx context.Context, projectID uuid.UUID, testSuiteID uuid.UUID, reqEditors ...api.RequestEditorFn) (*api.GetTestSuiteResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, testSuiteID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTestSuiteWithResponse")
	}

	var r0 *api.GetTestSuiteResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*api.GetTestSuiteResponse, error)); ok {
		return rf(ctx, projectID, testSuiteID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) *api.GetTestSuiteResponse); ok {
		r0 = rf(ctx, projectID, testSuiteID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.GetTestSuiteResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, testSuiteID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_GetTestSuiteWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTestSuiteWithResponse'
type ClientWithResponsesInterface_GetTestSuiteWithResponse_Call struct {
	*mock.Call
}

// GetTestSuiteWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - testSuiteID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) GetTestSuiteWithResponse(ctx interface{}, projectID interface{}, testSuiteID interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_GetTestSuiteWithResponse_Call {
	return &ClientWithResponsesInterface_GetTestSuiteWithResponse_Call{Call: _e.mock.On("GetTestSuiteWithResponse",
		append([]interface{}{ctx, projectID, testSuiteID}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_GetTestSuiteWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, testSuiteID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_GetTestSuiteWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_GetTestSuiteWithResponse_Call) Return(_a0 *api.GetTestSuiteResponse, _a1 error) *ClientWithResponsesInterface_GetTestSuiteWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_GetTestSuiteWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*api.GetTestSuiteResponse, error)) *ClientWithResponsesInterface_GetTestSuiteWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// GetViewSessionWithResponse provides a mock function with given fields: ctx, viewSessionID, reqEditors
func (_m *ClientWithResponsesInterface) GetViewSessionWithResponse(ctx context.Context, viewSessionID uuid.UUID, reqEditors ...api.RequestEditorFn) (*api.GetViewSessionResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, viewSessionID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetViewSessionWithResponse")
	}

	var r0 *api.GetViewSessionResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, ...api.RequestEditorFn) (*api.GetViewSessionResponse, error)); ok {
		return rf(ctx, viewSessionID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, ...api.RequestEditorFn) *api.GetViewSessionResponse); ok {
		r0 = rf(ctx, viewSessionID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.GetViewSessionResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, viewSessionID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_GetViewSessionWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetViewSessionWithResponse'
type ClientWithResponsesInterface_GetViewSessionWithResponse_Call struct {
	*mock.Call
}

// GetViewSessionWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - viewSessionID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) GetViewSessionWithResponse(ctx interface{}, viewSessionID interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_GetViewSessionWithResponse_Call {
	return &ClientWithResponsesInterface_GetViewSessionWithResponse_Call{Call: _e.mock.On("GetViewSessionWithResponse",
		append([]interface{}{ctx, viewSessionID}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_GetViewSessionWithResponse_Call) Run(run func(ctx context.Context, viewSessionID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_GetViewSessionWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_GetViewSessionWithResponse_Call) Return(_a0 *api.GetViewSessionResponse, _a1 error) *ClientWithResponsesInterface_GetViewSessionWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_GetViewSessionWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, ...api.RequestEditorFn) (*api.GetViewSessionResponse, error)) *ClientWithResponsesInterface_GetViewSessionWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// GetWorkflowRunWithResponse provides a mock function with given fields: ctx, projectID, workflowID, workflowRunID, reqEditors
func (_m *ClientWithResponsesInterface) GetWorkflowRunWithResponse(ctx context.Context, projectID uuid.UUID, workflowID uuid.UUID, workflowRunID uuid.UUID, reqEditors ...api.RequestEditorFn) (*api.GetWorkflowRunResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, workflowID, workflowRunID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetWorkflowRunWithResponse")
	}

	var r0 *api.GetWorkflowRunResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*api.GetWorkflowRunResponse, error)); ok {
		return rf(ctx, projectID, workflowID, workflowRunID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) *api.GetWorkflowRunResponse); ok {
		r0 = rf(ctx, projectID, workflowID, workflowRunID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.GetWorkflowRunResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, workflowID, workflowRunID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_GetWorkflowRunWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetWorkflowRunWithResponse'
type ClientWithResponsesInterface_GetWorkflowRunWithResponse_Call struct {
	*mock.Call
}

// GetWorkflowRunWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - workflowID uuid.UUID
//   - workflowRunID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) GetWorkflowRunWithResponse(ctx interface{}, projectID interface{}, workflowID interface{}, workflowRunID interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_GetWorkflowRunWithResponse_Call {
	return &ClientWithResponsesInterface_GetWorkflowRunWithResponse_Call{Call: _e.mock.On("GetWorkflowRunWithResponse",
		append([]interface{}{ctx, projectID, workflowID, workflowRunID}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_GetWorkflowRunWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, workflowID uuid.UUID, workflowRunID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_GetWorkflowRunWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_GetWorkflowRunWithResponse_Call) Return(_a0 *api.GetWorkflowRunResponse, _a1 error) *ClientWithResponsesInterface_GetWorkflowRunWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_GetWorkflowRunWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*api.GetWorkflowRunResponse, error)) *ClientWithResponsesInterface_GetWorkflowRunWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// GetWorkflowSuiteWithResponse provides a mock function with given fields: ctx, projectID, workflowID, testSuiteID, reqEditors
func (_m *ClientWithResponsesInterface) GetWorkflowSuiteWithResponse(ctx context.Context, projectID uuid.UUID, workflowID uuid.UUID, testSuiteID uuid.UUID, reqEditors ...api.RequestEditorFn) (*api.GetWorkflowSuiteResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, workflowID, testSuiteID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetWorkflowSuiteWithResponse")
	}

	var r0 *api.GetWorkflowSuiteResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*api.GetWorkflowSuiteResponse, error)); ok {
		return rf(ctx, projectID, workflowID, testSuiteID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) *api.GetWorkflowSuiteResponse); ok {
		r0 = rf(ctx, projectID, workflowID, testSuiteID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.GetWorkflowSuiteResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, workflowID, testSuiteID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_GetWorkflowSuiteWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetWorkflowSuiteWithResponse'
type ClientWithResponsesInterface_GetWorkflowSuiteWithResponse_Call struct {
	*mock.Call
}

// GetWorkflowSuiteWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - workflowID uuid.UUID
//   - testSuiteID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) GetWorkflowSuiteWithResponse(ctx interface{}, projectID interface{}, workflowID interface{}, testSuiteID interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_GetWorkflowSuiteWithResponse_Call {
	return &ClientWithResponsesInterface_GetWorkflowSuiteWithResponse_Call{Call: _e.mock.On("GetWorkflowSuiteWithResponse",
		append([]interface{}{ctx, projectID, workflowID, testSuiteID}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_GetWorkflowSuiteWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, workflowID uuid.UUID, testSuiteID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_GetWorkflowSuiteWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_GetWorkflowSuiteWithResponse_Call) Return(_a0 *api.GetWorkflowSuiteResponse, _a1 error) *ClientWithResponsesInterface_GetWorkflowSuiteWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_GetWorkflowSuiteWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*api.GetWorkflowSuiteResponse, error)) *ClientWithResponsesInterface_GetWorkflowSuiteWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// GetWorkflowWithResponse provides a mock function with given fields: ctx, projectID, workflowID, reqEditors
func (_m *ClientWithResponsesInterface) GetWorkflowWithResponse(ctx context.Context, projectID uuid.UUID, workflowID uuid.UUID, reqEditors ...api.RequestEditorFn) (*api.GetWorkflowResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, workflowID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetWorkflowWithResponse")
	}

	var r0 *api.GetWorkflowResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*api.GetWorkflowResponse, error)); ok {
		return rf(ctx, projectID, workflowID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) *api.GetWorkflowResponse); ok {
		r0 = rf(ctx, projectID, workflowID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.GetWorkflowResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, workflowID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_GetWorkflowWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetWorkflowWithResponse'
type ClientWithResponsesInterface_GetWorkflowWithResponse_Call struct {
	*mock.Call
}

// GetWorkflowWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - workflowID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) GetWorkflowWithResponse(ctx interface{}, projectID interface{}, workflowID interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_GetWorkflowWithResponse_Call {
	return &ClientWithResponsesInterface_GetWorkflowWithResponse_Call{Call: _e.mock.On("GetWorkflowWithResponse",
		append([]interface{}{ctx, projectID, workflowID}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_GetWorkflowWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, workflowID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_GetWorkflowWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_GetWorkflowWithResponse_Call) Return(_a0 *api.GetWorkflowResponse, _a1 error) *ClientWithResponsesInterface_GetWorkflowWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_GetWorkflowWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*api.GetWorkflowResponse, error)) *ClientWithResponsesInterface_GetWorkflowWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// HealthWithResponse provides a mock function with given fields: ctx, reqEditors
func (_m *ClientWithResponsesInterface) HealthWithResponse(ctx context.Context, reqEditors ...api.RequestEditorFn) (*api.HealthResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HealthWithResponse")
	}

	var r0 *api.HealthResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, ...api.RequestEditorFn) (*api.HealthResponse, error)); ok {
		return rf(ctx, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, ...api.RequestEditorFn) *api.HealthResponse); ok {
		r0 = rf(ctx, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.HealthResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_HealthWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HealthWithResponse'
type ClientWithResponsesInterface_HealthWithResponse_Call struct {
	*mock.Call
}

// HealthWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) HealthWithResponse(ctx interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_HealthWithResponse_Call {
	return &ClientWithResponsesInterface_HealthWithResponse_Call{Call: _e.mock.On("HealthWithResponse",
		append([]interface{}{ctx}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_HealthWithResponse_Call) Run(run func(ctx context.Context, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_HealthWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_HealthWithResponse_Call) Return(_a0 *api.HealthResponse, _a1 error) *ClientWithResponsesInterface_HealthWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_HealthWithResponse_Call) RunAndReturn(run func(context.Context, ...api.RequestEditorFn) (*api.HealthResponse, error)) *ClientWithResponsesInterface_HealthWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// ListAllJobsWithResponse provides a mock function with given fields: ctx, projectID, params, reqEditors
func (_m *ClientWithResponsesInterface) ListAllJobsWithResponse(ctx context.Context, projectID uuid.UUID, params *api.ListAllJobsParams, reqEditors ...api.RequestEditorFn) (*api.ListAllJobsResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListAllJobsWithResponse")
	}

	var r0 *api.ListAllJobsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, *api.ListAllJobsParams, ...api.RequestEditorFn) (*api.ListAllJobsResponse, error)); ok {
		return rf(ctx, projectID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, *api.ListAllJobsParams, ...api.RequestEditorFn) *api.ListAllJobsResponse); ok {
		r0 = rf(ctx, projectID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ListAllJobsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, *api.ListAllJobsParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_ListAllJobsWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListAllJobsWithResponse'
type ClientWithResponsesInterface_ListAllJobsWithResponse_Call struct {
	*mock.Call
}

// ListAllJobsWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - params *api.ListAllJobsParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) ListAllJobsWithResponse(ctx interface{}, projectID interface{}, params interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_ListAllJobsWithResponse_Call {
	return &ClientWithResponsesInterface_ListAllJobsWithResponse_Call{Call: _e.mock.On("ListAllJobsWithResponse",
		append([]interface{}{ctx, projectID, params}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_ListAllJobsWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, params *api.ListAllJobsParams, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_ListAllJobsWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(*api.ListAllJobsParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_ListAllJobsWithResponse_Call) Return(_a0 *api.ListAllJobsResponse, _a1 error) *ClientWithResponsesInterface_ListAllJobsWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_ListAllJobsWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, *api.ListAllJobsParams, ...api.RequestEditorFn) (*api.ListAllJobsResponse, error)) *ClientWithResponsesInterface_ListAllJobsWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// ListBatchAccountsWithResponse provides a mock function with given fields: ctx, projectID, params, reqEditors
func (_m *ClientWithResponsesInterface) ListBatchAccountsWithResponse(ctx context.Context, projectID uuid.UUID, params *api.ListBatchAccountsParams, reqEditors ...api.RequestEditorFn) (*api.ListBatchAccountsResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListBatchAccountsWithResponse")
	}

	var r0 *api.ListBatchAccountsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, *api.ListBatchAccountsParams, ...api.RequestEditorFn) (*api.ListBatchAccountsResponse, error)); ok {
		return rf(ctx, projectID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, *api.ListBatchAccountsParams, ...api.RequestEditorFn) *api.ListBatchAccountsResponse); ok {
		r0 = rf(ctx, projectID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ListBatchAccountsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, *api.ListBatchAccountsParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_ListBatchAccountsWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListBatchAccountsWithResponse'
type ClientWithResponsesInterface_ListBatchAccountsWithResponse_Call struct {
	*mock.Call
}

// ListBatchAccountsWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - params *api.ListBatchAccountsParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) ListBatchAccountsWithResponse(ctx interface{}, projectID interface{}, params interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_ListBatchAccountsWithResponse_Call {
	return &ClientWithResponsesInterface_ListBatchAccountsWithResponse_Call{Call: _e.mock.On("ListBatchAccountsWithResponse",
		append([]interface{}{ctx, projectID, params}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_ListBatchAccountsWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, params *api.ListBatchAccountsParams, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_ListBatchAccountsWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(*api.ListBatchAccountsParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_ListBatchAccountsWithResponse_Call) Return(_a0 *api.ListBatchAccountsResponse, _a1 error) *ClientWithResponsesInterface_ListBatchAccountsWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_ListBatchAccountsWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, *api.ListBatchAccountsParams, ...api.RequestEditorFn) (*api.ListBatchAccountsResponse, error)) *ClientWithResponsesInterface_ListBatchAccountsWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// ListBatchErrorsWithResponse provides a mock function with given fields: ctx, projectID, batchID, reqEditors
func (_m *ClientWithResponsesInterface) ListBatchErrorsWithResponse(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, reqEditors ...api.RequestEditorFn) (*api.ListBatchErrorsResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, batchID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListBatchErrorsWithResponse")
	}

	var r0 *api.ListBatchErrorsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*api.ListBatchErrorsResponse, error)); ok {
		return rf(ctx, projectID, batchID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) *api.ListBatchErrorsResponse); ok {
		r0 = rf(ctx, projectID, batchID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ListBatchErrorsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, batchID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_ListBatchErrorsWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListBatchErrorsWithResponse'
type ClientWithResponsesInterface_ListBatchErrorsWithResponse_Call struct {
	*mock.Call
}

// ListBatchErrorsWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - batchID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) ListBatchErrorsWithResponse(ctx interface{}, projectID interface{}, batchID interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_ListBatchErrorsWithResponse_Call {
	return &ClientWithResponsesInterface_ListBatchErrorsWithResponse_Call{Call: _e.mock.On("ListBatchErrorsWithResponse",
		append([]interface{}{ctx, projectID, batchID}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_ListBatchErrorsWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_ListBatchErrorsWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_ListBatchErrorsWithResponse_Call) Return(_a0 *api.ListBatchErrorsResponse, _a1 error) *ClientWithResponsesInterface_ListBatchErrorsWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_ListBatchErrorsWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*api.ListBatchErrorsResponse, error)) *ClientWithResponsesInterface_ListBatchErrorsWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// ListBatchLogsForBatchWithResponse provides a mock function with given fields: ctx, projectID, batchID, params, reqEditors
func (_m *ClientWithResponsesInterface) ListBatchLogsForBatchWithResponse(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, params *api.ListBatchLogsForBatchParams, reqEditors ...api.RequestEditorFn) (*api.ListBatchLogsForBatchResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, batchID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListBatchLogsForBatchWithResponse")
	}

	var r0 *api.ListBatchLogsForBatchResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, *api.ListBatchLogsForBatchParams, ...api.RequestEditorFn) (*api.ListBatchLogsForBatchResponse, error)); ok {
		return rf(ctx, projectID, batchID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, *api.ListBatchLogsForBatchParams, ...api.RequestEditorFn) *api.ListBatchLogsForBatchResponse); ok {
		r0 = rf(ctx, projectID, batchID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ListBatchLogsForBatchResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, *api.ListBatchLogsForBatchParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, batchID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_ListBatchLogsForBatchWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListBatchLogsForBatchWithResponse'
type ClientWithResponsesInterface_ListBatchLogsForBatchWithResponse_Call struct {
	*mock.Call
}

// ListBatchLogsForBatchWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - batchID uuid.UUID
//   - params *api.ListBatchLogsForBatchParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) ListBatchLogsForBatchWithResponse(ctx interface{}, projectID interface{}, batchID interface{}, params interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_ListBatchLogsForBatchWithResponse_Call {
	return &ClientWithResponsesInterface_ListBatchLogsForBatchWithResponse_Call{Call: _e.mock.On("ListBatchLogsForBatchWithResponse",
		append([]interface{}{ctx, projectID, batchID, params}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_ListBatchLogsForBatchWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, params *api.ListBatchLogsForBatchParams, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_ListBatchLogsForBatchWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(*api.ListBatchLogsForBatchParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_ListBatchLogsForBatchWithResponse_Call) Return(_a0 *api.ListBatchLogsForBatchResponse, _a1 error) *ClientWithResponsesInterface_ListBatchLogsForBatchWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_ListBatchLogsForBatchWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, *api.ListBatchLogsForBatchParams, ...api.RequestEditorFn) (*api.ListBatchLogsForBatchResponse, error)) *ClientWithResponsesInterface_ListBatchLogsForBatchWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// ListBatchMetricsDataForBatchMetricIDsWithResponse provides a mock function with given fields: ctx, projectID, batchID, metricID, params, reqEditors
func (_m *ClientWithResponsesInterface) ListBatchMetricsDataForBatchMetricIDsWithResponse(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, metricID []uuid.UUID, params *api.ListBatchMetricsDataForBatchMetricIDsParams, reqEditors ...api.RequestEditorFn) (*api.ListBatchMetricsDataForBatchMetricIDsResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, batchID, metricID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListBatchMetricsDataForBatchMetricIDsWithResponse")
	}

	var r0 *api.ListBatchMetricsDataForBatchMetricIDsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListBatchMetricsDataForBatchMetricIDsParams, ...api.RequestEditorFn) (*api.ListBatchMetricsDataForBatchMetricIDsResponse, error)); ok {
		return rf(ctx, projectID, batchID, metricID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListBatchMetricsDataForBatchMetricIDsParams, ...api.RequestEditorFn) *api.ListBatchMetricsDataForBatchMetricIDsResponse); ok {
		r0 = rf(ctx, projectID, batchID, metricID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ListBatchMetricsDataForBatchMetricIDsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListBatchMetricsDataForBatchMetricIDsParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, batchID, metricID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_ListBatchMetricsDataForBatchMetricIDsWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListBatchMetricsDataForBatchMetricIDsWithResponse'
type ClientWithResponsesInterface_ListBatchMetricsDataForBatchMetricIDsWithResponse_Call struct {
	*mock.Call
}

// ListBatchMetricsDataForBatchMetricIDsWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - batchID uuid.UUID
//   - metricID []uuid.UUID
//   - params *api.ListBatchMetricsDataForBatchMetricIDsParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) ListBatchMetricsDataForBatchMetricIDsWithResponse(ctx interface{}, projectID interface{}, batchID interface{}, metricID interface{}, params interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_ListBatchMetricsDataForBatchMetricIDsWithResponse_Call {
	return &ClientWithResponsesInterface_ListBatchMetricsDataForBatchMetricIDsWithResponse_Call{Call: _e.mock.On("ListBatchMetricsDataForBatchMetricIDsWithResponse",
		append([]interface{}{ctx, projectID, batchID, metricID, params}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_ListBatchMetricsDataForBatchMetricIDsWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, metricID []uuid.UUID, params *api.ListBatchMetricsDataForBatchMetricIDsParams, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_ListBatchMetricsDataForBatchMetricIDsWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].([]uuid.UUID), args[4].(*api.ListBatchMetricsDataForBatchMetricIDsParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_ListBatchMetricsDataForBatchMetricIDsWithResponse_Call) Return(_a0 *api.ListBatchMetricsDataForBatchMetricIDsResponse, _a1 error) *ClientWithResponsesInterface_ListBatchMetricsDataForBatchMetricIDsWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_ListBatchMetricsDataForBatchMetricIDsWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListBatchMetricsDataForBatchMetricIDsParams, ...api.RequestEditorFn) (*api.ListBatchMetricsDataForBatchMetricIDsResponse, error)) *ClientWithResponsesInterface_ListBatchMetricsDataForBatchMetricIDsWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// ListBatchMetricsDataForBatchMetricsDataIDsWithResponse provides a mock function with given fields: ctx, projectID, batchID, metricsDataID, params, reqEditors
func (_m *ClientWithResponsesInterface) ListBatchMetricsDataForBatchMetricsDataIDsWithResponse(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, metricsDataID []uuid.UUID, params *api.ListBatchMetricsDataForBatchMetricsDataIDsParams, reqEditors ...api.RequestEditorFn) (*api.ListBatchMetricsDataForBatchMetricsDataIDsResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, batchID, metricsDataID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListBatchMetricsDataForBatchMetricsDataIDsWithResponse")
	}

	var r0 *api.ListBatchMetricsDataForBatchMetricsDataIDsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListBatchMetricsDataForBatchMetricsDataIDsParams, ...api.RequestEditorFn) (*api.ListBatchMetricsDataForBatchMetricsDataIDsResponse, error)); ok {
		return rf(ctx, projectID, batchID, metricsDataID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListBatchMetricsDataForBatchMetricsDataIDsParams, ...api.RequestEditorFn) *api.ListBatchMetricsDataForBatchMetricsDataIDsResponse); ok {
		r0 = rf(ctx, projectID, batchID, metricsDataID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ListBatchMetricsDataForBatchMetricsDataIDsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListBatchMetricsDataForBatchMetricsDataIDsParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, batchID, metricsDataID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_ListBatchMetricsDataForBatchMetricsDataIDsWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListBatchMetricsDataForBatchMetricsDataIDsWithResponse'
type ClientWithResponsesInterface_ListBatchMetricsDataForBatchMetricsDataIDsWithResponse_Call struct {
	*mock.Call
}

// ListBatchMetricsDataForBatchMetricsDataIDsWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - batchID uuid.UUID
//   - metricsDataID []uuid.UUID
//   - params *api.ListBatchMetricsDataForBatchMetricsDataIDsParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) ListBatchMetricsDataForBatchMetricsDataIDsWithResponse(ctx interface{}, projectID interface{}, batchID interface{}, metricsDataID interface{}, params interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_ListBatchMetricsDataForBatchMetricsDataIDsWithResponse_Call {
	return &ClientWithResponsesInterface_ListBatchMetricsDataForBatchMetricsDataIDsWithResponse_Call{Call: _e.mock.On("ListBatchMetricsDataForBatchMetricsDataIDsWithResponse",
		append([]interface{}{ctx, projectID, batchID, metricsDataID, params}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_ListBatchMetricsDataForBatchMetricsDataIDsWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, metricsDataID []uuid.UUID, params *api.ListBatchMetricsDataForBatchMetricsDataIDsParams, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_ListBatchMetricsDataForBatchMetricsDataIDsWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].([]uuid.UUID), args[4].(*api.ListBatchMetricsDataForBatchMetricsDataIDsParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_ListBatchMetricsDataForBatchMetricsDataIDsWithResponse_Call) Return(_a0 *api.ListBatchMetricsDataForBatchMetricsDataIDsResponse, _a1 error) *ClientWithResponsesInterface_ListBatchMetricsDataForBatchMetricsDataIDsWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_ListBatchMetricsDataForBatchMetricsDataIDsWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListBatchMetricsDataForBatchMetricsDataIDsParams, ...api.RequestEditorFn) (*api.ListBatchMetricsDataForBatchMetricsDataIDsResponse, error)) *ClientWithResponsesInterface_ListBatchMetricsDataForBatchMetricsDataIDsWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// ListBatchMetricsDataWithResponse provides a mock function with given fields: ctx, projectID, batchID, params, reqEditors
func (_m *ClientWithResponsesInterface) ListBatchMetricsDataWithResponse(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, params *api.ListBatchMetricsDataParams, reqEditors ...api.RequestEditorFn) (*api.ListBatchMetricsDataResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, batchID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListBatchMetricsDataWithResponse")
	}

	var r0 *api.ListBatchMetricsDataResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, *api.ListBatchMetricsDataParams, ...api.RequestEditorFn) (*api.ListBatchMetricsDataResponse, error)); ok {
		return rf(ctx, projectID, batchID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, *api.ListBatchMetricsDataParams, ...api.RequestEditorFn) *api.ListBatchMetricsDataResponse); ok {
		r0 = rf(ctx, projectID, batchID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ListBatchMetricsDataResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, *api.ListBatchMetricsDataParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, batchID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_ListBatchMetricsDataWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListBatchMetricsDataWithResponse'
type ClientWithResponsesInterface_ListBatchMetricsDataWithResponse_Call struct {
	*mock.Call
}

// ListBatchMetricsDataWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - batchID uuid.UUID
//   - params *api.ListBatchMetricsDataParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) ListBatchMetricsDataWithResponse(ctx interface{}, projectID interface{}, batchID interface{}, params interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_ListBatchMetricsDataWithResponse_Call {
	return &ClientWithResponsesInterface_ListBatchMetricsDataWithResponse_Call{Call: _e.mock.On("ListBatchMetricsDataWithResponse",
		append([]interface{}{ctx, projectID, batchID, params}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_ListBatchMetricsDataWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, params *api.ListBatchMetricsDataParams, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_ListBatchMetricsDataWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(*api.ListBatchMetricsDataParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_ListBatchMetricsDataWithResponse_Call) Return(_a0 *api.ListBatchMetricsDataResponse, _a1 error) *ClientWithResponsesInterface_ListBatchMetricsDataWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_ListBatchMetricsDataWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, *api.ListBatchMetricsDataParams, ...api.RequestEditorFn) (*api.ListBatchMetricsDataResponse, error)) *ClientWithResponsesInterface_ListBatchMetricsDataWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// ListBatchMetricsForBatchMetricIDsWithResponse provides a mock function with given fields: ctx, projectID, batchID, metricID, params, reqEditors
func (_m *ClientWithResponsesInterface) ListBatchMetricsForBatchMetricIDsWithResponse(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, metricID []uuid.UUID, params *api.ListBatchMetricsForBatchMetricIDsParams, reqEditors ...api.RequestEditorFn) (*api.ListBatchMetricsForBatchMetricIDsResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, batchID, metricID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListBatchMetricsForBatchMetricIDsWithResponse")
	}

	var r0 *api.ListBatchMetricsForBatchMetricIDsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListBatchMetricsForBatchMetricIDsParams, ...api.RequestEditorFn) (*api.ListBatchMetricsForBatchMetricIDsResponse, error)); ok {
		return rf(ctx, projectID, batchID, metricID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListBatchMetricsForBatchMetricIDsParams, ...api.RequestEditorFn) *api.ListBatchMetricsForBatchMetricIDsResponse); ok {
		r0 = rf(ctx, projectID, batchID, metricID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ListBatchMetricsForBatchMetricIDsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListBatchMetricsForBatchMetricIDsParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, batchID, metricID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_ListBatchMetricsForBatchMetricIDsWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListBatchMetricsForBatchMetricIDsWithResponse'
type ClientWithResponsesInterface_ListBatchMetricsForBatchMetricIDsWithResponse_Call struct {
	*mock.Call
}

// ListBatchMetricsForBatchMetricIDsWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - batchID uuid.UUID
//   - metricID []uuid.UUID
//   - params *api.ListBatchMetricsForBatchMetricIDsParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) ListBatchMetricsForBatchMetricIDsWithResponse(ctx interface{}, projectID interface{}, batchID interface{}, metricID interface{}, params interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_ListBatchMetricsForBatchMetricIDsWithResponse_Call {
	return &ClientWithResponsesInterface_ListBatchMetricsForBatchMetricIDsWithResponse_Call{Call: _e.mock.On("ListBatchMetricsForBatchMetricIDsWithResponse",
		append([]interface{}{ctx, projectID, batchID, metricID, params}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_ListBatchMetricsForBatchMetricIDsWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, metricID []uuid.UUID, params *api.ListBatchMetricsForBatchMetricIDsParams, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_ListBatchMetricsForBatchMetricIDsWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].([]uuid.UUID), args[4].(*api.ListBatchMetricsForBatchMetricIDsParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_ListBatchMetricsForBatchMetricIDsWithResponse_Call) Return(_a0 *api.ListBatchMetricsForBatchMetricIDsResponse, _a1 error) *ClientWithResponsesInterface_ListBatchMetricsForBatchMetricIDsWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_ListBatchMetricsForBatchMetricIDsWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListBatchMetricsForBatchMetricIDsParams, ...api.RequestEditorFn) (*api.ListBatchMetricsForBatchMetricIDsResponse, error)) *ClientWithResponsesInterface_ListBatchMetricsForBatchMetricIDsWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// ListBatchMetricsWithResponse provides a mock function with given fields: ctx, projectID, batchID, params, reqEditors
func (_m *ClientWithResponsesInterface) ListBatchMetricsWithResponse(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, params *api.ListBatchMetricsParams, reqEditors ...api.RequestEditorFn) (*api.ListBatchMetricsResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, batchID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListBatchMetricsWithResponse")
	}

	var r0 *api.ListBatchMetricsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, *api.ListBatchMetricsParams, ...api.RequestEditorFn) (*api.ListBatchMetricsResponse, error)); ok {
		return rf(ctx, projectID, batchID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, *api.ListBatchMetricsParams, ...api.RequestEditorFn) *api.ListBatchMetricsResponse); ok {
		r0 = rf(ctx, projectID, batchID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ListBatchMetricsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, *api.ListBatchMetricsParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, batchID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_ListBatchMetricsWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListBatchMetricsWithResponse'
type ClientWithResponsesInterface_ListBatchMetricsWithResponse_Call struct {
	*mock.Call
}

// ListBatchMetricsWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - batchID uuid.UUID
//   - params *api.ListBatchMetricsParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) ListBatchMetricsWithResponse(ctx interface{}, projectID interface{}, batchID interface{}, params interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_ListBatchMetricsWithResponse_Call {
	return &ClientWithResponsesInterface_ListBatchMetricsWithResponse_Call{Call: _e.mock.On("ListBatchMetricsWithResponse",
		append([]interface{}{ctx, projectID, batchID, params}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_ListBatchMetricsWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, params *api.ListBatchMetricsParams, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_ListBatchMetricsWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(*api.ListBatchMetricsParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_ListBatchMetricsWithResponse_Call) Return(_a0 *api.ListBatchMetricsResponse, _a1 error) *ClientWithResponsesInterface_ListBatchMetricsWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_ListBatchMetricsWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, *api.ListBatchMetricsParams, ...api.RequestEditorFn) (*api.ListBatchMetricsResponse, error)) *ClientWithResponsesInterface_ListBatchMetricsWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// ListBatchesForBuildsWithResponse provides a mock function with given fields: ctx, projectID, branchID, buildID, params, reqEditors
func (_m *ClientWithResponsesInterface) ListBatchesForBuildsWithResponse(ctx context.Context, projectID uuid.UUID, branchID uuid.UUID, buildID []uuid.UUID, params *api.ListBatchesForBuildsParams, reqEditors ...api.RequestEditorFn) (*api.ListBatchesForBuildsResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, branchID, buildID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListBatchesForBuildsWithResponse")
	}

	var r0 *api.ListBatchesForBuildsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListBatchesForBuildsParams, ...api.RequestEditorFn) (*api.ListBatchesForBuildsResponse, error)); ok {
		return rf(ctx, projectID, branchID, buildID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListBatchesForBuildsParams, ...api.RequestEditorFn) *api.ListBatchesForBuildsResponse); ok {
		r0 = rf(ctx, projectID, branchID, buildID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ListBatchesForBuildsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListBatchesForBuildsParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, branchID, buildID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_ListBatchesForBuildsWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListBatchesForBuildsWithResponse'
type ClientWithResponsesInterface_ListBatchesForBuildsWithResponse_Call struct {
	*mock.Call
}

// ListBatchesForBuildsWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - branchID uuid.UUID
//   - buildID []uuid.UUID
//   - params *api.ListBatchesForBuildsParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) ListBatchesForBuildsWithResponse(ctx interface{}, projectID interface{}, branchID interface{}, buildID interface{}, params interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_ListBatchesForBuildsWithResponse_Call {
	return &ClientWithResponsesInterface_ListBatchesForBuildsWithResponse_Call{Call: _e.mock.On("ListBatchesForBuildsWithResponse",
		append([]interface{}{ctx, projectID, branchID, buildID, params}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_ListBatchesForBuildsWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, branchID uuid.UUID, buildID []uuid.UUID, params *api.ListBatchesForBuildsParams, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_ListBatchesForBuildsWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].([]uuid.UUID), args[4].(*api.ListBatchesForBuildsParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_ListBatchesForBuildsWithResponse_Call) Return(_a0 *api.ListBatchesForBuildsResponse, _a1 error) *ClientWithResponsesInterface_ListBatchesForBuildsWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_ListBatchesForBuildsWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListBatchesForBuildsParams, ...api.RequestEditorFn) (*api.ListBatchesForBuildsResponse, error)) *ClientWithResponsesInterface_ListBatchesForBuildsWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// ListBatchesForTestSuiteRevisionWithResponse provides a mock function with given fields: ctx, projectID, testSuiteID, revision, params, reqEditors
func (_m *ClientWithResponsesInterface) ListBatchesForTestSuiteRevisionWithResponse(ctx context.Context, projectID uuid.UUID, testSuiteID uuid.UUID, revision int32, params *api.ListBatchesForTestSuiteRevisionParams, reqEditors ...api.RequestEditorFn) (*api.ListBatchesForTestSuiteRevisionResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, testSuiteID, revision, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListBatchesForTestSuiteRevisionWithResponse")
	}

	var r0 *api.ListBatchesForTestSuiteRevisionResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, int32, *api.ListBatchesForTestSuiteRevisionParams, ...api.RequestEditorFn) (*api.ListBatchesForTestSuiteRevisionResponse, error)); ok {
		return rf(ctx, projectID, testSuiteID, revision, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, int32, *api.ListBatchesForTestSuiteRevisionParams, ...api.RequestEditorFn) *api.ListBatchesForTestSuiteRevisionResponse); ok {
		r0 = rf(ctx, projectID, testSuiteID, revision, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ListBatchesForTestSuiteRevisionResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, int32, *api.ListBatchesForTestSuiteRevisionParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, testSuiteID, revision, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_ListBatchesForTestSuiteRevisionWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListBatchesForTestSuiteRevisionWithResponse'
type ClientWithResponsesInterface_ListBatchesForTestSuiteRevisionWithResponse_Call struct {
	*mock.Call
}

// ListBatchesForTestSuiteRevisionWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - testSuiteID uuid.UUID
//   - revision int32
//   - params *api.ListBatchesForTestSuiteRevisionParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) ListBatchesForTestSuiteRevisionWithResponse(ctx interface{}, projectID interface{}, testSuiteID interface{}, revision interface{}, params interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_ListBatchesForTestSuiteRevisionWithResponse_Call {
	return &ClientWithResponsesInterface_ListBatchesForTestSuiteRevisionWithResponse_Call{Call: _e.mock.On("ListBatchesForTestSuiteRevisionWithResponse",
		append([]interface{}{ctx, projectID, testSuiteID, revision, params}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_ListBatchesForTestSuiteRevisionWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, testSuiteID uuid.UUID, revision int32, params *api.ListBatchesForTestSuiteRevisionParams, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_ListBatchesForTestSuiteRevisionWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(int32), args[4].(*api.ListBatchesForTestSuiteRevisionParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_ListBatchesForTestSuiteRevisionWithResponse_Call) Return(_a0 *api.ListBatchesForTestSuiteRevisionResponse, _a1 error) *ClientWithResponsesInterface_ListBatchesForTestSuiteRevisionWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_ListBatchesForTestSuiteRevisionWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, int32, *api.ListBatchesForTestSuiteRevisionParams, ...api.RequestEditorFn) (*api.ListBatchesForTestSuiteRevisionResponse, error)) *ClientWithResponsesInterface_ListBatchesForTestSuiteRevisionWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// ListBatchesForTestSuiteWithResponse provides a mock function with given fields: ctx, projectID, testSuiteID, params, reqEditors
func (_m *ClientWithResponsesInterface) ListBatchesForTestSuiteWithResponse(ctx context.Context, projectID uuid.UUID, testSuiteID uuid.UUID, params *api.ListBatchesForTestSuiteParams, reqEditors ...api.RequestEditorFn) (*api.ListBatchesForTestSuiteResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, testSuiteID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListBatchesForTestSuiteWithResponse")
	}

	var r0 *api.ListBatchesForTestSuiteResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, *api.ListBatchesForTestSuiteParams, ...api.RequestEditorFn) (*api.ListBatchesForTestSuiteResponse, error)); ok {
		return rf(ctx, projectID, testSuiteID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, *api.ListBatchesForTestSuiteParams, ...api.RequestEditorFn) *api.ListBatchesForTestSuiteResponse); ok {
		r0 = rf(ctx, projectID, testSuiteID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ListBatchesForTestSuiteResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, *api.ListBatchesForTestSuiteParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, testSuiteID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_ListBatchesForTestSuiteWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListBatchesForTestSuiteWithResponse'
type ClientWithResponsesInterface_ListBatchesForTestSuiteWithResponse_Call struct {
	*mock.Call
}

// ListBatchesForTestSuiteWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - testSuiteID uuid.UUID
//   - params *api.ListBatchesForTestSuiteParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) ListBatchesForTestSuiteWithResponse(ctx interface{}, projectID interface{}, testSuiteID interface{}, params interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_ListBatchesForTestSuiteWithResponse_Call {
	return &ClientWithResponsesInterface_ListBatchesForTestSuiteWithResponse_Call{Call: _e.mock.On("ListBatchesForTestSuiteWithResponse",
		append([]interface{}{ctx, projectID, testSuiteID, params}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_ListBatchesForTestSuiteWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, testSuiteID uuid.UUID, params *api.ListBatchesForTestSuiteParams, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_ListBatchesForTestSuiteWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(*api.ListBatchesForTestSuiteParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_ListBatchesForTestSuiteWithResponse_Call) Return(_a0 *api.ListBatchesForTestSuiteResponse, _a1 error) *ClientWithResponsesInterface_ListBatchesForTestSuiteWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_ListBatchesForTestSuiteWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, *api.ListBatchesForTestSuiteParams, ...api.RequestEditorFn) (*api.ListBatchesForTestSuiteResponse, error)) *ClientWithResponsesInterface_ListBatchesForTestSuiteWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// ListBatchesWithResponse provides a mock function with given fields: ctx, projectID, params, reqEditors
func (_m *ClientWithResponsesInterface) ListBatchesWithResponse(ctx context.Context, projectID uuid.UUID, params *api.ListBatchesParams, reqEditors ...api.RequestEditorFn) (*api.ListBatchesResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListBatchesWithResponse")
	}

	var r0 *api.ListBatchesResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, *api.ListBatchesParams, ...api.RequestEditorFn) (*api.ListBatchesResponse, error)); ok {
		return rf(ctx, projectID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, *api.ListBatchesParams, ...api.RequestEditorFn) *api.ListBatchesResponse); ok {
		r0 = rf(ctx, projectID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ListBatchesResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, *api.ListBatchesParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_ListBatchesWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListBatchesWithResponse'
type ClientWithResponsesInterface_ListBatchesWithResponse_Call struct {
	*mock.Call
}

// ListBatchesWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - params *api.ListBatchesParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) ListBatchesWithResponse(ctx interface{}, projectID interface{}, params interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_ListBatchesWithResponse_Call {
	return &ClientWithResponsesInterface_ListBatchesWithResponse_Call{Call: _e.mock.On("ListBatchesWithResponse",
		append([]interface{}{ctx, projectID, params}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_ListBatchesWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, params *api.ListBatchesParams, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_ListBatchesWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(*api.ListBatchesParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_ListBatchesWithResponse_Call) Return(_a0 *api.ListBatchesResponse, _a1 error) *ClientWithResponsesInterface_ListBatchesWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_ListBatchesWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, *api.ListBatchesParams, ...api.RequestEditorFn) (*api.ListBatchesResponse, error)) *ClientWithResponsesInterface_ListBatchesWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// ListBranchesForProjectWithResponse provides a mock function with given fields: ctx, projectID, params, reqEditors
func (_m *ClientWithResponsesInterface) ListBranchesForProjectWithResponse(ctx context.Context, projectID uuid.UUID, params *api.ListBranchesForProjectParams, reqEditors ...api.RequestEditorFn) (*api.ListBranchesForProjectResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListBranchesForProjectWithResponse")
	}

	var r0 *api.ListBranchesForProjectResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, *api.ListBranchesForProjectParams, ...api.RequestEditorFn) (*api.ListBranchesForProjectResponse, error)); ok {
		return rf(ctx, projectID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, *api.ListBranchesForProjectParams, ...api.RequestEditorFn) *api.ListBranchesForProjectResponse); ok {
		r0 = rf(ctx, projectID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ListBranchesForProjectResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, *api.ListBranchesForProjectParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_ListBranchesForProjectWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListBranchesForProjectWithResponse'
type ClientWithResponsesInterface_ListBranchesForProjectWithResponse_Call struct {
	*mock.Call
}

// ListBranchesForProjectWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - params *api.ListBranchesForProjectParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) ListBranchesForProjectWithResponse(ctx interface{}, projectID interface{}, params interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_ListBranchesForProjectWithResponse_Call {
	return &ClientWithResponsesInterface_ListBranchesForProjectWithResponse_Call{Call: _e.mock.On("ListBranchesForProjectWithResponse",
		append([]interface{}{ctx, projectID, params}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_ListBranchesForProjectWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, params *api.ListBranchesForProjectParams, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_ListBranchesForProjectWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(*api.ListBranchesForProjectParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_ListBranchesForProjectWithResponse_Call) Return(_a0 *api.ListBranchesForProjectResponse, _a1 error) *ClientWithResponsesInterface_ListBranchesForProjectWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_ListBranchesForProjectWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, *api.ListBranchesForProjectParams, ...api.RequestEditorFn) (*api.ListBranchesForProjectResponse, error)) *ClientWithResponsesInterface_ListBranchesForProjectWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// ListBuildAccountsWithResponse provides a mock function with given fields: ctx, projectID, reqEditors
func (_m *ClientWithResponsesInterface) ListBuildAccountsWithResponse(ctx context.Context, projectID uuid.UUID, reqEditors ...api.RequestEditorFn) (*api.ListBuildAccountsResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListBuildAccountsWithResponse")
	}

	var r0 *api.ListBuildAccountsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, ...api.RequestEditorFn) (*api.ListBuildAccountsResponse, error)); ok {
		return rf(ctx, projectID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, ...api.RequestEditorFn) *api.ListBuildAccountsResponse); ok {
		r0 = rf(ctx, projectID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ListBuildAccountsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_ListBuildAccountsWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListBuildAccountsWithResponse'
type ClientWithResponsesInterface_ListBuildAccountsWithResponse_Call struct {
	*mock.Call
}

// ListBuildAccountsWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) ListBuildAccountsWithResponse(ctx interface{}, projectID interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_ListBuildAccountsWithResponse_Call {
	return &ClientWithResponsesInterface_ListBuildAccountsWithResponse_Call{Call: _e.mock.On("ListBuildAccountsWithResponse",
		append([]interface{}{ctx, projectID}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_ListBuildAccountsWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_ListBuildAccountsWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_ListBuildAccountsWithResponse_Call) Return(_a0 *api.ListBuildAccountsResponse, _a1 error) *ClientWithResponsesInterface_ListBuildAccountsWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_ListBuildAccountsWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, ...api.RequestEditorFn) (*api.ListBuildAccountsResponse, error)) *ClientWithResponsesInterface_ListBuildAccountsWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// ListBuildsForBranchesWithResponse provides a mock function with given fields: ctx, projectID, branchID, params, reqEditors
func (_m *ClientWithResponsesInterface) ListBuildsForBranchesWithResponse(ctx context.Context, projectID uuid.UUID, branchID []uuid.UUID, params *api.ListBuildsForBranchesParams, reqEditors ...api.RequestEditorFn) (*api.ListBuildsForBranchesResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, branchID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListBuildsForBranchesWithResponse")
	}

	var r0 *api.ListBuildsForBranchesResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, []uuid.UUID, *api.ListBuildsForBranchesParams, ...api.RequestEditorFn) (*api.ListBuildsForBranchesResponse, error)); ok {
		return rf(ctx, projectID, branchID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, []uuid.UUID, *api.ListBuildsForBranchesParams, ...api.RequestEditorFn) *api.ListBuildsForBranchesResponse); ok {
		r0 = rf(ctx, projectID, branchID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ListBuildsForBranchesResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, []uuid.UUID, *api.ListBuildsForBranchesParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, branchID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_ListBuildsForBranchesWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListBuildsForBranchesWithResponse'
type ClientWithResponsesInterface_ListBuildsForBranchesWithResponse_Call struct {
	*mock.Call
}

// ListBuildsForBranchesWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - branchID []uuid.UUID
//   - params *api.ListBuildsForBranchesParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) ListBuildsForBranchesWithResponse(ctx interface{}, projectID interface{}, branchID interface{}, params interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_ListBuildsForBranchesWithResponse_Call {
	return &ClientWithResponsesInterface_ListBuildsForBranchesWithResponse_Call{Call: _e.mock.On("ListBuildsForBranchesWithResponse",
		append([]interface{}{ctx, projectID, branchID, params}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_ListBuildsForBranchesWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, branchID []uuid.UUID, params *api.ListBuildsForBranchesParams, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_ListBuildsForBranchesWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].([]uuid.UUID), args[3].(*api.ListBuildsForBranchesParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_ListBuildsForBranchesWithResponse_Call) Return(_a0 *api.ListBuildsForBranchesResponse, _a1 error) *ClientWithResponsesInterface_ListBuildsForBranchesWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_ListBuildsForBranchesWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, []uuid.UUID, *api.ListBuildsForBranchesParams, ...api.RequestEditorFn) (*api.ListBuildsForBranchesResponse, error)) *ClientWithResponsesInterface_ListBuildsForBranchesWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// ListBuildsForSystemWithResponse provides a mock function with given fields: ctx, projectID, systemID, params, reqEditors
func (_m *ClientWithResponsesInterface) ListBuildsForSystemWithResponse(ctx context.Context, projectID uuid.UUID, systemID uuid.UUID, params *api.ListBuildsForSystemParams, reqEditors ...api.RequestEditorFn) (*api.ListBuildsForSystemResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, systemID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListBuildsForSystemWithResponse")
	}

	var r0 *api.ListBuildsForSystemResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, *api.ListBuildsForSystemParams, ...api.RequestEditorFn) (*api.ListBuildsForSystemResponse, error)); ok {
		return rf(ctx, projectID, systemID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, *api.ListBuildsForSystemParams, ...api.RequestEditorFn) *api.ListBuildsForSystemResponse); ok {
		r0 = rf(ctx, projectID, systemID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ListBuildsForSystemResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, *api.ListBuildsForSystemParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, systemID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_ListBuildsForSystemWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListBuildsForSystemWithResponse'
type ClientWithResponsesInterface_ListBuildsForSystemWithResponse_Call struct {
	*mock.Call
}

// ListBuildsForSystemWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - systemID uuid.UUID
//   - params *api.ListBuildsForSystemParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) ListBuildsForSystemWithResponse(ctx interface{}, projectID interface{}, systemID interface{}, params interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_ListBuildsForSystemWithResponse_Call {
	return &ClientWithResponsesInterface_ListBuildsForSystemWithResponse_Call{Call: _e.mock.On("ListBuildsForSystemWithResponse",
		append([]interface{}{ctx, projectID, systemID, params}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_ListBuildsForSystemWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, systemID uuid.UUID, params *api.ListBuildsForSystemParams, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_ListBuildsForSystemWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(*api.ListBuildsForSystemParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_ListBuildsForSystemWithResponse_Call) Return(_a0 *api.ListBuildsForSystemResponse, _a1 error) *ClientWithResponsesInterface_ListBuildsForSystemWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_ListBuildsForSystemWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, *api.ListBuildsForSystemParams, ...api.RequestEditorFn) (*api.ListBuildsForSystemResponse, error)) *ClientWithResponsesInterface_ListBuildsForSystemWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// ListBuildsWithResponse provides a mock function with given fields: ctx, projectID, params, reqEditors
func (_m *ClientWithResponsesInterface) ListBuildsWithResponse(ctx context.Context, projectID uuid.UUID, params *api.ListBuildsParams, reqEditors ...api.RequestEditorFn) (*api.ListBuildsResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListBuildsWithResponse")
	}

	var r0 *api.ListBuildsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, *api.ListBuildsParams, ...api.RequestEditorFn) (*api.ListBuildsResponse, error)); ok {
		return rf(ctx, projectID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, *api.ListBuildsParams, ...api.RequestEditorFn) *api.ListBuildsResponse); ok {
		r0 = rf(ctx, projectID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ListBuildsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, *api.ListBuildsParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_ListBuildsWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListBuildsWithResponse'
type ClientWithResponsesInterface_ListBuildsWithResponse_Call struct {
	*mock.Call
}

// ListBuildsWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - params *api.ListBuildsParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) ListBuildsWithResponse(ctx interface{}, projectID interface{}, params interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_ListBuildsWithResponse_Call {
	return &ClientWithResponsesInterface_ListBuildsWithResponse_Call{Call: _e.mock.On("ListBuildsWithResponse",
		append([]interface{}{ctx, projectID, params}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_ListBuildsWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, params *api.ListBuildsParams, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_ListBuildsWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(*api.ListBuildsParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_ListBuildsWithResponse_Call) Return(_a0 *api.ListBuildsResponse, _a1 error) *ClientWithResponsesInterface_ListBuildsWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_ListBuildsWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, *api.ListBuildsParams, ...api.RequestEditorFn) (*api.ListBuildsResponse, error)) *ClientWithResponsesInterface_ListBuildsWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// ListEventTagsForJobWithResponse provides a mock function with given fields: ctx, projectID, batchID, jobID, params, reqEditors
func (_m *ClientWithResponsesInterface) ListEventTagsForJobWithResponse(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, jobID uuid.UUID, params *api.ListEventTagsForJobParams, reqEditors ...api.RequestEditorFn) (*api.ListEventTagsForJobResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, batchID, jobID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListEventTagsForJobWithResponse")
	}

	var r0 *api.ListEventTagsForJobResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, *api.ListEventTagsForJobParams, ...api.RequestEditorFn) (*api.ListEventTagsForJobResponse, error)); ok {
		return rf(ctx, projectID, batchID, jobID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, *api.ListEventTagsForJobParams, ...api.RequestEditorFn) *api.ListEventTagsForJobResponse); ok {
		r0 = rf(ctx, projectID, batchID, jobID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ListEventTagsForJobResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, *api.ListEventTagsForJobParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, batchID, jobID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_ListEventTagsForJobWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListEventTagsForJobWithResponse'
type ClientWithResponsesInterface_ListEventTagsForJobWithResponse_Call struct {
	*mock.Call
}

// ListEventTagsForJobWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - batchID uuid.UUID
//   - jobID uuid.UUID
//   - params *api.ListEventTagsForJobParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) ListEventTagsForJobWithResponse(ctx interface{}, projectID interface{}, batchID interface{}, jobID interface{}, params interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_ListEventTagsForJobWithResponse_Call {
	return &ClientWithResponsesInterface_ListEventTagsForJobWithResponse_Call{Call: _e.mock.On("ListEventTagsForJobWithResponse",
		append([]interface{}{ctx, projectID, batchID, jobID, params}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_ListEventTagsForJobWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, jobID uuid.UUID, params *api.ListEventTagsForJobParams, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_ListEventTagsForJobWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(uuid.UUID), args[4].(*api.ListEventTagsForJobParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_ListEventTagsForJobWithResponse_Call) Return(_a0 *api.ListEventTagsForJobResponse, _a1 error) *ClientWithResponsesInterface_ListEventTagsForJobWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_ListEventTagsForJobWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, *api.ListEventTagsForJobParams, ...api.RequestEditorFn) (*api.ListEventTagsForJobResponse, error)) *ClientWithResponsesInterface_ListEventTagsForJobWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// ListEventsForJobWithResponse provides a mock function with given fields: ctx, projectID, batchID, jobID, params, reqEditors
func (_m *ClientWithResponsesInterface) ListEventsForJobWithResponse(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, jobID uuid.UUID, params *api.ListEventsForJobParams, reqEditors ...api.RequestEditorFn) (*api.ListEventsForJobResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, batchID, jobID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListEventsForJobWithResponse")
	}

	var r0 *api.ListEventsForJobResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, *api.ListEventsForJobParams, ...api.RequestEditorFn) (*api.ListEventsForJobResponse, error)); ok {
		return rf(ctx, projectID, batchID, jobID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, *api.ListEventsForJobParams, ...api.RequestEditorFn) *api.ListEventsForJobResponse); ok {
		r0 = rf(ctx, projectID, batchID, jobID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ListEventsForJobResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, *api.ListEventsForJobParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, batchID, jobID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_ListEventsForJobWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListEventsForJobWithResponse'
type ClientWithResponsesInterface_ListEventsForJobWithResponse_Call struct {
	*mock.Call
}

// ListEventsForJobWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - batchID uuid.UUID
//   - jobID uuid.UUID
//   - params *api.ListEventsForJobParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) ListEventsForJobWithResponse(ctx interface{}, projectID interface{}, batchID interface{}, jobID interface{}, params interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_ListEventsForJobWithResponse_Call {
	return &ClientWithResponsesInterface_ListEventsForJobWithResponse_Call{Call: _e.mock.On("ListEventsForJobWithResponse",
		append([]interface{}{ctx, projectID, batchID, jobID, params}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_ListEventsForJobWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, jobID uuid.UUID, params *api.ListEventsForJobParams, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_ListEventsForJobWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(uuid.UUID), args[4].(*api.ListEventsForJobParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_ListEventsForJobWithResponse_Call) Return(_a0 *api.ListEventsForJobResponse, _a1 error) *ClientWithResponsesInterface_ListEventsForJobWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_ListEventsForJobWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, *api.ListEventsForJobParams, ...api.RequestEditorFn) (*api.ListEventsForJobResponse, error)) *ClientWithResponsesInterface_ListEventsForJobWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// ListExperienceTagsForExperienceWithResponse provides a mock function with given fields: ctx, projectID, experienceID, params, reqEditors
func (_m *ClientWithResponsesInterface) ListExperienceTagsForExperienceWithResponse(ctx context.Context, projectID uuid.UUID, experienceID uuid.UUID, params *api.ListExperienceTagsForExperienceParams, reqEditors ...api.RequestEditorFn) (*api.ListExperienceTagsForExperienceResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, experienceID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListExperienceTagsForExperienceWithResponse")
	}

	var r0 *api.ListExperienceTagsForExperienceResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, *api.ListExperienceTagsForExperienceParams, ...api.RequestEditorFn) (*api.ListExperienceTagsForExperienceResponse, error)); ok {
		return rf(ctx, projectID, experienceID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, *api.ListExperienceTagsForExperienceParams, ...api.RequestEditorFn) *api.ListExperienceTagsForExperienceResponse); ok {
		r0 = rf(ctx, projectID, experienceID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ListExperienceTagsForExperienceResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, *api.ListExperienceTagsForExperienceParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, experienceID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_ListExperienceTagsForExperienceWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListExperienceTagsForExperienceWithResponse'
type ClientWithResponsesInterface_ListExperienceTagsForExperienceWithResponse_Call struct {
	*mock.Call
}

// ListExperienceTagsForExperienceWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - experienceID uuid.UUID
//   - params *api.ListExperienceTagsForExperienceParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) ListExperienceTagsForExperienceWithResponse(ctx interface{}, projectID interface{}, experienceID interface{}, params interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_ListExperienceTagsForExperienceWithResponse_Call {
	return &ClientWithResponsesInterface_ListExperienceTagsForExperienceWithResponse_Call{Call: _e.mock.On("ListExperienceTagsForExperienceWithResponse",
		append([]interface{}{ctx, projectID, experienceID, params}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_ListExperienceTagsForExperienceWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, experienceID uuid.UUID, params *api.ListExperienceTagsForExperienceParams, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_ListExperienceTagsForExperienceWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(*api.ListExperienceTagsForExperienceParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_ListExperienceTagsForExperienceWithResponse_Call) Return(_a0 *api.ListExperienceTagsForExperienceResponse, _a1 error) *ClientWithResponsesInterface_ListExperienceTagsForExperienceWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_ListExperienceTagsForExperienceWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, *api.ListExperienceTagsForExperienceParams, ...api.RequestEditorFn) (*api.ListExperienceTagsForExperienceResponse, error)) *ClientWithResponsesInterface_ListExperienceTagsForExperienceWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// ListExperienceTagsWithResponse provides a mock function with given fields: ctx, projectID, params, reqEditors
func (_m *ClientWithResponsesInterface) ListExperienceTagsWithResponse(ctx context.Context, projectID uuid.UUID, params *api.ListExperienceTagsParams, reqEditors ...api.RequestEditorFn) (*api.ListExperienceTagsResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListExperienceTagsWithResponse")
	}

	var r0 *api.ListExperienceTagsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, *api.ListExperienceTagsParams, ...api.RequestEditorFn) (*api.ListExperienceTagsResponse, error)); ok {
		return rf(ctx, projectID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, *api.ListExperienceTagsParams, ...api.RequestEditorFn) *api.ListExperienceTagsResponse); ok {
		r0 = rf(ctx, projectID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ListExperienceTagsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, *api.ListExperienceTagsParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_ListExperienceTagsWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListExperienceTagsWithResponse'
type ClientWithResponsesInterface_ListExperienceTagsWithResponse_Call struct {
	*mock.Call
}

// ListExperienceTagsWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - params *api.ListExperienceTagsParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) ListExperienceTagsWithResponse(ctx interface{}, projectID interface{}, params interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_ListExperienceTagsWithResponse_Call {
	return &ClientWithResponsesInterface_ListExperienceTagsWithResponse_Call{Call: _e.mock.On("ListExperienceTagsWithResponse",
		append([]interface{}{ctx, projectID, params}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_ListExperienceTagsWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, params *api.ListExperienceTagsParams, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_ListExperienceTagsWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(*api.ListExperienceTagsParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_ListExperienceTagsWithResponse_Call) Return(_a0 *api.ListExperienceTagsResponse, _a1 error) *ClientWithResponsesInterface_ListExperienceTagsWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_ListExperienceTagsWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, *api.ListExperienceTagsParams, ...api.RequestEditorFn) (*api.ListExperienceTagsResponse, error)) *ClientWithResponsesInterface_ListExperienceTagsWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// ListExperiencesForSystemWithResponse provides a mock function with given fields: ctx, projectID, systemID, params, reqEditors
func (_m *ClientWithResponsesInterface) ListExperiencesForSystemWithResponse(ctx context.Context, projectID uuid.UUID, systemID uuid.UUID, params *api.ListExperiencesForSystemParams, reqEditors ...api.RequestEditorFn) (*api.ListExperiencesForSystemResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, systemID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListExperiencesForSystemWithResponse")
	}

	var r0 *api.ListExperiencesForSystemResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, *api.ListExperiencesForSystemParams, ...api.RequestEditorFn) (*api.ListExperiencesForSystemResponse, error)); ok {
		return rf(ctx, projectID, systemID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, *api.ListExperiencesForSystemParams, ...api.RequestEditorFn) *api.ListExperiencesForSystemResponse); ok {
		r0 = rf(ctx, projectID, systemID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ListExperiencesForSystemResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, *api.ListExperiencesForSystemParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, systemID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_ListExperiencesForSystemWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListExperiencesForSystemWithResponse'
type ClientWithResponsesInterface_ListExperiencesForSystemWithResponse_Call struct {
	*mock.Call
}

// ListExperiencesForSystemWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - systemID uuid.UUID
//   - params *api.ListExperiencesForSystemParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) ListExperiencesForSystemWithResponse(ctx interface{}, projectID interface{}, systemID interface{}, params interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_ListExperiencesForSystemWithResponse_Call {
	return &ClientWithResponsesInterface_ListExperiencesForSystemWithResponse_Call{Call: _e.mock.On("ListExperiencesForSystemWithResponse",
		append([]interface{}{ctx, projectID, systemID, params}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_ListExperiencesForSystemWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, systemID uuid.UUID, params *api.ListExperiencesForSystemParams, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_ListExperiencesForSystemWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(*api.ListExperiencesForSystemParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_ListExperiencesForSystemWithResponse_Call) Return(_a0 *api.ListExperiencesForSystemResponse, _a1 error) *ClientWithResponsesInterface_ListExperiencesForSystemWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_ListExperiencesForSystemWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, *api.ListExperiencesForSystemParams, ...api.RequestEditorFn) (*api.ListExperiencesForSystemResponse, error)) *ClientWithResponsesInterface_ListExperiencesForSystemWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// ListExperiencesWithExperienceTagWithResponse provides a mock function with given fields: ctx, projectID, experienceTagID, params, reqEditors
func (_m *ClientWithResponsesInterface) ListExperiencesWithExperienceTagWithResponse(ctx context.Context, projectID uuid.UUID, experienceTagID uuid.UUID, params *api.ListExperiencesWithExperienceTagParams, reqEditors ...api.RequestEditorFn) (*api.ListExperiencesWithExperienceTagResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, experienceTagID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListExperiencesWithExperienceTagWithResponse")
	}

	var r0 *api.ListExperiencesWithExperienceTagResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, *api.ListExperiencesWithExperienceTagParams, ...api.RequestEditorFn) (*api.ListExperiencesWithExperienceTagResponse, error)); ok {
		return rf(ctx, projectID, experienceTagID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, *api.ListExperiencesWithExperienceTagParams, ...api.RequestEditorFn) *api.ListExperiencesWithExperienceTagResponse); ok {
		r0 = rf(ctx, projectID, experienceTagID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ListExperiencesWithExperienceTagResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, *api.ListExperiencesWithExperienceTagParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, experienceTagID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_ListExperiencesWithExperienceTagWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListExperiencesWithExperienceTagWithResponse'
type ClientWithResponsesInterface_ListExperiencesWithExperienceTagWithResponse_Call struct {
	*mock.Call
}

// ListExperiencesWithExperienceTagWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - experienceTagID uuid.UUID
//   - params *api.ListExperiencesWithExperienceTagParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) ListExperiencesWithExperienceTagWithResponse(ctx interface{}, projectID interface{}, experienceTagID interface{}, params interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_ListExperiencesWithExperienceTagWithResponse_Call {
	return &ClientWithResponsesInterface_ListExperiencesWithExperienceTagWithResponse_Call{Call: _e.mock.On("ListExperiencesWithExperienceTagWithResponse",
		append([]interface{}{ctx, projectID, experienceTagID, params}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_ListExperiencesWithExperienceTagWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, experienceTagID uuid.UUID, params *api.ListExperiencesWithExperienceTagParams, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_ListExperiencesWithExperienceTagWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(*api.ListExperiencesWithExperienceTagParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_ListExperiencesWithExperienceTagWithResponse_Call) Return(_a0 *api.ListExperiencesWithExperienceTagResponse, _a1 error) *ClientWithResponsesInterface_ListExperiencesWithExperienceTagWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_ListExperiencesWithExperienceTagWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, *api.ListExperiencesWithExperienceTagParams, ...api.RequestEditorFn) (*api.ListExperiencesWithExperienceTagResponse, error)) *ClientWithResponsesInterface_ListExperiencesWithExperienceTagWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// ListExperiencesWithResponse provides a mock function with given fields: ctx, projectID, params, reqEditors
func (_m *ClientWithResponsesInterface) ListExperiencesWithResponse(ctx context.Context, projectID uuid.UUID, params *api.ListExperiencesParams, reqEditors ...api.RequestEditorFn) (*api.ListExperiencesResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListExperiencesWithResponse")
	}

	var r0 *api.ListExperiencesResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, *api.ListExperiencesParams, ...api.RequestEditorFn) (*api.ListExperiencesResponse, error)); ok {
		return rf(ctx, projectID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, *api.ListExperiencesParams, ...api.RequestEditorFn) *api.ListExperiencesResponse); ok {
		r0 = rf(ctx, projectID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ListExperiencesResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, *api.ListExperiencesParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_ListExperiencesWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListExperiencesWithResponse'
type ClientWithResponsesInterface_ListExperiencesWithResponse_Call struct {
	*mock.Call
}

// ListExperiencesWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - params *api.ListExperiencesParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) ListExperiencesWithResponse(ctx interface{}, projectID interface{}, params interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_ListExperiencesWithResponse_Call {
	return &ClientWithResponsesInterface_ListExperiencesWithResponse_Call{Call: _e.mock.On("ListExperiencesWithResponse",
		append([]interface{}{ctx, projectID, params}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_ListExperiencesWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, params *api.ListExperiencesParams, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_ListExperiencesWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(*api.ListExperiencesParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_ListExperiencesWithResponse_Call) Return(_a0 *api.ListExperiencesResponse, _a1 error) *ClientWithResponsesInterface_ListExperiencesWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_ListExperiencesWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, *api.ListExperiencesParams, ...api.RequestEditorFn) (*api.ListExperiencesResponse, error)) *ClientWithResponsesInterface_ListExperiencesWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// ListJobLogsForJobWithResponse provides a mock function with given fields: ctx, projectID, batchID, jobID, params, reqEditors
func (_m *ClientWithResponsesInterface) ListJobLogsForJobWithResponse(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, jobID uuid.UUID, params *api.ListJobLogsForJobParams, reqEditors ...api.RequestEditorFn) (*api.ListJobLogsForJobResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, batchID, jobID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListJobLogsForJobWithResponse")
	}

	var r0 *api.ListJobLogsForJobResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, *api.ListJobLogsForJobParams, ...api.RequestEditorFn) (*api.ListJobLogsForJobResponse, error)); ok {
		return rf(ctx, projectID, batchID, jobID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, *api.ListJobLogsForJobParams, ...api.RequestEditorFn) *api.ListJobLogsForJobResponse); ok {
		r0 = rf(ctx, projectID, batchID, jobID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ListJobLogsForJobResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, *api.ListJobLogsForJobParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, batchID, jobID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_ListJobLogsForJobWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListJobLogsForJobWithResponse'
type ClientWithResponsesInterface_ListJobLogsForJobWithResponse_Call struct {
	*mock.Call
}

// ListJobLogsForJobWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - batchID uuid.UUID
//   - jobID uuid.UUID
//   - params *api.ListJobLogsForJobParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) ListJobLogsForJobWithResponse(ctx interface{}, projectID interface{}, batchID interface{}, jobID interface{}, params interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_ListJobLogsForJobWithResponse_Call {
	return &ClientWithResponsesInterface_ListJobLogsForJobWithResponse_Call{Call: _e.mock.On("ListJobLogsForJobWithResponse",
		append([]interface{}{ctx, projectID, batchID, jobID, params}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_ListJobLogsForJobWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, jobID uuid.UUID, params *api.ListJobLogsForJobParams, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_ListJobLogsForJobWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(uuid.UUID), args[4].(*api.ListJobLogsForJobParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_ListJobLogsForJobWithResponse_Call) Return(_a0 *api.ListJobLogsForJobResponse, _a1 error) *ClientWithResponsesInterface_ListJobLogsForJobWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_ListJobLogsForJobWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, *api.ListJobLogsForJobParams, ...api.RequestEditorFn) (*api.ListJobLogsForJobResponse, error)) *ClientWithResponsesInterface_ListJobLogsForJobWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// ListJobsWithResponse provides a mock function with given fields: ctx, projectID, batchID, params, reqEditors
func (_m *ClientWithResponsesInterface) ListJobsWithResponse(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, params *api.ListJobsParams, reqEditors ...api.RequestEditorFn) (*api.ListJobsResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, batchID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListJobsWithResponse")
	}

	var r0 *api.ListJobsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, *api.ListJobsParams, ...api.RequestEditorFn) (*api.ListJobsResponse, error)); ok {
		return rf(ctx, projectID, batchID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, *api.ListJobsParams, ...api.RequestEditorFn) *api.ListJobsResponse); ok {
		r0 = rf(ctx, projectID, batchID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ListJobsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, *api.ListJobsParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, batchID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_ListJobsWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListJobsWithResponse'
type ClientWithResponsesInterface_ListJobsWithResponse_Call struct {
	*mock.Call
}

// ListJobsWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - batchID uuid.UUID
//   - params *api.ListJobsParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) ListJobsWithResponse(ctx interface{}, projectID interface{}, batchID interface{}, params interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_ListJobsWithResponse_Call {
	return &ClientWithResponsesInterface_ListJobsWithResponse_Call{Call: _e.mock.On("ListJobsWithResponse",
		append([]interface{}{ctx, projectID, batchID, params}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_ListJobsWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, params *api.ListJobsParams, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_ListJobsWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(*api.ListJobsParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_ListJobsWithResponse_Call) Return(_a0 *api.ListJobsResponse, _a1 error) *ClientWithResponsesInterface_ListJobsWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_ListJobsWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, *api.ListJobsParams, ...api.RequestEditorFn) (*api.ListJobsResponse, error)) *ClientWithResponsesInterface_ListJobsWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// ListLogsForReportWithResponse provides a mock function with given fields: ctx, projectID, reportID, params, reqEditors
func (_m *ClientWithResponsesInterface) ListLogsForReportWithResponse(ctx context.Context, projectID uuid.UUID, reportID uuid.UUID, params *api.ListLogsForReportParams, reqEditors ...api.RequestEditorFn) (*api.ListLogsForReportResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, reportID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListLogsForReportWithResponse")
	}

	var r0 *api.ListLogsForReportResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, *api.ListLogsForReportParams, ...api.RequestEditorFn) (*api.ListLogsForReportResponse, error)); ok {
		return rf(ctx, projectID, reportID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, *api.ListLogsForReportParams, ...api.RequestEditorFn) *api.ListLogsForReportResponse); ok {
		r0 = rf(ctx, projectID, reportID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ListLogsForReportResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, *api.ListLogsForReportParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, reportID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_ListLogsForReportWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListLogsForReportWithResponse'
type ClientWithResponsesInterface_ListLogsForReportWithResponse_Call struct {
	*mock.Call
}

// ListLogsForReportWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - reportID uuid.UUID
//   - params *api.ListLogsForReportParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) ListLogsForReportWithResponse(ctx interface{}, projectID interface{}, reportID interface{}, params interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_ListLogsForReportWithResponse_Call {
	return &ClientWithResponsesInterface_ListLogsForReportWithResponse_Call{Call: _e.mock.On("ListLogsForReportWithResponse",
		append([]interface{}{ctx, projectID, reportID, params}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_ListLogsForReportWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, reportID uuid.UUID, params *api.ListLogsForReportParams, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_ListLogsForReportWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(*api.ListLogsForReportParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_ListLogsForReportWithResponse_Call) Return(_a0 *api.ListLogsForReportResponse, _a1 error) *ClientWithResponsesInterface_ListLogsForReportWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_ListLogsForReportWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, *api.ListLogsForReportParams, ...api.RequestEditorFn) (*api.ListLogsForReportResponse, error)) *ClientWithResponsesInterface_ListLogsForReportWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// ListMetricsBuildsWithResponse provides a mock function with given fields: ctx, projectID, params, reqEditors
func (_m *ClientWithResponsesInterface) ListMetricsBuildsWithResponse(ctx context.Context, projectID uuid.UUID, params *api.ListMetricsBuildsParams, reqEditors ...api.RequestEditorFn) (*api.ListMetricsBuildsResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListMetricsBuildsWithResponse")
	}

	var r0 *api.ListMetricsBuildsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, *api.ListMetricsBuildsParams, ...api.RequestEditorFn) (*api.ListMetricsBuildsResponse, error)); ok {
		return rf(ctx, projectID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, *api.ListMetricsBuildsParams, ...api.RequestEditorFn) *api.ListMetricsBuildsResponse); ok {
		r0 = rf(ctx, projectID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ListMetricsBuildsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, *api.ListMetricsBuildsParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_ListMetricsBuildsWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListMetricsBuildsWithResponse'
type ClientWithResponsesInterface_ListMetricsBuildsWithResponse_Call struct {
	*mock.Call
}

// ListMetricsBuildsWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - params *api.ListMetricsBuildsParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) ListMetricsBuildsWithResponse(ctx interface{}, projectID interface{}, params interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_ListMetricsBuildsWithResponse_Call {
	return &ClientWithResponsesInterface_ListMetricsBuildsWithResponse_Call{Call: _e.mock.On("ListMetricsBuildsWithResponse",
		append([]interface{}{ctx, projectID, params}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_ListMetricsBuildsWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, params *api.ListMetricsBuildsParams, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_ListMetricsBuildsWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(*api.ListMetricsBuildsParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_ListMetricsBuildsWithResponse_Call) Return(_a0 *api.ListMetricsBuildsResponse, _a1 error) *ClientWithResponsesInterface_ListMetricsBuildsWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_ListMetricsBuildsWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, *api.ListMetricsBuildsParams, ...api.RequestEditorFn) (*api.ListMetricsBuildsResponse, error)) *ClientWithResponsesInterface_ListMetricsBuildsWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// ListMetricsDataForJobWithResponse provides a mock function with given fields: ctx, projectID, batchID, jobID, params, reqEditors
func (_m *ClientWithResponsesInterface) ListMetricsDataForJobWithResponse(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, jobID uuid.UUID, params *api.ListMetricsDataForJobParams, reqEditors ...api.RequestEditorFn) (*api.ListMetricsDataForJobResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, batchID, jobID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListMetricsDataForJobWithResponse")
	}

	var r0 *api.ListMetricsDataForJobResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, *api.ListMetricsDataForJobParams, ...api.RequestEditorFn) (*api.ListMetricsDataForJobResponse, error)); ok {
		return rf(ctx, projectID, batchID, jobID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, *api.ListMetricsDataForJobParams, ...api.RequestEditorFn) *api.ListMetricsDataForJobResponse); ok {
		r0 = rf(ctx, projectID, batchID, jobID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ListMetricsDataForJobResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, *api.ListMetricsDataForJobParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, batchID, jobID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_ListMetricsDataForJobWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListMetricsDataForJobWithResponse'
type ClientWithResponsesInterface_ListMetricsDataForJobWithResponse_Call struct {
	*mock.Call
}

// ListMetricsDataForJobWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - batchID uuid.UUID
//   - jobID uuid.UUID
//   - params *api.ListMetricsDataForJobParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) ListMetricsDataForJobWithResponse(ctx interface{}, projectID interface{}, batchID interface{}, jobID interface{}, params interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_ListMetricsDataForJobWithResponse_Call {
	return &ClientWithResponsesInterface_ListMetricsDataForJobWithResponse_Call{Call: _e.mock.On("ListMetricsDataForJobWithResponse",
		append([]interface{}{ctx, projectID, batchID, jobID, params}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_ListMetricsDataForJobWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, jobID uuid.UUID, params *api.ListMetricsDataForJobParams, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_ListMetricsDataForJobWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(uuid.UUID), args[4].(*api.ListMetricsDataForJobParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_ListMetricsDataForJobWithResponse_Call) Return(_a0 *api.ListMetricsDataForJobResponse, _a1 error) *ClientWithResponsesInterface_ListMetricsDataForJobWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_ListMetricsDataForJobWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, *api.ListMetricsDataForJobParams, ...api.RequestEditorFn) (*api.ListMetricsDataForJobResponse, error)) *ClientWithResponsesInterface_ListMetricsDataForJobWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// ListMetricsDataForMetricIDsWithResponse provides a mock function with given fields: ctx, projectID, batchID, jobID, metricID, params, reqEditors
func (_m *ClientWithResponsesInterface) ListMetricsDataForMetricIDsWithResponse(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, jobID uuid.UUID, metricID []uuid.UUID, params *api.ListMetricsDataForMetricIDsParams, reqEditors ...api.RequestEditorFn) (*api.ListMetricsDataForMetricIDsResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, batchID, jobID, metricID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListMetricsDataForMetricIDsWithResponse")
	}

	var r0 *api.ListMetricsDataForMetricIDsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListMetricsDataForMetricIDsParams, ...api.RequestEditorFn) (*api.ListMetricsDataForMetricIDsResponse, error)); ok {
		return rf(ctx, projectID, batchID, jobID, metricID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListMetricsDataForMetricIDsParams, ...api.RequestEditorFn) *api.ListMetricsDataForMetricIDsResponse); ok {
		r0 = rf(ctx, projectID, batchID, jobID, metricID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ListMetricsDataForMetricIDsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListMetricsDataForMetricIDsParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, batchID, jobID, metricID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_ListMetricsDataForMetricIDsWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListMetricsDataForMetricIDsWithResponse'
type ClientWithResponsesInterface_ListMetricsDataForMetricIDsWithResponse_Call struct {
	*mock.Call
}

// ListMetricsDataForMetricIDsWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - batchID uuid.UUID
//   - jobID uuid.UUID
//   - metricID []uuid.UUID
//   - params *api.ListMetricsDataForMetricIDsParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) ListMetricsDataForMetricIDsWithResponse(ctx interface{}, projectID interface{}, batchID interface{}, jobID interface{}, metricID interface{}, params interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_ListMetricsDataForMetricIDsWithResponse_Call {
	return &ClientWithResponsesInterface_ListMetricsDataForMetricIDsWithResponse_Call{Call: _e.mock.On("ListMetricsDataForMetricIDsWithResponse",
		append([]interface{}{ctx, projectID, batchID, jobID, metricID, params}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_ListMetricsDataForMetricIDsWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, jobID uuid.UUID, metricID []uuid.UUID, params *api.ListMetricsDataForMetricIDsParams, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_ListMetricsDataForMetricIDsWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-6)
		for i, a := range args[6:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(uuid.UUID), args[4].([]uuid.UUID), args[5].(*api.ListMetricsDataForMetricIDsParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_ListMetricsDataForMetricIDsWithResponse_Call) Return(_a0 *api.ListMetricsDataForMetricIDsResponse, _a1 error) *ClientWithResponsesInterface_ListMetricsDataForMetricIDsWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_ListMetricsDataForMetricIDsWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListMetricsDataForMetricIDsParams, ...api.RequestEditorFn) (*api.ListMetricsDataForMetricIDsResponse, error)) *ClientWithResponsesInterface_ListMetricsDataForMetricIDsWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// ListMetricsDataForMetricsDataIDsWithResponse provides a mock function with given fields: ctx, projectID, batchID, jobID, metricsDataID, params, reqEditors
func (_m *ClientWithResponsesInterface) ListMetricsDataForMetricsDataIDsWithResponse(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, jobID uuid.UUID, metricsDataID []uuid.UUID, params *api.ListMetricsDataForMetricsDataIDsParams, reqEditors ...api.RequestEditorFn) (*api.ListMetricsDataForMetricsDataIDsResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, batchID, jobID, metricsDataID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListMetricsDataForMetricsDataIDsWithResponse")
	}

	var r0 *api.ListMetricsDataForMetricsDataIDsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListMetricsDataForMetricsDataIDsParams, ...api.RequestEditorFn) (*api.ListMetricsDataForMetricsDataIDsResponse, error)); ok {
		return rf(ctx, projectID, batchID, jobID, metricsDataID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListMetricsDataForMetricsDataIDsParams, ...api.RequestEditorFn) *api.ListMetricsDataForMetricsDataIDsResponse); ok {
		r0 = rf(ctx, projectID, batchID, jobID, metricsDataID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ListMetricsDataForMetricsDataIDsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListMetricsDataForMetricsDataIDsParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, batchID, jobID, metricsDataID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_ListMetricsDataForMetricsDataIDsWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListMetricsDataForMetricsDataIDsWithResponse'
type ClientWithResponsesInterface_ListMetricsDataForMetricsDataIDsWithResponse_Call struct {
	*mock.Call
}

// ListMetricsDataForMetricsDataIDsWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - batchID uuid.UUID
//   - jobID uuid.UUID
//   - metricsDataID []uuid.UUID
//   - params *api.ListMetricsDataForMetricsDataIDsParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) ListMetricsDataForMetricsDataIDsWithResponse(ctx interface{}, projectID interface{}, batchID interface{}, jobID interface{}, metricsDataID interface{}, params interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_ListMetricsDataForMetricsDataIDsWithResponse_Call {
	return &ClientWithResponsesInterface_ListMetricsDataForMetricsDataIDsWithResponse_Call{Call: _e.mock.On("ListMetricsDataForMetricsDataIDsWithResponse",
		append([]interface{}{ctx, projectID, batchID, jobID, metricsDataID, params}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_ListMetricsDataForMetricsDataIDsWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, jobID uuid.UUID, metricsDataID []uuid.UUID, params *api.ListMetricsDataForMetricsDataIDsParams, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_ListMetricsDataForMetricsDataIDsWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-6)
		for i, a := range args[6:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(uuid.UUID), args[4].([]uuid.UUID), args[5].(*api.ListMetricsDataForMetricsDataIDsParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_ListMetricsDataForMetricsDataIDsWithResponse_Call) Return(_a0 *api.ListMetricsDataForMetricsDataIDsResponse, _a1 error) *ClientWithResponsesInterface_ListMetricsDataForMetricsDataIDsWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_ListMetricsDataForMetricsDataIDsWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListMetricsDataForMetricsDataIDsParams, ...api.RequestEditorFn) (*api.ListMetricsDataForMetricsDataIDsResponse, error)) *ClientWithResponsesInterface_ListMetricsDataForMetricsDataIDsWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// ListMetricsForJobWithResponse provides a mock function with given fields: ctx, projectID, batchID, jobID, params, reqEditors
func (_m *ClientWithResponsesInterface) ListMetricsForJobWithResponse(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, jobID uuid.UUID, params *api.ListMetricsForJobParams, reqEditors ...api.RequestEditorFn) (*api.ListMetricsForJobResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, batchID, jobID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListMetricsForJobWithResponse")
	}

	var r0 *api.ListMetricsForJobResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, *api.ListMetricsForJobParams, ...api.RequestEditorFn) (*api.ListMetricsForJobResponse, error)); ok {
		return rf(ctx, projectID, batchID, jobID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, *api.ListMetricsForJobParams, ...api.RequestEditorFn) *api.ListMetricsForJobResponse); ok {
		r0 = rf(ctx, projectID, batchID, jobID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ListMetricsForJobResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, *api.ListMetricsForJobParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, batchID, jobID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_ListMetricsForJobWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListMetricsForJobWithResponse'
type ClientWithResponsesInterface_ListMetricsForJobWithResponse_Call struct {
	*mock.Call
}

// ListMetricsForJobWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - batchID uuid.UUID
//   - jobID uuid.UUID
//   - params *api.ListMetricsForJobParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) ListMetricsForJobWithResponse(ctx interface{}, projectID interface{}, batchID interface{}, jobID interface{}, params interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_ListMetricsForJobWithResponse_Call {
	return &ClientWithResponsesInterface_ListMetricsForJobWithResponse_Call{Call: _e.mock.On("ListMetricsForJobWithResponse",
		append([]interface{}{ctx, projectID, batchID, jobID, params}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_ListMetricsForJobWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, jobID uuid.UUID, params *api.ListMetricsForJobParams, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_ListMetricsForJobWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(uuid.UUID), args[4].(*api.ListMetricsForJobParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_ListMetricsForJobWithResponse_Call) Return(_a0 *api.ListMetricsForJobResponse, _a1 error) *ClientWithResponsesInterface_ListMetricsForJobWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_ListMetricsForJobWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, *api.ListMetricsForJobParams, ...api.RequestEditorFn) (*api.ListMetricsForJobResponse, error)) *ClientWithResponsesInterface_ListMetricsForJobWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// ListMetricsForMetricIDsWithResponse provides a mock function with given fields: ctx, projectID, batchID, jobID, metricID, params, reqEditors
func (_m *ClientWithResponsesInterface) ListMetricsForMetricIDsWithResponse(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, jobID uuid.UUID, metricID []uuid.UUID, params *api.ListMetricsForMetricIDsParams, reqEditors ...api.RequestEditorFn) (*api.ListMetricsForMetricIDsResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, batchID, jobID, metricID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListMetricsForMetricIDsWithResponse")
	}

	var r0 *api.ListMetricsForMetricIDsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListMetricsForMetricIDsParams, ...api.RequestEditorFn) (*api.ListMetricsForMetricIDsResponse, error)); ok {
		return rf(ctx, projectID, batchID, jobID, metricID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListMetricsForMetricIDsParams, ...api.RequestEditorFn) *api.ListMetricsForMetricIDsResponse); ok {
		r0 = rf(ctx, projectID, batchID, jobID, metricID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ListMetricsForMetricIDsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListMetricsForMetricIDsParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, batchID, jobID, metricID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_ListMetricsForMetricIDsWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListMetricsForMetricIDsWithResponse'
type ClientWithResponsesInterface_ListMetricsForMetricIDsWithResponse_Call struct {
	*mock.Call
}

// ListMetricsForMetricIDsWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - batchID uuid.UUID
//   - jobID uuid.UUID
//   - metricID []uuid.UUID
//   - params *api.ListMetricsForMetricIDsParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) ListMetricsForMetricIDsWithResponse(ctx interface{}, projectID interface{}, batchID interface{}, jobID interface{}, metricID interface{}, params interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_ListMetricsForMetricIDsWithResponse_Call {
	return &ClientWithResponsesInterface_ListMetricsForMetricIDsWithResponse_Call{Call: _e.mock.On("ListMetricsForMetricIDsWithResponse",
		append([]interface{}{ctx, projectID, batchID, jobID, metricID, params}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_ListMetricsForMetricIDsWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, jobID uuid.UUID, metricID []uuid.UUID, params *api.ListMetricsForMetricIDsParams, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_ListMetricsForMetricIDsWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-6)
		for i, a := range args[6:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(uuid.UUID), args[4].([]uuid.UUID), args[5].(*api.ListMetricsForMetricIDsParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_ListMetricsForMetricIDsWithResponse_Call) Return(_a0 *api.ListMetricsForMetricIDsResponse, _a1 error) *ClientWithResponsesInterface_ListMetricsForMetricIDsWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_ListMetricsForMetricIDsWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListMetricsForMetricIDsParams, ...api.RequestEditorFn) (*api.ListMetricsForMetricIDsResponse, error)) *ClientWithResponsesInterface_ListMetricsForMetricIDsWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// ListParameterSweepsWithResponse provides a mock function with given fields: ctx, projectID, params, reqEditors
func (_m *ClientWithResponsesInterface) ListParameterSweepsWithResponse(ctx context.Context, projectID uuid.UUID, params *api.ListParameterSweepsParams, reqEditors ...api.RequestEditorFn) (*api.ListParameterSweepsResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListParameterSweepsWithResponse")
	}

	var r0 *api.ListParameterSweepsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, *api.ListParameterSweepsParams, ...api.RequestEditorFn) (*api.ListParameterSweepsResponse, error)); ok {
		return rf(ctx, projectID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, *api.ListParameterSweepsParams, ...api.RequestEditorFn) *api.ListParameterSweepsResponse); ok {
		r0 = rf(ctx, projectID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ListParameterSweepsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, *api.ListParameterSweepsParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_ListParameterSweepsWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListParameterSweepsWithResponse'
type ClientWithResponsesInterface_ListParameterSweepsWithResponse_Call struct {
	*mock.Call
}

// ListParameterSweepsWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - params *api.ListParameterSweepsParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) ListParameterSweepsWithResponse(ctx interface{}, projectID interface{}, params interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_ListParameterSweepsWithResponse_Call {
	return &ClientWithResponsesInterface_ListParameterSweepsWithResponse_Call{Call: _e.mock.On("ListParameterSweepsWithResponse",
		append([]interface{}{ctx, projectID, params}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_ListParameterSweepsWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, params *api.ListParameterSweepsParams, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_ListParameterSweepsWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(*api.ListParameterSweepsParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_ListParameterSweepsWithResponse_Call) Return(_a0 *api.ListParameterSweepsResponse, _a1 error) *ClientWithResponsesInterface_ListParameterSweepsWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_ListParameterSweepsWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, *api.ListParameterSweepsParams, ...api.RequestEditorFn) (*api.ListParameterSweepsResponse, error)) *ClientWithResponsesInterface_ListParameterSweepsWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// ListProjectsWithResponse provides a mock function with given fields: ctx, params, reqEditors
func (_m *ClientWithResponsesInterface) ListProjectsWithResponse(ctx context.Context, params *api.ListProjectsParams, reqEditors ...api.RequestEditorFn) (*api.ListProjectsResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListProjectsWithResponse")
	}

	var r0 *api.ListProjectsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *api.ListProjectsParams, ...api.RequestEditorFn) (*api.ListProjectsResponse, error)); ok {
		return rf(ctx, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *api.ListProjectsParams, ...api.RequestEditorFn) *api.ListProjectsResponse); ok {
		r0 = rf(ctx, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ListProjectsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *api.ListProjectsParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_ListProjectsWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListProjectsWithResponse'
type ClientWithResponsesInterface_ListProjectsWithResponse_Call struct {
	*mock.Call
}

// ListProjectsWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - params *api.ListProjectsParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) ListProjectsWithResponse(ctx interface{}, params interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_ListProjectsWithResponse_Call {
	return &ClientWithResponsesInterface_ListProjectsWithResponse_Call{Call: _e.mock.On("ListProjectsWithResponse",
		append([]interface{}{ctx, params}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_ListProjectsWithResponse_Call) Run(run func(ctx context.Context, params *api.ListProjectsParams, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_ListProjectsWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(*api.ListProjectsParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_ListProjectsWithResponse_Call) Return(_a0 *api.ListProjectsResponse, _a1 error) *ClientWithResponsesInterface_ListProjectsWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_ListProjectsWithResponse_Call) RunAndReturn(run func(context.Context, *api.ListProjectsParams, ...api.RequestEditorFn) (*api.ListProjectsResponse, error)) *ClientWithResponsesInterface_ListProjectsWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// ListReportAccountsWithResponse provides a mock function with given fields: ctx, projectID, reqEditors
func (_m *ClientWithResponsesInterface) ListReportAccountsWithResponse(ctx context.Context, projectID uuid.UUID, reqEditors ...api.RequestEditorFn) (*api.ListReportAccountsResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListReportAccountsWithResponse")
	}

	var r0 *api.ListReportAccountsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, ...api.RequestEditorFn) (*api.ListReportAccountsResponse, error)); ok {
		return rf(ctx, projectID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, ...api.RequestEditorFn) *api.ListReportAccountsResponse); ok {
		r0 = rf(ctx, projectID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ListReportAccountsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_ListReportAccountsWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListReportAccountsWithResponse'
type ClientWithResponsesInterface_ListReportAccountsWithResponse_Call struct {
	*mock.Call
}

// ListReportAccountsWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) ListReportAccountsWithResponse(ctx interface{}, projectID interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_ListReportAccountsWithResponse_Call {
	return &ClientWithResponsesInterface_ListReportAccountsWithResponse_Call{Call: _e.mock.On("ListReportAccountsWithResponse",
		append([]interface{}{ctx, projectID}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_ListReportAccountsWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_ListReportAccountsWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_ListReportAccountsWithResponse_Call) Return(_a0 *api.ListReportAccountsResponse, _a1 error) *ClientWithResponsesInterface_ListReportAccountsWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_ListReportAccountsWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, ...api.RequestEditorFn) (*api.ListReportAccountsResponse, error)) *ClientWithResponsesInterface_ListReportAccountsWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// ListReportMetricsDataForReportMetricIDsWithResponse provides a mock function with given fields: ctx, projectID, reportID, metricID, params, reqEditors
func (_m *ClientWithResponsesInterface) ListReportMetricsDataForReportMetricIDsWithResponse(ctx context.Context, projectID uuid.UUID, reportID uuid.UUID, metricID []uuid.UUID, params *api.ListReportMetricsDataForReportMetricIDsParams, reqEditors ...api.RequestEditorFn) (*api.ListReportMetricsDataForReportMetricIDsResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, reportID, metricID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListReportMetricsDataForReportMetricIDsWithResponse")
	}

	var r0 *api.ListReportMetricsDataForReportMetricIDsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListReportMetricsDataForReportMetricIDsParams, ...api.RequestEditorFn) (*api.ListReportMetricsDataForReportMetricIDsResponse, error)); ok {
		return rf(ctx, projectID, reportID, metricID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListReportMetricsDataForReportMetricIDsParams, ...api.RequestEditorFn) *api.ListReportMetricsDataForReportMetricIDsResponse); ok {
		r0 = rf(ctx, projectID, reportID, metricID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ListReportMetricsDataForReportMetricIDsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListReportMetricsDataForReportMetricIDsParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, reportID, metricID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_ListReportMetricsDataForReportMetricIDsWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListReportMetricsDataForReportMetricIDsWithResponse'
type ClientWithResponsesInterface_ListReportMetricsDataForReportMetricIDsWithResponse_Call struct {
	*mock.Call
}

// ListReportMetricsDataForReportMetricIDsWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - reportID uuid.UUID
//   - metricID []uuid.UUID
//   - params *api.ListReportMetricsDataForReportMetricIDsParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) ListReportMetricsDataForReportMetricIDsWithResponse(ctx interface{}, projectID interface{}, reportID interface{}, metricID interface{}, params interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_ListReportMetricsDataForReportMetricIDsWithResponse_Call {
	return &ClientWithResponsesInterface_ListReportMetricsDataForReportMetricIDsWithResponse_Call{Call: _e.mock.On("ListReportMetricsDataForReportMetricIDsWithResponse",
		append([]interface{}{ctx, projectID, reportID, metricID, params}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_ListReportMetricsDataForReportMetricIDsWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, reportID uuid.UUID, metricID []uuid.UUID, params *api.ListReportMetricsDataForReportMetricIDsParams, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_ListReportMetricsDataForReportMetricIDsWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].([]uuid.UUID), args[4].(*api.ListReportMetricsDataForReportMetricIDsParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_ListReportMetricsDataForReportMetricIDsWithResponse_Call) Return(_a0 *api.ListReportMetricsDataForReportMetricIDsResponse, _a1 error) *ClientWithResponsesInterface_ListReportMetricsDataForReportMetricIDsWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_ListReportMetricsDataForReportMetricIDsWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListReportMetricsDataForReportMetricIDsParams, ...api.RequestEditorFn) (*api.ListReportMetricsDataForReportMetricIDsResponse, error)) *ClientWithResponsesInterface_ListReportMetricsDataForReportMetricIDsWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// ListReportMetricsDataForReportMetricsDataIDsWithResponse provides a mock function with given fields: ctx, projectID, reportID, metricsDataID, params, reqEditors
func (_m *ClientWithResponsesInterface) ListReportMetricsDataForReportMetricsDataIDsWithResponse(ctx context.Context, projectID uuid.UUID, reportID uuid.UUID, metricsDataID []uuid.UUID, params *api.ListReportMetricsDataForReportMetricsDataIDsParams, reqEditors ...api.RequestEditorFn) (*api.ListReportMetricsDataForReportMetricsDataIDsResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, reportID, metricsDataID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListReportMetricsDataForReportMetricsDataIDsWithResponse")
	}

	var r0 *api.ListReportMetricsDataForReportMetricsDataIDsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListReportMetricsDataForReportMetricsDataIDsParams, ...api.RequestEditorFn) (*api.ListReportMetricsDataForReportMetricsDataIDsResponse, error)); ok {
		return rf(ctx, projectID, reportID, metricsDataID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListReportMetricsDataForReportMetricsDataIDsParams, ...api.RequestEditorFn) *api.ListReportMetricsDataForReportMetricsDataIDsResponse); ok {
		r0 = rf(ctx, projectID, reportID, metricsDataID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ListReportMetricsDataForReportMetricsDataIDsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListReportMetricsDataForReportMetricsDataIDsParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, reportID, metricsDataID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_ListReportMetricsDataForReportMetricsDataIDsWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListReportMetricsDataForReportMetricsDataIDsWithResponse'
type ClientWithResponsesInterface_ListReportMetricsDataForReportMetricsDataIDsWithResponse_Call struct {
	*mock.Call
}

// ListReportMetricsDataForReportMetricsDataIDsWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - reportID uuid.UUID
//   - metricsDataID []uuid.UUID
//   - params *api.ListReportMetricsDataForReportMetricsDataIDsParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) ListReportMetricsDataForReportMetricsDataIDsWithResponse(ctx interface{}, projectID interface{}, reportID interface{}, metricsDataID interface{}, params interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_ListReportMetricsDataForReportMetricsDataIDsWithResponse_Call {
	return &ClientWithResponsesInterface_ListReportMetricsDataForReportMetricsDataIDsWithResponse_Call{Call: _e.mock.On("ListReportMetricsDataForReportMetricsDataIDsWithResponse",
		append([]interface{}{ctx, projectID, reportID, metricsDataID, params}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_ListReportMetricsDataForReportMetricsDataIDsWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, reportID uuid.UUID, metricsDataID []uuid.UUID, params *api.ListReportMetricsDataForReportMetricsDataIDsParams, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_ListReportMetricsDataForReportMetricsDataIDsWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].([]uuid.UUID), args[4].(*api.ListReportMetricsDataForReportMetricsDataIDsParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_ListReportMetricsDataForReportMetricsDataIDsWithResponse_Call) Return(_a0 *api.ListReportMetricsDataForReportMetricsDataIDsResponse, _a1 error) *ClientWithResponsesInterface_ListReportMetricsDataForReportMetricsDataIDsWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_ListReportMetricsDataForReportMetricsDataIDsWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListReportMetricsDataForReportMetricsDataIDsParams, ...api.RequestEditorFn) (*api.ListReportMetricsDataForReportMetricsDataIDsResponse, error)) *ClientWithResponsesInterface_ListReportMetricsDataForReportMetricsDataIDsWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// ListReportMetricsDataWithResponse provides a mock function with given fields: ctx, projectID, reportID, params, reqEditors
func (_m *ClientWithResponsesInterface) ListReportMetricsDataWithResponse(ctx context.Context, projectID uuid.UUID, reportID uuid.UUID, params *api.ListReportMetricsDataParams, reqEditors ...api.RequestEditorFn) (*api.ListReportMetricsDataResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, reportID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListReportMetricsDataWithResponse")
	}

	var r0 *api.ListReportMetricsDataResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, *api.ListReportMetricsDataParams, ...api.RequestEditorFn) (*api.ListReportMetricsDataResponse, error)); ok {
		return rf(ctx, projectID, reportID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, *api.ListReportMetricsDataParams, ...api.RequestEditorFn) *api.ListReportMetricsDataResponse); ok {
		r0 = rf(ctx, projectID, reportID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ListReportMetricsDataResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, *api.ListReportMetricsDataParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, reportID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_ListReportMetricsDataWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListReportMetricsDataWithResponse'
type ClientWithResponsesInterface_ListReportMetricsDataWithResponse_Call struct {
	*mock.Call
}

// ListReportMetricsDataWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - reportID uuid.UUID
//   - params *api.ListReportMetricsDataParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) ListReportMetricsDataWithResponse(ctx interface{}, projectID interface{}, reportID interface{}, params interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_ListReportMetricsDataWithResponse_Call {
	return &ClientWithResponsesInterface_ListReportMetricsDataWithResponse_Call{Call: _e.mock.On("ListReportMetricsDataWithResponse",
		append([]interface{}{ctx, projectID, reportID, params}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_ListReportMetricsDataWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, reportID uuid.UUID, params *api.ListReportMetricsDataParams, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_ListReportMetricsDataWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(*api.ListReportMetricsDataParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_ListReportMetricsDataWithResponse_Call) Return(_a0 *api.ListReportMetricsDataResponse, _a1 error) *ClientWithResponsesInterface_ListReportMetricsDataWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_ListReportMetricsDataWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, *api.ListReportMetricsDataParams, ...api.RequestEditorFn) (*api.ListReportMetricsDataResponse, error)) *ClientWithResponsesInterface_ListReportMetricsDataWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// ListReportMetricsForReportMetricIDsWithResponse provides a mock function with given fields: ctx, projectID, reportID, metricID, params, reqEditors
func (_m *ClientWithResponsesInterface) ListReportMetricsForReportMetricIDsWithResponse(ctx context.Context, projectID uuid.UUID, reportID uuid.UUID, metricID []uuid.UUID, params *api.ListReportMetricsForReportMetricIDsParams, reqEditors ...api.RequestEditorFn) (*api.ListReportMetricsForReportMetricIDsResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, reportID, metricID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListReportMetricsForReportMetricIDsWithResponse")
	}

	var r0 *api.ListReportMetricsForReportMetricIDsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListReportMetricsForReportMetricIDsParams, ...api.RequestEditorFn) (*api.ListReportMetricsForReportMetricIDsResponse, error)); ok {
		return rf(ctx, projectID, reportID, metricID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListReportMetricsForReportMetricIDsParams, ...api.RequestEditorFn) *api.ListReportMetricsForReportMetricIDsResponse); ok {
		r0 = rf(ctx, projectID, reportID, metricID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ListReportMetricsForReportMetricIDsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListReportMetricsForReportMetricIDsParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, reportID, metricID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_ListReportMetricsForReportMetricIDsWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListReportMetricsForReportMetricIDsWithResponse'
type ClientWithResponsesInterface_ListReportMetricsForReportMetricIDsWithResponse_Call struct {
	*mock.Call
}

// ListReportMetricsForReportMetricIDsWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - reportID uuid.UUID
//   - metricID []uuid.UUID
//   - params *api.ListReportMetricsForReportMetricIDsParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) ListReportMetricsForReportMetricIDsWithResponse(ctx interface{}, projectID interface{}, reportID interface{}, metricID interface{}, params interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_ListReportMetricsForReportMetricIDsWithResponse_Call {
	return &ClientWithResponsesInterface_ListReportMetricsForReportMetricIDsWithResponse_Call{Call: _e.mock.On("ListReportMetricsForReportMetricIDsWithResponse",
		append([]interface{}{ctx, projectID, reportID, metricID, params}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_ListReportMetricsForReportMetricIDsWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, reportID uuid.UUID, metricID []uuid.UUID, params *api.ListReportMetricsForReportMetricIDsParams, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_ListReportMetricsForReportMetricIDsWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].([]uuid.UUID), args[4].(*api.ListReportMetricsForReportMetricIDsParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_ListReportMetricsForReportMetricIDsWithResponse_Call) Return(_a0 *api.ListReportMetricsForReportMetricIDsResponse, _a1 error) *ClientWithResponsesInterface_ListReportMetricsForReportMetricIDsWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_ListReportMetricsForReportMetricIDsWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListReportMetricsForReportMetricIDsParams, ...api.RequestEditorFn) (*api.ListReportMetricsForReportMetricIDsResponse, error)) *ClientWithResponsesInterface_ListReportMetricsForReportMetricIDsWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// ListReportMetricsWithResponse provides a mock function with given fields: ctx, projectID, reportID, params, reqEditors
func (_m *ClientWithResponsesInterface) ListReportMetricsWithResponse(ctx context.Context, projectID uuid.UUID, reportID uuid.UUID, params *api.ListReportMetricsParams, reqEditors ...api.RequestEditorFn) (*api.ListReportMetricsResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, reportID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListReportMetricsWithResponse")
	}

	var r0 *api.ListReportMetricsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, *api.ListReportMetricsParams, ...api.RequestEditorFn) (*api.ListReportMetricsResponse, error)); ok {
		return rf(ctx, projectID, reportID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, *api.ListReportMetricsParams, ...api.RequestEditorFn) *api.ListReportMetricsResponse); ok {
		r0 = rf(ctx, projectID, reportID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ListReportMetricsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, *api.ListReportMetricsParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, reportID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_ListReportMetricsWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListReportMetricsWithResponse'
type ClientWithResponsesInterface_ListReportMetricsWithResponse_Call struct {
	*mock.Call
}

// ListReportMetricsWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - reportID uuid.UUID
//   - params *api.ListReportMetricsParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) ListReportMetricsWithResponse(ctx interface{}, projectID interface{}, reportID interface{}, params interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_ListReportMetricsWithResponse_Call {
	return &ClientWithResponsesInterface_ListReportMetricsWithResponse_Call{Call: _e.mock.On("ListReportMetricsWithResponse",
		append([]interface{}{ctx, projectID, reportID, params}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_ListReportMetricsWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, reportID uuid.UUID, params *api.ListReportMetricsParams, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_ListReportMetricsWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(*api.ListReportMetricsParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_ListReportMetricsWithResponse_Call) Return(_a0 *api.ListReportMetricsResponse, _a1 error) *ClientWithResponsesInterface_ListReportMetricsWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_ListReportMetricsWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, *api.ListReportMetricsParams, ...api.RequestEditorFn) (*api.ListReportMetricsResponse, error)) *ClientWithResponsesInterface_ListReportMetricsWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// ListReportsWithResponse provides a mock function with given fields: ctx, projectID, params, reqEditors
func (_m *ClientWithResponsesInterface) ListReportsWithResponse(ctx context.Context, projectID uuid.UUID, params *api.ListReportsParams, reqEditors ...api.RequestEditorFn) (*api.ListReportsResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListReportsWithResponse")
	}

	var r0 *api.ListReportsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, *api.ListReportsParams, ...api.RequestEditorFn) (*api.ListReportsResponse, error)); ok {
		return rf(ctx, projectID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, *api.ListReportsParams, ...api.RequestEditorFn) *api.ListReportsResponse); ok {
		r0 = rf(ctx, projectID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ListReportsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, *api.ListReportsParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_ListReportsWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListReportsWithResponse'
type ClientWithResponsesInterface_ListReportsWithResponse_Call struct {
	*mock.Call
}

// ListReportsWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - params *api.ListReportsParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) ListReportsWithResponse(ctx interface{}, projectID interface{}, params interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_ListReportsWithResponse_Call {
	return &ClientWithResponsesInterface_ListReportsWithResponse_Call{Call: _e.mock.On("ListReportsWithResponse",
		append([]interface{}{ctx, projectID, params}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_ListReportsWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, params *api.ListReportsParams, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_ListReportsWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(*api.ListReportsParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_ListReportsWithResponse_Call) Return(_a0 *api.ListReportsResponse, _a1 error) *ClientWithResponsesInterface_ListReportsWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_ListReportsWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, *api.ListReportsParams, ...api.RequestEditorFn) (*api.ListReportsResponse, error)) *ClientWithResponsesInterface_ListReportsWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// ListServiceProfilesWithResponse provides a mock function with given fields: ctx, projectID, reqEditors
func (_m *ClientWithResponsesInterface) ListServiceProfilesWithResponse(ctx context.Context, projectID uuid.UUID, reqEditors ...api.RequestEditorFn) (*api.ListServiceProfilesResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListServiceProfilesWithResponse")
	}

	var r0 *api.ListServiceProfilesResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, ...api.RequestEditorFn) (*api.ListServiceProfilesResponse, error)); ok {
		return rf(ctx, projectID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, ...api.RequestEditorFn) *api.ListServiceProfilesResponse); ok {
		r0 = rf(ctx, projectID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ListServiceProfilesResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_ListServiceProfilesWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListServiceProfilesWithResponse'
type ClientWithResponsesInterface_ListServiceProfilesWithResponse_Call struct {
	*mock.Call
}

// ListServiceProfilesWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) ListServiceProfilesWithResponse(ctx interface{}, projectID interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_ListServiceProfilesWithResponse_Call {
	return &ClientWithResponsesInterface_ListServiceProfilesWithResponse_Call{Call: _e.mock.On("ListServiceProfilesWithResponse",
		append([]interface{}{ctx, projectID}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_ListServiceProfilesWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_ListServiceProfilesWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_ListServiceProfilesWithResponse_Call) Return(_a0 *api.ListServiceProfilesResponse, _a1 error) *ClientWithResponsesInterface_ListServiceProfilesWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_ListServiceProfilesWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, ...api.RequestEditorFn) (*api.ListServiceProfilesResponse, error)) *ClientWithResponsesInterface_ListServiceProfilesWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// ListSweepAccountsWithResponse provides a mock function with given fields: ctx, projectID, reqEditors
func (_m *ClientWithResponsesInterface) ListSweepAccountsWithResponse(ctx context.Context, projectID uuid.UUID, reqEditors ...api.RequestEditorFn) (*api.ListSweepAccountsResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListSweepAccountsWithResponse")
	}

	var r0 *api.ListSweepAccountsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, ...api.RequestEditorFn) (*api.ListSweepAccountsResponse, error)); ok {
		return rf(ctx, projectID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, ...api.RequestEditorFn) *api.ListSweepAccountsResponse); ok {
		r0 = rf(ctx, projectID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ListSweepAccountsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_ListSweepAccountsWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListSweepAccountsWithResponse'
type ClientWithResponsesInterface_ListSweepAccountsWithResponse_Call struct {
	*mock.Call
}

// ListSweepAccountsWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) ListSweepAccountsWithResponse(ctx interface{}, projectID interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_ListSweepAccountsWithResponse_Call {
	return &ClientWithResponsesInterface_ListSweepAccountsWithResponse_Call{Call: _e.mock.On("ListSweepAccountsWithResponse",
		append([]interface{}{ctx, projectID}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_ListSweepAccountsWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_ListSweepAccountsWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_ListSweepAccountsWithResponse_Call) Return(_a0 *api.ListSweepAccountsResponse, _a1 error) *ClientWithResponsesInterface_ListSweepAccountsWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_ListSweepAccountsWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, ...api.RequestEditorFn) (*api.ListSweepAccountsResponse, error)) *ClientWithResponsesInterface_ListSweepAccountsWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// ListSystemsWithResponse provides a mock function with given fields: ctx, projectID, params, reqEditors
func (_m *ClientWithResponsesInterface) ListSystemsWithResponse(ctx context.Context, projectID uuid.UUID, params *api.ListSystemsParams, reqEditors ...api.RequestEditorFn) (*api.ListSystemsResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListSystemsWithResponse")
	}

	var r0 *api.ListSystemsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, *api.ListSystemsParams, ...api.RequestEditorFn) (*api.ListSystemsResponse, error)); ok {
		return rf(ctx, projectID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, *api.ListSystemsParams, ...api.RequestEditorFn) *api.ListSystemsResponse); ok {
		r0 = rf(ctx, projectID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ListSystemsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, *api.ListSystemsParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_ListSystemsWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListSystemsWithResponse'
type ClientWithResponsesInterface_ListSystemsWithResponse_Call struct {
	*mock.Call
}

// ListSystemsWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - params *api.ListSystemsParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) ListSystemsWithResponse(ctx interface{}, projectID interface{}, params interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_ListSystemsWithResponse_Call {
	return &ClientWithResponsesInterface_ListSystemsWithResponse_Call{Call: _e.mock.On("ListSystemsWithResponse",
		append([]interface{}{ctx, projectID, params}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_ListSystemsWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, params *api.ListSystemsParams, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_ListSystemsWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(*api.ListSystemsParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_ListSystemsWithResponse_Call) Return(_a0 *api.ListSystemsResponse, _a1 error) *ClientWithResponsesInterface_ListSystemsWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_ListSystemsWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, *api.ListSystemsParams, ...api.RequestEditorFn) (*api.ListSystemsResponse, error)) *ClientWithResponsesInterface_ListSystemsWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// ListTagsForBatchMetricsWithResponse provides a mock function with given fields: ctx, projectID, batchID, metricID, params, reqEditors
func (_m *ClientWithResponsesInterface) ListTagsForBatchMetricsWithResponse(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, metricID []uuid.UUID, params *api.ListTagsForBatchMetricsParams, reqEditors ...api.RequestEditorFn) (*api.ListTagsForBatchMetricsResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, batchID, metricID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTagsForBatchMetricsWithResponse")
	}

	var r0 *api.ListTagsForBatchMetricsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListTagsForBatchMetricsParams, ...api.RequestEditorFn) (*api.ListTagsForBatchMetricsResponse, error)); ok {
		return rf(ctx, projectID, batchID, metricID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListTagsForBatchMetricsParams, ...api.RequestEditorFn) *api.ListTagsForBatchMetricsResponse); ok {
		r0 = rf(ctx, projectID, batchID, metricID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ListTagsForBatchMetricsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListTagsForBatchMetricsParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, batchID, metricID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_ListTagsForBatchMetricsWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListTagsForBatchMetricsWithResponse'
type ClientWithResponsesInterface_ListTagsForBatchMetricsWithResponse_Call struct {
	*mock.Call
}

// ListTagsForBatchMetricsWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - batchID uuid.UUID
//   - metricID []uuid.UUID
//   - params *api.ListTagsForBatchMetricsParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) ListTagsForBatchMetricsWithResponse(ctx interface{}, projectID interface{}, batchID interface{}, metricID interface{}, params interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_ListTagsForBatchMetricsWithResponse_Call {
	return &ClientWithResponsesInterface_ListTagsForBatchMetricsWithResponse_Call{Call: _e.mock.On("ListTagsForBatchMetricsWithResponse",
		append([]interface{}{ctx, projectID, batchID, metricID, params}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_ListTagsForBatchMetricsWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, metricID []uuid.UUID, params *api.ListTagsForBatchMetricsParams, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_ListTagsForBatchMetricsWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].([]uuid.UUID), args[4].(*api.ListTagsForBatchMetricsParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_ListTagsForBatchMetricsWithResponse_Call) Return(_a0 *api.ListTagsForBatchMetricsResponse, _a1 error) *ClientWithResponsesInterface_ListTagsForBatchMetricsWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_ListTagsForBatchMetricsWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListTagsForBatchMetricsParams, ...api.RequestEditorFn) (*api.ListTagsForBatchMetricsResponse, error)) *ClientWithResponsesInterface_ListTagsForBatchMetricsWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// ListTagsForJobMetricsWithResponse provides a mock function with given fields: ctx, projectID, batchID, jobID, metricID, params, reqEditors
func (_m *ClientWithResponsesInterface) ListTagsForJobMetricsWithResponse(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, jobID uuid.UUID, metricID []uuid.UUID, params *api.ListTagsForJobMetricsParams, reqEditors ...api.RequestEditorFn) (*api.ListTagsForJobMetricsResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, batchID, jobID, metricID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTagsForJobMetricsWithResponse")
	}

	var r0 *api.ListTagsForJobMetricsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListTagsForJobMetricsParams, ...api.RequestEditorFn) (*api.ListTagsForJobMetricsResponse, error)); ok {
		return rf(ctx, projectID, batchID, jobID, metricID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListTagsForJobMetricsParams, ...api.RequestEditorFn) *api.ListTagsForJobMetricsResponse); ok {
		r0 = rf(ctx, projectID, batchID, jobID, metricID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ListTagsForJobMetricsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListTagsForJobMetricsParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, batchID, jobID, metricID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_ListTagsForJobMetricsWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListTagsForJobMetricsWithResponse'
type ClientWithResponsesInterface_ListTagsForJobMetricsWithResponse_Call struct {
	*mock.Call
}

// ListTagsForJobMetricsWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - batchID uuid.UUID
//   - jobID uuid.UUID
//   - metricID []uuid.UUID
//   - params *api.ListTagsForJobMetricsParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) ListTagsForJobMetricsWithResponse(ctx interface{}, projectID interface{}, batchID interface{}, jobID interface{}, metricID interface{}, params interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_ListTagsForJobMetricsWithResponse_Call {
	return &ClientWithResponsesInterface_ListTagsForJobMetricsWithResponse_Call{Call: _e.mock.On("ListTagsForJobMetricsWithResponse",
		append([]interface{}{ctx, projectID, batchID, jobID, metricID, params}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_ListTagsForJobMetricsWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, jobID uuid.UUID, metricID []uuid.UUID, params *api.ListTagsForJobMetricsParams, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_ListTagsForJobMetricsWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-6)
		for i, a := range args[6:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(uuid.UUID), args[4].([]uuid.UUID), args[5].(*api.ListTagsForJobMetricsParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_ListTagsForJobMetricsWithResponse_Call) Return(_a0 *api.ListTagsForJobMetricsResponse, _a1 error) *ClientWithResponsesInterface_ListTagsForJobMetricsWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_ListTagsForJobMetricsWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListTagsForJobMetricsParams, ...api.RequestEditorFn) (*api.ListTagsForJobMetricsResponse, error)) *ClientWithResponsesInterface_ListTagsForJobMetricsWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// ListTagsForReportMetricsWithResponse provides a mock function with given fields: ctx, projectID, reportID, metricID, params, reqEditors
func (_m *ClientWithResponsesInterface) ListTagsForReportMetricsWithResponse(ctx context.Context, projectID uuid.UUID, reportID uuid.UUID, metricID []uuid.UUID, params *api.ListTagsForReportMetricsParams, reqEditors ...api.RequestEditorFn) (*api.ListTagsForReportMetricsResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, reportID, metricID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTagsForReportMetricsWithResponse")
	}

	var r0 *api.ListTagsForReportMetricsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListTagsForReportMetricsParams, ...api.RequestEditorFn) (*api.ListTagsForReportMetricsResponse, error)); ok {
		return rf(ctx, projectID, reportID, metricID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListTagsForReportMetricsParams, ...api.RequestEditorFn) *api.ListTagsForReportMetricsResponse); ok {
		r0 = rf(ctx, projectID, reportID, metricID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ListTagsForReportMetricsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListTagsForReportMetricsParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, reportID, metricID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_ListTagsForReportMetricsWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListTagsForReportMetricsWithResponse'
type ClientWithResponsesInterface_ListTagsForReportMetricsWithResponse_Call struct {
	*mock.Call
}

// ListTagsForReportMetricsWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - reportID uuid.UUID
//   - metricID []uuid.UUID
//   - params *api.ListTagsForReportMetricsParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) ListTagsForReportMetricsWithResponse(ctx interface{}, projectID interface{}, reportID interface{}, metricID interface{}, params interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_ListTagsForReportMetricsWithResponse_Call {
	return &ClientWithResponsesInterface_ListTagsForReportMetricsWithResponse_Call{Call: _e.mock.On("ListTagsForReportMetricsWithResponse",
		append([]interface{}{ctx, projectID, reportID, metricID, params}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_ListTagsForReportMetricsWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, reportID uuid.UUID, metricID []uuid.UUID, params *api.ListTagsForReportMetricsParams, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_ListTagsForReportMetricsWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].([]uuid.UUID), args[4].(*api.ListTagsForReportMetricsParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_ListTagsForReportMetricsWithResponse_Call) Return(_a0 *api.ListTagsForReportMetricsResponse, _a1 error) *ClientWithResponsesInterface_ListTagsForReportMetricsWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_ListTagsForReportMetricsWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, []uuid.UUID, *api.ListTagsForReportMetricsParams, ...api.RequestEditorFn) (*api.ListTagsForReportMetricsResponse, error)) *ClientWithResponsesInterface_ListTagsForReportMetricsWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// ListTestSuiteRevisionsWithResponse provides a mock function with given fields: ctx, projectID, testSuiteID, params, reqEditors
func (_m *ClientWithResponsesInterface) ListTestSuiteRevisionsWithResponse(ctx context.Context, projectID uuid.UUID, testSuiteID uuid.UUID, params *api.ListTestSuiteRevisionsParams, reqEditors ...api.RequestEditorFn) (*api.ListTestSuiteRevisionsResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, testSuiteID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTestSuiteRevisionsWithResponse")
	}

	var r0 *api.ListTestSuiteRevisionsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, *api.ListTestSuiteRevisionsParams, ...api.RequestEditorFn) (*api.ListTestSuiteRevisionsResponse, error)); ok {
		return rf(ctx, projectID, testSuiteID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, *api.ListTestSuiteRevisionsParams, ...api.RequestEditorFn) *api.ListTestSuiteRevisionsResponse); ok {
		r0 = rf(ctx, projectID, testSuiteID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ListTestSuiteRevisionsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, *api.ListTestSuiteRevisionsParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, testSuiteID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_ListTestSuiteRevisionsWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListTestSuiteRevisionsWithResponse'
type ClientWithResponsesInterface_ListTestSuiteRevisionsWithResponse_Call struct {
	*mock.Call
}

// ListTestSuiteRevisionsWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - testSuiteID uuid.UUID
//   - params *api.ListTestSuiteRevisionsParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) ListTestSuiteRevisionsWithResponse(ctx interface{}, projectID interface{}, testSuiteID interface{}, params interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_ListTestSuiteRevisionsWithResponse_Call {
	return &ClientWithResponsesInterface_ListTestSuiteRevisionsWithResponse_Call{Call: _e.mock.On("ListTestSuiteRevisionsWithResponse",
		append([]interface{}{ctx, projectID, testSuiteID, params}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_ListTestSuiteRevisionsWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, testSuiteID uuid.UUID, params *api.ListTestSuiteRevisionsParams, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_ListTestSuiteRevisionsWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(*api.ListTestSuiteRevisionsParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_ListTestSuiteRevisionsWithResponse_Call) Return(_a0 *api.ListTestSuiteRevisionsResponse, _a1 error) *ClientWithResponsesInterface_ListTestSuiteRevisionsWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_ListTestSuiteRevisionsWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, *api.ListTestSuiteRevisionsParams, ...api.RequestEditorFn) (*api.ListTestSuiteRevisionsResponse, error)) *ClientWithResponsesInterface_ListTestSuiteRevisionsWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// ListTestSuitesWithResponse provides a mock function with given fields: ctx, projectID, params, reqEditors
func (_m *ClientWithResponsesInterface) ListTestSuitesWithResponse(ctx context.Context, projectID uuid.UUID, params *api.ListTestSuitesParams, reqEditors ...api.RequestEditorFn) (*api.ListTestSuitesResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTestSuitesWithResponse")
	}

	var r0 *api.ListTestSuitesResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, *api.ListTestSuitesParams, ...api.RequestEditorFn) (*api.ListTestSuitesResponse, error)); ok {
		return rf(ctx, projectID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, *api.ListTestSuitesParams, ...api.RequestEditorFn) *api.ListTestSuitesResponse); ok {
		r0 = rf(ctx, projectID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ListTestSuitesResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, *api.ListTestSuitesParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_ListTestSuitesWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListTestSuitesWithResponse'
type ClientWithResponsesInterface_ListTestSuitesWithResponse_Call struct {
	*mock.Call
}

// ListTestSuitesWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - params *api.ListTestSuitesParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) ListTestSuitesWithResponse(ctx interface{}, projectID interface{}, params interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_ListTestSuitesWithResponse_Call {
	return &ClientWithResponsesInterface_ListTestSuitesWithResponse_Call{Call: _e.mock.On("ListTestSuitesWithResponse",
		append([]interface{}{ctx, projectID, params}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_ListTestSuitesWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, params *api.ListTestSuitesParams, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_ListTestSuitesWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(*api.ListTestSuitesParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_ListTestSuitesWithResponse_Call) Return(_a0 *api.ListTestSuitesResponse, _a1 error) *ClientWithResponsesInterface_ListTestSuitesWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_ListTestSuitesWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, *api.ListTestSuitesParams, ...api.RequestEditorFn) (*api.ListTestSuitesResponse, error)) *ClientWithResponsesInterface_ListTestSuitesWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// ListViewSessionsWithResponse provides a mock function with given fields: ctx, params, reqEditors
func (_m *ClientWithResponsesInterface) ListViewSessionsWithResponse(ctx context.Context, params *api.ListViewSessionsParams, reqEditors ...api.RequestEditorFn) (*api.ListViewSessionsResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListViewSessionsWithResponse")
	}

	var r0 *api.ListViewSessionsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *api.ListViewSessionsParams, ...api.RequestEditorFn) (*api.ListViewSessionsResponse, error)); ok {
		return rf(ctx, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *api.ListViewSessionsParams, ...api.RequestEditorFn) *api.ListViewSessionsResponse); ok {
		r0 = rf(ctx, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ListViewSessionsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *api.ListViewSessionsParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_ListViewSessionsWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListViewSessionsWithResponse'
type ClientWithResponsesInterface_ListViewSessionsWithResponse_Call struct {
	*mock.Call
}

// ListViewSessionsWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - params *api.ListViewSessionsParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) ListViewSessionsWithResponse(ctx interface{}, params interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_ListViewSessionsWithResponse_Call {
	return &ClientWithResponsesInterface_ListViewSessionsWithResponse_Call{Call: _e.mock.On("ListViewSessionsWithResponse",
		append([]interface{}{ctx, params}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_ListViewSessionsWithResponse_Call) Run(run func(ctx context.Context, params *api.ListViewSessionsParams, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_ListViewSessionsWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(*api.ListViewSessionsParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_ListViewSessionsWithResponse_Call) Return(_a0 *api.ListViewSessionsResponse, _a1 error) *ClientWithResponsesInterface_ListViewSessionsWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_ListViewSessionsWithResponse_Call) RunAndReturn(run func(context.Context, *api.ListViewSessionsParams, ...api.RequestEditorFn) (*api.ListViewSessionsResponse, error)) *ClientWithResponsesInterface_ListViewSessionsWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// ListWorkflowRunsWithResponse provides a mock function with given fields: ctx, projectID, workflowID, params, reqEditors
func (_m *ClientWithResponsesInterface) ListWorkflowRunsWithResponse(ctx context.Context, projectID uuid.UUID, workflowID uuid.UUID, params *api.ListWorkflowRunsParams, reqEditors ...api.RequestEditorFn) (*api.ListWorkflowRunsResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, workflowID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListWorkflowRunsWithResponse")
	}

	var r0 *api.ListWorkflowRunsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, *api.ListWorkflowRunsParams, ...api.RequestEditorFn) (*api.ListWorkflowRunsResponse, error)); ok {
		return rf(ctx, projectID, workflowID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, *api.ListWorkflowRunsParams, ...api.RequestEditorFn) *api.ListWorkflowRunsResponse); ok {
		r0 = rf(ctx, projectID, workflowID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ListWorkflowRunsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, *api.ListWorkflowRunsParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, workflowID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_ListWorkflowRunsWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListWorkflowRunsWithResponse'
type ClientWithResponsesInterface_ListWorkflowRunsWithResponse_Call struct {
	*mock.Call
}

// ListWorkflowRunsWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - workflowID uuid.UUID
//   - params *api.ListWorkflowRunsParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) ListWorkflowRunsWithResponse(ctx interface{}, projectID interface{}, workflowID interface{}, params interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_ListWorkflowRunsWithResponse_Call {
	return &ClientWithResponsesInterface_ListWorkflowRunsWithResponse_Call{Call: _e.mock.On("ListWorkflowRunsWithResponse",
		append([]interface{}{ctx, projectID, workflowID, params}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_ListWorkflowRunsWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, workflowID uuid.UUID, params *api.ListWorkflowRunsParams, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_ListWorkflowRunsWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(*api.ListWorkflowRunsParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_ListWorkflowRunsWithResponse_Call) Return(_a0 *api.ListWorkflowRunsResponse, _a1 error) *ClientWithResponsesInterface_ListWorkflowRunsWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_ListWorkflowRunsWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, *api.ListWorkflowRunsParams, ...api.RequestEditorFn) (*api.ListWorkflowRunsResponse, error)) *ClientWithResponsesInterface_ListWorkflowRunsWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// ListWorkflowSuitesWithResponse provides a mock function with given fields: ctx, projectID, workflowID, reqEditors
func (_m *ClientWithResponsesInterface) ListWorkflowSuitesWithResponse(ctx context.Context, projectID uuid.UUID, workflowID uuid.UUID, reqEditors ...api.RequestEditorFn) (*api.ListWorkflowSuitesResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, workflowID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListWorkflowSuitesWithResponse")
	}

	var r0 *api.ListWorkflowSuitesResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*api.ListWorkflowSuitesResponse, error)); ok {
		return rf(ctx, projectID, workflowID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) *api.ListWorkflowSuitesResponse); ok {
		r0 = rf(ctx, projectID, workflowID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ListWorkflowSuitesResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, workflowID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_ListWorkflowSuitesWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListWorkflowSuitesWithResponse'
type ClientWithResponsesInterface_ListWorkflowSuitesWithResponse_Call struct {
	*mock.Call
}

// ListWorkflowSuitesWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - workflowID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) ListWorkflowSuitesWithResponse(ctx interface{}, projectID interface{}, workflowID interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_ListWorkflowSuitesWithResponse_Call {
	return &ClientWithResponsesInterface_ListWorkflowSuitesWithResponse_Call{Call: _e.mock.On("ListWorkflowSuitesWithResponse",
		append([]interface{}{ctx, projectID, workflowID}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_ListWorkflowSuitesWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, workflowID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_ListWorkflowSuitesWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_ListWorkflowSuitesWithResponse_Call) Return(_a0 *api.ListWorkflowSuitesResponse, _a1 error) *ClientWithResponsesInterface_ListWorkflowSuitesWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_ListWorkflowSuitesWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*api.ListWorkflowSuitesResponse, error)) *ClientWithResponsesInterface_ListWorkflowSuitesWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// ListWorkflowsWithResponse provides a mock function with given fields: ctx, projectID, params, reqEditors
func (_m *ClientWithResponsesInterface) ListWorkflowsWithResponse(ctx context.Context, projectID uuid.UUID, params *api.ListWorkflowsParams, reqEditors ...api.RequestEditorFn) (*api.ListWorkflowsResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListWorkflowsWithResponse")
	}

	var r0 *api.ListWorkflowsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, *api.ListWorkflowsParams, ...api.RequestEditorFn) (*api.ListWorkflowsResponse, error)); ok {
		return rf(ctx, projectID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, *api.ListWorkflowsParams, ...api.RequestEditorFn) *api.ListWorkflowsResponse); ok {
		r0 = rf(ctx, projectID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ListWorkflowsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, *api.ListWorkflowsParams, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_ListWorkflowsWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListWorkflowsWithResponse'
type ClientWithResponsesInterface_ListWorkflowsWithResponse_Call struct {
	*mock.Call
}

// ListWorkflowsWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - params *api.ListWorkflowsParams
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) ListWorkflowsWithResponse(ctx interface{}, projectID interface{}, params interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_ListWorkflowsWithResponse_Call {
	return &ClientWithResponsesInterface_ListWorkflowsWithResponse_Call{Call: _e.mock.On("ListWorkflowsWithResponse",
		append([]interface{}{ctx, projectID, params}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_ListWorkflowsWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, params *api.ListWorkflowsParams, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_ListWorkflowsWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(*api.ListWorkflowsParams), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_ListWorkflowsWithResponse_Call) Return(_a0 *api.ListWorkflowsResponse, _a1 error) *ClientWithResponsesInterface_ListWorkflowsWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_ListWorkflowsWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, *api.ListWorkflowsParams, ...api.RequestEditorFn) (*api.ListWorkflowsResponse, error)) *ClientWithResponsesInterface_ListWorkflowsWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveExperienceTagFromExperienceWithResponse provides a mock function with given fields: ctx, projectID, experienceTagID, experienceID, reqEditors
func (_m *ClientWithResponsesInterface) RemoveExperienceTagFromExperienceWithResponse(ctx context.Context, projectID uuid.UUID, experienceTagID uuid.UUID, experienceID uuid.UUID, reqEditors ...api.RequestEditorFn) (*api.RemoveExperienceTagFromExperienceResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, experienceTagID, experienceID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RemoveExperienceTagFromExperienceWithResponse")
	}

	var r0 *api.RemoveExperienceTagFromExperienceResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*api.RemoveExperienceTagFromExperienceResponse, error)); ok {
		return rf(ctx, projectID, experienceTagID, experienceID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) *api.RemoveExperienceTagFromExperienceResponse); ok {
		r0 = rf(ctx, projectID, experienceTagID, experienceID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.RemoveExperienceTagFromExperienceResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, experienceTagID, experienceID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_RemoveExperienceTagFromExperienceWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveExperienceTagFromExperienceWithResponse'
type ClientWithResponsesInterface_RemoveExperienceTagFromExperienceWithResponse_Call struct {
	*mock.Call
}

// RemoveExperienceTagFromExperienceWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - experienceTagID uuid.UUID
//   - experienceID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) RemoveExperienceTagFromExperienceWithResponse(ctx interface{}, projectID interface{}, experienceTagID interface{}, experienceID interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_RemoveExperienceTagFromExperienceWithResponse_Call {
	return &ClientWithResponsesInterface_RemoveExperienceTagFromExperienceWithResponse_Call{Call: _e.mock.On("RemoveExperienceTagFromExperienceWithResponse",
		append([]interface{}{ctx, projectID, experienceTagID, experienceID}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_RemoveExperienceTagFromExperienceWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, experienceTagID uuid.UUID, experienceID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_RemoveExperienceTagFromExperienceWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_RemoveExperienceTagFromExperienceWithResponse_Call) Return(_a0 *api.RemoveExperienceTagFromExperienceResponse, _a1 error) *ClientWithResponsesInterface_RemoveExperienceTagFromExperienceWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_RemoveExperienceTagFromExperienceWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*api.RemoveExperienceTagFromExperienceResponse, error)) *ClientWithResponsesInterface_RemoveExperienceTagFromExperienceWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveExperiencesFromTestSuiteWithBodyWithResponse provides a mock function with given fields: ctx, projectID, testSuiteID, contentType, body, reqEditors
func (_m *ClientWithResponsesInterface) RemoveExperiencesFromTestSuiteWithBodyWithResponse(ctx context.Context, projectID uuid.UUID, testSuiteID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn) (*api.RemoveExperiencesFromTestSuiteResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, testSuiteID, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RemoveExperiencesFromTestSuiteWithBodyWithResponse")
	}

	var r0 *api.RemoveExperiencesFromTestSuiteResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*api.RemoveExperiencesFromTestSuiteResponse, error)); ok {
		return rf(ctx, projectID, testSuiteID, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) *api.RemoveExperiencesFromTestSuiteResponse); ok {
		r0 = rf(ctx, projectID, testSuiteID, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.RemoveExperiencesFromTestSuiteResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, testSuiteID, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_RemoveExperiencesFromTestSuiteWithBodyWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveExperiencesFromTestSuiteWithBodyWithResponse'
type ClientWithResponsesInterface_RemoveExperiencesFromTestSuiteWithBodyWithResponse_Call struct {
	*mock.Call
}

// RemoveExperiencesFromTestSuiteWithBodyWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - testSuiteID uuid.UUID
//   - contentType string
//   - body io.Reader
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) RemoveExperiencesFromTestSuiteWithBodyWithResponse(ctx interface{}, projectID interface{}, testSuiteID interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_RemoveExperiencesFromTestSuiteWithBodyWithResponse_Call {
	return &ClientWithResponsesInterface_RemoveExperiencesFromTestSuiteWithBodyWithResponse_Call{Call: _e.mock.On("RemoveExperiencesFromTestSuiteWithBodyWithResponse",
		append([]interface{}{ctx, projectID, testSuiteID, contentType, body}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_RemoveExperiencesFromTestSuiteWithBodyWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, testSuiteID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_RemoveExperiencesFromTestSuiteWithBodyWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(string), args[4].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_RemoveExperiencesFromTestSuiteWithBodyWithResponse_Call) Return(_a0 *api.RemoveExperiencesFromTestSuiteResponse, _a1 error) *ClientWithResponsesInterface_RemoveExperiencesFromTestSuiteWithBodyWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_RemoveExperiencesFromTestSuiteWithBodyWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*api.RemoveExperiencesFromTestSuiteResponse, error)) *ClientWithResponsesInterface_RemoveExperiencesFromTestSuiteWithBodyWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveExperiencesFromTestSuiteWithResponse provides a mock function with given fields: ctx, projectID, testSuiteID, body, reqEditors
func (_m *ClientWithResponsesInterface) RemoveExperiencesFromTestSuiteWithResponse(ctx context.Context, projectID uuid.UUID, testSuiteID uuid.UUID, body api.SelectExperiencesInput, reqEditors ...api.RequestEditorFn) (*api.RemoveExperiencesFromTestSuiteResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, testSuiteID, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RemoveExperiencesFromTestSuiteWithResponse")
	}

	var r0 *api.RemoveExperiencesFromTestSuiteResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, api.SelectExperiencesInput, ...api.RequestEditorFn) (*api.RemoveExperiencesFromTestSuiteResponse, error)); ok {
		return rf(ctx, projectID, testSuiteID, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, api.SelectExperiencesInput, ...api.RequestEditorFn) *api.RemoveExperiencesFromTestSuiteResponse); ok {
		r0 = rf(ctx, projectID, testSuiteID, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.RemoveExperiencesFromTestSuiteResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, api.SelectExperiencesInput, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, testSuiteID, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_RemoveExperiencesFromTestSuiteWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveExperiencesFromTestSuiteWithResponse'
type ClientWithResponsesInterface_RemoveExperiencesFromTestSuiteWithResponse_Call struct {
	*mock.Call
}

// RemoveExperiencesFromTestSuiteWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - testSuiteID uuid.UUID
//   - body api.SelectExperiencesInput
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) RemoveExperiencesFromTestSuiteWithResponse(ctx interface{}, projectID interface{}, testSuiteID interface{}, body interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_RemoveExperiencesFromTestSuiteWithResponse_Call {
	return &ClientWithResponsesInterface_RemoveExperiencesFromTestSuiteWithResponse_Call{Call: _e.mock.On("RemoveExperiencesFromTestSuiteWithResponse",
		append([]interface{}{ctx, projectID, testSuiteID, body}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_RemoveExperiencesFromTestSuiteWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, testSuiteID uuid.UUID, body api.SelectExperiencesInput, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_RemoveExperiencesFromTestSuiteWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(api.SelectExperiencesInput), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_RemoveExperiencesFromTestSuiteWithResponse_Call) Return(_a0 *api.RemoveExperiencesFromTestSuiteResponse, _a1 error) *ClientWithResponsesInterface_RemoveExperiencesFromTestSuiteWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_RemoveExperiencesFromTestSuiteWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, api.SelectExperiencesInput, ...api.RequestEditorFn) (*api.RemoveExperiencesFromTestSuiteResponse, error)) *ClientWithResponsesInterface_RemoveExperiencesFromTestSuiteWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveSystemFromExperienceWithResponse provides a mock function with given fields: ctx, projectID, systemID, experienceID, reqEditors
func (_m *ClientWithResponsesInterface) RemoveSystemFromExperienceWithResponse(ctx context.Context, projectID uuid.UUID, systemID uuid.UUID, experienceID uuid.UUID, reqEditors ...api.RequestEditorFn) (*api.RemoveSystemFromExperienceResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, systemID, experienceID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RemoveSystemFromExperienceWithResponse")
	}

	var r0 *api.RemoveSystemFromExperienceResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*api.RemoveSystemFromExperienceResponse, error)); ok {
		return rf(ctx, projectID, systemID, experienceID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) *api.RemoveSystemFromExperienceResponse); ok {
		r0 = rf(ctx, projectID, systemID, experienceID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.RemoveSystemFromExperienceResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, systemID, experienceID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_RemoveSystemFromExperienceWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveSystemFromExperienceWithResponse'
type ClientWithResponsesInterface_RemoveSystemFromExperienceWithResponse_Call struct {
	*mock.Call
}

// RemoveSystemFromExperienceWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - systemID uuid.UUID
//   - experienceID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) RemoveSystemFromExperienceWithResponse(ctx interface{}, projectID interface{}, systemID interface{}, experienceID interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_RemoveSystemFromExperienceWithResponse_Call {
	return &ClientWithResponsesInterface_RemoveSystemFromExperienceWithResponse_Call{Call: _e.mock.On("RemoveSystemFromExperienceWithResponse",
		append([]interface{}{ctx, projectID, systemID, experienceID}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_RemoveSystemFromExperienceWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, systemID uuid.UUID, experienceID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_RemoveSystemFromExperienceWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_RemoveSystemFromExperienceWithResponse_Call) Return(_a0 *api.RemoveSystemFromExperienceResponse, _a1 error) *ClientWithResponsesInterface_RemoveSystemFromExperienceWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_RemoveSystemFromExperienceWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*api.RemoveSystemFromExperienceResponse, error)) *ClientWithResponsesInterface_RemoveSystemFromExperienceWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveSystemFromMetricsBuildWithResponse provides a mock function with given fields: ctx, projectID, systemID, metricsBuildID, reqEditors
func (_m *ClientWithResponsesInterface) RemoveSystemFromMetricsBuildWithResponse(ctx context.Context, projectID uuid.UUID, systemID uuid.UUID, metricsBuildID uuid.UUID, reqEditors ...api.RequestEditorFn) (*api.RemoveSystemFromMetricsBuildResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, systemID, metricsBuildID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RemoveSystemFromMetricsBuildWithResponse")
	}

	var r0 *api.RemoveSystemFromMetricsBuildResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*api.RemoveSystemFromMetricsBuildResponse, error)); ok {
		return rf(ctx, projectID, systemID, metricsBuildID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) *api.RemoveSystemFromMetricsBuildResponse); ok {
		r0 = rf(ctx, projectID, systemID, metricsBuildID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.RemoveSystemFromMetricsBuildResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, systemID, metricsBuildID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_RemoveSystemFromMetricsBuildWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveSystemFromMetricsBuildWithResponse'
type ClientWithResponsesInterface_RemoveSystemFromMetricsBuildWithResponse_Call struct {
	*mock.Call
}

// RemoveSystemFromMetricsBuildWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - systemID uuid.UUID
//   - metricsBuildID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) RemoveSystemFromMetricsBuildWithResponse(ctx interface{}, projectID interface{}, systemID interface{}, metricsBuildID interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_RemoveSystemFromMetricsBuildWithResponse_Call {
	return &ClientWithResponsesInterface_RemoveSystemFromMetricsBuildWithResponse_Call{Call: _e.mock.On("RemoveSystemFromMetricsBuildWithResponse",
		append([]interface{}{ctx, projectID, systemID, metricsBuildID}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_RemoveSystemFromMetricsBuildWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, systemID uuid.UUID, metricsBuildID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_RemoveSystemFromMetricsBuildWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_RemoveSystemFromMetricsBuildWithResponse_Call) Return(_a0 *api.RemoveSystemFromMetricsBuildResponse, _a1 error) *ClientWithResponsesInterface_RemoveSystemFromMetricsBuildWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_RemoveSystemFromMetricsBuildWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*api.RemoveSystemFromMetricsBuildResponse, error)) *ClientWithResponsesInterface_RemoveSystemFromMetricsBuildWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveSystemsFromExperiencesWithBodyWithResponse provides a mock function with given fields: ctx, projectID, contentType, body, reqEditors
func (_m *ClientWithResponsesInterface) RemoveSystemsFromExperiencesWithBodyWithResponse(ctx context.Context, projectID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn) (*api.RemoveSystemsFromExperiencesResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RemoveSystemsFromExperiencesWithBodyWithResponse")
	}

	var r0 *api.RemoveSystemsFromExperiencesResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*api.RemoveSystemsFromExperiencesResponse, error)); ok {
		return rf(ctx, projectID, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) *api.RemoveSystemsFromExperiencesResponse); ok {
		r0 = rf(ctx, projectID, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.RemoveSystemsFromExperiencesResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_RemoveSystemsFromExperiencesWithBodyWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveSystemsFromExperiencesWithBodyWithResponse'
type ClientWithResponsesInterface_RemoveSystemsFromExperiencesWithBodyWithResponse_Call struct {
	*mock.Call
}

// RemoveSystemsFromExperiencesWithBodyWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - contentType string
//   - body io.Reader
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) RemoveSystemsFromExperiencesWithBodyWithResponse(ctx interface{}, projectID interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_RemoveSystemsFromExperiencesWithBodyWithResponse_Call {
	return &ClientWithResponsesInterface_RemoveSystemsFromExperiencesWithBodyWithResponse_Call{Call: _e.mock.On("RemoveSystemsFromExperiencesWithBodyWithResponse",
		append([]interface{}{ctx, projectID, contentType, body}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_RemoveSystemsFromExperiencesWithBodyWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_RemoveSystemsFromExperiencesWithBodyWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(string), args[3].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_RemoveSystemsFromExperiencesWithBodyWithResponse_Call) Return(_a0 *api.RemoveSystemsFromExperiencesResponse, _a1 error) *ClientWithResponsesInterface_RemoveSystemsFromExperiencesWithBodyWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_RemoveSystemsFromExperiencesWithBodyWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*api.RemoveSystemsFromExperiencesResponse, error)) *ClientWithResponsesInterface_RemoveSystemsFromExperiencesWithBodyWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveSystemsFromExperiencesWithResponse provides a mock function with given fields: ctx, projectID, body, reqEditors
func (_m *ClientWithResponsesInterface) RemoveSystemsFromExperiencesWithResponse(ctx context.Context, projectID uuid.UUID, body api.MutateSystemsToExperienceInput, reqEditors ...api.RequestEditorFn) (*api.RemoveSystemsFromExperiencesResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RemoveSystemsFromExperiencesWithResponse")
	}

	var r0 *api.RemoveSystemsFromExperiencesResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, api.MutateSystemsToExperienceInput, ...api.RequestEditorFn) (*api.RemoveSystemsFromExperiencesResponse, error)); ok {
		return rf(ctx, projectID, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, api.MutateSystemsToExperienceInput, ...api.RequestEditorFn) *api.RemoveSystemsFromExperiencesResponse); ok {
		r0 = rf(ctx, projectID, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.RemoveSystemsFromExperiencesResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, api.MutateSystemsToExperienceInput, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_RemoveSystemsFromExperiencesWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveSystemsFromExperiencesWithResponse'
type ClientWithResponsesInterface_RemoveSystemsFromExperiencesWithResponse_Call struct {
	*mock.Call
}

// RemoveSystemsFromExperiencesWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - body api.MutateSystemsToExperienceInput
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) RemoveSystemsFromExperiencesWithResponse(ctx interface{}, projectID interface{}, body interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_RemoveSystemsFromExperiencesWithResponse_Call {
	return &ClientWithResponsesInterface_RemoveSystemsFromExperiencesWithResponse_Call{Call: _e.mock.On("RemoveSystemsFromExperiencesWithResponse",
		append([]interface{}{ctx, projectID, body}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_RemoveSystemsFromExperiencesWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, body api.MutateSystemsToExperienceInput, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_RemoveSystemsFromExperiencesWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(api.MutateSystemsToExperienceInput), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_RemoveSystemsFromExperiencesWithResponse_Call) Return(_a0 *api.RemoveSystemsFromExperiencesResponse, _a1 error) *ClientWithResponsesInterface_RemoveSystemsFromExperiencesWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_RemoveSystemsFromExperiencesWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, api.MutateSystemsToExperienceInput, ...api.RequestEditorFn) (*api.RemoveSystemsFromExperiencesResponse, error)) *ClientWithResponsesInterface_RemoveSystemsFromExperiencesWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// RerunBatchWithBodyWithResponse provides a mock function with given fields: ctx, projectID, batchID, contentType, body, reqEditors
func (_m *ClientWithResponsesInterface) RerunBatchWithBodyWithResponse(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn) (*api.RerunBatchResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, batchID, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RerunBatchWithBodyWithResponse")
	}

	var r0 *api.RerunBatchResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*api.RerunBatchResponse, error)); ok {
		return rf(ctx, projectID, batchID, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) *api.RerunBatchResponse); ok {
		r0 = rf(ctx, projectID, batchID, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.RerunBatchResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, batchID, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_RerunBatchWithBodyWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RerunBatchWithBodyWithResponse'
type ClientWithResponsesInterface_RerunBatchWithBodyWithResponse_Call struct {
	*mock.Call
}

// RerunBatchWithBodyWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - batchID uuid.UUID
//   - contentType string
//   - body io.Reader
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) RerunBatchWithBodyWithResponse(ctx interface{}, projectID interface{}, batchID interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_RerunBatchWithBodyWithResponse_Call {
	return &ClientWithResponsesInterface_RerunBatchWithBodyWithResponse_Call{Call: _e.mock.On("RerunBatchWithBodyWithResponse",
		append([]interface{}{ctx, projectID, batchID, contentType, body}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_RerunBatchWithBodyWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_RerunBatchWithBodyWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(string), args[4].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_RerunBatchWithBodyWithResponse_Call) Return(_a0 *api.RerunBatchResponse, _a1 error) *ClientWithResponsesInterface_RerunBatchWithBodyWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_RerunBatchWithBodyWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*api.RerunBatchResponse, error)) *ClientWithResponsesInterface_RerunBatchWithBodyWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// RerunBatchWithResponse provides a mock function with given fields: ctx, projectID, batchID, body, reqEditors
func (_m *ClientWithResponsesInterface) RerunBatchWithResponse(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, body api.RerunBatchInput, reqEditors ...api.RequestEditorFn) (*api.RerunBatchResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, batchID, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RerunBatchWithResponse")
	}

	var r0 *api.RerunBatchResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, api.RerunBatchInput, ...api.RequestEditorFn) (*api.RerunBatchResponse, error)); ok {
		return rf(ctx, projectID, batchID, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, api.RerunBatchInput, ...api.RequestEditorFn) *api.RerunBatchResponse); ok {
		r0 = rf(ctx, projectID, batchID, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.RerunBatchResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, api.RerunBatchInput, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, batchID, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_RerunBatchWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RerunBatchWithResponse'
type ClientWithResponsesInterface_RerunBatchWithResponse_Call struct {
	*mock.Call
}

// RerunBatchWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - batchID uuid.UUID
//   - body api.RerunBatchInput
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) RerunBatchWithResponse(ctx interface{}, projectID interface{}, batchID interface{}, body interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_RerunBatchWithResponse_Call {
	return &ClientWithResponsesInterface_RerunBatchWithResponse_Call{Call: _e.mock.On("RerunBatchWithResponse",
		append([]interface{}{ctx, projectID, batchID, body}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_RerunBatchWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, body api.RerunBatchInput, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_RerunBatchWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(api.RerunBatchInput), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_RerunBatchWithResponse_Call) Return(_a0 *api.RerunBatchResponse, _a1 error) *ClientWithResponsesInterface_RerunBatchWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_RerunBatchWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, api.RerunBatchInput, ...api.RequestEditorFn) (*api.RerunBatchResponse, error)) *ClientWithResponsesInterface_RerunBatchWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// RestoreExperienceWithResponse provides a mock function with given fields: ctx, projectID, experienceID, reqEditors
func (_m *ClientWithResponsesInterface) RestoreExperienceWithResponse(ctx context.Context, projectID uuid.UUID, experienceID uuid.UUID, reqEditors ...api.RequestEditorFn) (*api.RestoreExperienceResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, experienceID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RestoreExperienceWithResponse")
	}

	var r0 *api.RestoreExperienceResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*api.RestoreExperienceResponse, error)); ok {
		return rf(ctx, projectID, experienceID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) *api.RestoreExperienceResponse); ok {
		r0 = rf(ctx, projectID, experienceID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.RestoreExperienceResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, experienceID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_RestoreExperienceWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RestoreExperienceWithResponse'
type ClientWithResponsesInterface_RestoreExperienceWithResponse_Call struct {
	*mock.Call
}

// RestoreExperienceWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - experienceID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) RestoreExperienceWithResponse(ctx interface{}, projectID interface{}, experienceID interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_RestoreExperienceWithResponse_Call {
	return &ClientWithResponsesInterface_RestoreExperienceWithResponse_Call{Call: _e.mock.On("RestoreExperienceWithResponse",
		append([]interface{}{ctx, projectID, experienceID}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_RestoreExperienceWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, experienceID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_RestoreExperienceWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_RestoreExperienceWithResponse_Call) Return(_a0 *api.RestoreExperienceResponse, _a1 error) *ClientWithResponsesInterface_RestoreExperienceWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_RestoreExperienceWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*api.RestoreExperienceResponse, error)) *ClientWithResponsesInterface_RestoreExperienceWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// RestoreTestSuiteWithResponse provides a mock function with given fields: ctx, projectID, testSuiteID, reqEditors
func (_m *ClientWithResponsesInterface) RestoreTestSuiteWithResponse(ctx context.Context, projectID uuid.UUID, testSuiteID uuid.UUID, reqEditors ...api.RequestEditorFn) (*api.RestoreTestSuiteResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, testSuiteID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RestoreTestSuiteWithResponse")
	}

	var r0 *api.RestoreTestSuiteResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*api.RestoreTestSuiteResponse, error)); ok {
		return rf(ctx, projectID, testSuiteID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) *api.RestoreTestSuiteResponse); ok {
		r0 = rf(ctx, projectID, testSuiteID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.RestoreTestSuiteResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, testSuiteID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_RestoreTestSuiteWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RestoreTestSuiteWithResponse'
type ClientWithResponsesInterface_RestoreTestSuiteWithResponse_Call struct {
	*mock.Call
}

// RestoreTestSuiteWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - testSuiteID uuid.UUID
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) RestoreTestSuiteWithResponse(ctx interface{}, projectID interface{}, testSuiteID interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_RestoreTestSuiteWithResponse_Call {
	return &ClientWithResponsesInterface_RestoreTestSuiteWithResponse_Call{Call: _e.mock.On("RestoreTestSuiteWithResponse",
		append([]interface{}{ctx, projectID, testSuiteID}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_RestoreTestSuiteWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, testSuiteID uuid.UUID, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_RestoreTestSuiteWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_RestoreTestSuiteWithResponse_Call) Return(_a0 *api.RestoreTestSuiteResponse, _a1 error) *ClientWithResponsesInterface_RestoreTestSuiteWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_RestoreTestSuiteWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, ...api.RequestEditorFn) (*api.RestoreTestSuiteResponse, error)) *ClientWithResponsesInterface_RestoreTestSuiteWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// ReviseTestSuiteWithBodyWithResponse provides a mock function with given fields: ctx, projectID, testSuiteID, contentType, body, reqEditors
func (_m *ClientWithResponsesInterface) ReviseTestSuiteWithBodyWithResponse(ctx context.Context, projectID uuid.UUID, testSuiteID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn) (*api.ReviseTestSuiteResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, testSuiteID, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ReviseTestSuiteWithBodyWithResponse")
	}

	var r0 *api.ReviseTestSuiteResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*api.ReviseTestSuiteResponse, error)); ok {
		return rf(ctx, projectID, testSuiteID, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) *api.ReviseTestSuiteResponse); ok {
		r0 = rf(ctx, projectID, testSuiteID, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ReviseTestSuiteResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, testSuiteID, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_ReviseTestSuiteWithBodyWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReviseTestSuiteWithBodyWithResponse'
type ClientWithResponsesInterface_ReviseTestSuiteWithBodyWithResponse_Call struct {
	*mock.Call
}

// ReviseTestSuiteWithBodyWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - testSuiteID uuid.UUID
//   - contentType string
//   - body io.Reader
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) ReviseTestSuiteWithBodyWithResponse(ctx interface{}, projectID interface{}, testSuiteID interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_ReviseTestSuiteWithBodyWithResponse_Call {
	return &ClientWithResponsesInterface_ReviseTestSuiteWithBodyWithResponse_Call{Call: _e.mock.On("ReviseTestSuiteWithBodyWithResponse",
		append([]interface{}{ctx, projectID, testSuiteID, contentType, body}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_ReviseTestSuiteWithBodyWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, testSuiteID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_ReviseTestSuiteWithBodyWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(string), args[4].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_ReviseTestSuiteWithBodyWithResponse_Call) Return(_a0 *api.ReviseTestSuiteResponse, _a1 error) *ClientWithResponsesInterface_ReviseTestSuiteWithBodyWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_ReviseTestSuiteWithBodyWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*api.ReviseTestSuiteResponse, error)) *ClientWithResponsesInterface_ReviseTestSuiteWithBodyWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// ReviseTestSuiteWithResponse provides a mock function with given fields: ctx, projectID, testSuiteID, body, reqEditors
func (_m *ClientWithResponsesInterface) ReviseTestSuiteWithResponse(ctx context.Context, projectID uuid.UUID, testSuiteID uuid.UUID, body api.ReviseTestSuiteInput, reqEditors ...api.RequestEditorFn) (*api.ReviseTestSuiteResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, testSuiteID, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ReviseTestSuiteWithResponse")
	}

	var r0 *api.ReviseTestSuiteResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, api.ReviseTestSuiteInput, ...api.RequestEditorFn) (*api.ReviseTestSuiteResponse, error)); ok {
		return rf(ctx, projectID, testSuiteID, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, api.ReviseTestSuiteInput, ...api.RequestEditorFn) *api.ReviseTestSuiteResponse); ok {
		r0 = rf(ctx, projectID, testSuiteID, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ReviseTestSuiteResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, api.ReviseTestSuiteInput, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, testSuiteID, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_ReviseTestSuiteWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReviseTestSuiteWithResponse'
type ClientWithResponsesInterface_ReviseTestSuiteWithResponse_Call struct {
	*mock.Call
}

// ReviseTestSuiteWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - testSuiteID uuid.UUID
//   - body api.ReviseTestSuiteInput
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) ReviseTestSuiteWithResponse(ctx interface{}, projectID interface{}, testSuiteID interface{}, body interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_ReviseTestSuiteWithResponse_Call {
	return &ClientWithResponsesInterface_ReviseTestSuiteWithResponse_Call{Call: _e.mock.On("ReviseTestSuiteWithResponse",
		append([]interface{}{ctx, projectID, testSuiteID, body}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_ReviseTestSuiteWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, testSuiteID uuid.UUID, body api.ReviseTestSuiteInput, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_ReviseTestSuiteWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(api.ReviseTestSuiteInput), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_ReviseTestSuiteWithResponse_Call) Return(_a0 *api.ReviseTestSuiteResponse, _a1 error) *ClientWithResponsesInterface_ReviseTestSuiteWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_ReviseTestSuiteWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, api.ReviseTestSuiteInput, ...api.RequestEditorFn) (*api.ReviseTestSuiteResponse, error)) *ClientWithResponsesInterface_ReviseTestSuiteWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateBatchWithBodyWithResponse provides a mock function with given fields: ctx, projectID, batchID, contentType, body, reqEditors
func (_m *ClientWithResponsesInterface) UpdateBatchWithBodyWithResponse(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn) (*api.UpdateBatchResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, batchID, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateBatchWithBodyWithResponse")
	}

	var r0 *api.UpdateBatchResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*api.UpdateBatchResponse, error)); ok {
		return rf(ctx, projectID, batchID, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) *api.UpdateBatchResponse); ok {
		r0 = rf(ctx, projectID, batchID, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.UpdateBatchResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, batchID, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_UpdateBatchWithBodyWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateBatchWithBodyWithResponse'
type ClientWithResponsesInterface_UpdateBatchWithBodyWithResponse_Call struct {
	*mock.Call
}

// UpdateBatchWithBodyWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - batchID uuid.UUID
//   - contentType string
//   - body io.Reader
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) UpdateBatchWithBodyWithResponse(ctx interface{}, projectID interface{}, batchID interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_UpdateBatchWithBodyWithResponse_Call {
	return &ClientWithResponsesInterface_UpdateBatchWithBodyWithResponse_Call{Call: _e.mock.On("UpdateBatchWithBodyWithResponse",
		append([]interface{}{ctx, projectID, batchID, contentType, body}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_UpdateBatchWithBodyWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_UpdateBatchWithBodyWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(string), args[4].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_UpdateBatchWithBodyWithResponse_Call) Return(_a0 *api.UpdateBatchResponse, _a1 error) *ClientWithResponsesInterface_UpdateBatchWithBodyWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_UpdateBatchWithBodyWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*api.UpdateBatchResponse, error)) *ClientWithResponsesInterface_UpdateBatchWithBodyWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateBatchWithResponse provides a mock function with given fields: ctx, projectID, batchID, body, reqEditors
func (_m *ClientWithResponsesInterface) UpdateBatchWithResponse(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, body api.UpdateBatchInput, reqEditors ...api.RequestEditorFn) (*api.UpdateBatchResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, batchID, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateBatchWithResponse")
	}

	var r0 *api.UpdateBatchResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, api.UpdateBatchInput, ...api.RequestEditorFn) (*api.UpdateBatchResponse, error)); ok {
		return rf(ctx, projectID, batchID, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, api.UpdateBatchInput, ...api.RequestEditorFn) *api.UpdateBatchResponse); ok {
		r0 = rf(ctx, projectID, batchID, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.UpdateBatchResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, api.UpdateBatchInput, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, batchID, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_UpdateBatchWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateBatchWithResponse'
type ClientWithResponsesInterface_UpdateBatchWithResponse_Call struct {
	*mock.Call
}

// UpdateBatchWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - batchID uuid.UUID
//   - body api.UpdateBatchInput
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) UpdateBatchWithResponse(ctx interface{}, projectID interface{}, batchID interface{}, body interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_UpdateBatchWithResponse_Call {
	return &ClientWithResponsesInterface_UpdateBatchWithResponse_Call{Call: _e.mock.On("UpdateBatchWithResponse",
		append([]interface{}{ctx, projectID, batchID, body}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_UpdateBatchWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, body api.UpdateBatchInput, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_UpdateBatchWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(api.UpdateBatchInput), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_UpdateBatchWithResponse_Call) Return(_a0 *api.UpdateBatchResponse, _a1 error) *ClientWithResponsesInterface_UpdateBatchWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_UpdateBatchWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, api.UpdateBatchInput, ...api.RequestEditorFn) (*api.UpdateBatchResponse, error)) *ClientWithResponsesInterface_UpdateBatchWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateBuildWithBodyWithResponse provides a mock function with given fields: ctx, projectID, buildID, contentType, body, reqEditors
func (_m *ClientWithResponsesInterface) UpdateBuildWithBodyWithResponse(ctx context.Context, projectID uuid.UUID, buildID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn) (*api.UpdateBuildResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, buildID, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateBuildWithBodyWithResponse")
	}

	var r0 *api.UpdateBuildResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*api.UpdateBuildResponse, error)); ok {
		return rf(ctx, projectID, buildID, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) *api.UpdateBuildResponse); ok {
		r0 = rf(ctx, projectID, buildID, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.UpdateBuildResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, buildID, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_UpdateBuildWithBodyWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateBuildWithBodyWithResponse'
type ClientWithResponsesInterface_UpdateBuildWithBodyWithResponse_Call struct {
	*mock.Call
}

// UpdateBuildWithBodyWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - buildID uuid.UUID
//   - contentType string
//   - body io.Reader
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) UpdateBuildWithBodyWithResponse(ctx interface{}, projectID interface{}, buildID interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_UpdateBuildWithBodyWithResponse_Call {
	return &ClientWithResponsesInterface_UpdateBuildWithBodyWithResponse_Call{Call: _e.mock.On("UpdateBuildWithBodyWithResponse",
		append([]interface{}{ctx, projectID, buildID, contentType, body}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_UpdateBuildWithBodyWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, buildID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_UpdateBuildWithBodyWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(string), args[4].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_UpdateBuildWithBodyWithResponse_Call) Return(_a0 *api.UpdateBuildResponse, _a1 error) *ClientWithResponsesInterface_UpdateBuildWithBodyWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_UpdateBuildWithBodyWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*api.UpdateBuildResponse, error)) *ClientWithResponsesInterface_UpdateBuildWithBodyWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateBuildWithResponse provides a mock function with given fields: ctx, projectID, buildID, body, reqEditors
func (_m *ClientWithResponsesInterface) UpdateBuildWithResponse(ctx context.Context, projectID uuid.UUID, buildID uuid.UUID, body api.UpdateBuildInput, reqEditors ...api.RequestEditorFn) (*api.UpdateBuildResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, buildID, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateBuildWithResponse")
	}

	var r0 *api.UpdateBuildResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, api.UpdateBuildInput, ...api.RequestEditorFn) (*api.UpdateBuildResponse, error)); ok {
		return rf(ctx, projectID, buildID, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, api.UpdateBuildInput, ...api.RequestEditorFn) *api.UpdateBuildResponse); ok {
		r0 = rf(ctx, projectID, buildID, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.UpdateBuildResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, api.UpdateBuildInput, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, buildID, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_UpdateBuildWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateBuildWithResponse'
type ClientWithResponsesInterface_UpdateBuildWithResponse_Call struct {
	*mock.Call
}

// UpdateBuildWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - buildID uuid.UUID
//   - body api.UpdateBuildInput
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) UpdateBuildWithResponse(ctx interface{}, projectID interface{}, buildID interface{}, body interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_UpdateBuildWithResponse_Call {
	return &ClientWithResponsesInterface_UpdateBuildWithResponse_Call{Call: _e.mock.On("UpdateBuildWithResponse",
		append([]interface{}{ctx, projectID, buildID, body}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_UpdateBuildWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, buildID uuid.UUID, body api.UpdateBuildInput, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_UpdateBuildWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(api.UpdateBuildInput), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_UpdateBuildWithResponse_Call) Return(_a0 *api.UpdateBuildResponse, _a1 error) *ClientWithResponsesInterface_UpdateBuildWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_UpdateBuildWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, api.UpdateBuildInput, ...api.RequestEditorFn) (*api.UpdateBuildResponse, error)) *ClientWithResponsesInterface_UpdateBuildWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateEventWithBodyWithResponse provides a mock function with given fields: ctx, projectID, batchID, jobID, eventID, contentType, body, reqEditors
func (_m *ClientWithResponsesInterface) UpdateEventWithBodyWithResponse(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, jobID uuid.UUID, eventID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn) (*api.UpdateEventResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, batchID, jobID, eventID, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateEventWithBodyWithResponse")
	}

	var r0 *api.UpdateEventResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*api.UpdateEventResponse, error)); ok {
		return rf(ctx, projectID, batchID, jobID, eventID, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) *api.UpdateEventResponse); ok {
		r0 = rf(ctx, projectID, batchID, jobID, eventID, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.UpdateEventResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, batchID, jobID, eventID, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_UpdateEventWithBodyWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateEventWithBodyWithResponse'
type ClientWithResponsesInterface_UpdateEventWithBodyWithResponse_Call struct {
	*mock.Call
}

// UpdateEventWithBodyWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - batchID uuid.UUID
//   - jobID uuid.UUID
//   - eventID uuid.UUID
//   - contentType string
//   - body io.Reader
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) UpdateEventWithBodyWithResponse(ctx interface{}, projectID interface{}, batchID interface{}, jobID interface{}, eventID interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_UpdateEventWithBodyWithResponse_Call {
	return &ClientWithResponsesInterface_UpdateEventWithBodyWithResponse_Call{Call: _e.mock.On("UpdateEventWithBodyWithResponse",
		append([]interface{}{ctx, projectID, batchID, jobID, eventID, contentType, body}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_UpdateEventWithBodyWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, jobID uuid.UUID, eventID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_UpdateEventWithBodyWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-7)
		for i, a := range args[7:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(uuid.UUID), args[4].(uuid.UUID), args[5].(string), args[6].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_UpdateEventWithBodyWithResponse_Call) Return(_a0 *api.UpdateEventResponse, _a1 error) *ClientWithResponsesInterface_UpdateEventWithBodyWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_UpdateEventWithBodyWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*api.UpdateEventResponse, error)) *ClientWithResponsesInterface_UpdateEventWithBodyWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateEventWithResponse provides a mock function with given fields: ctx, projectID, batchID, jobID, eventID, body, reqEditors
func (_m *ClientWithResponsesInterface) UpdateEventWithResponse(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, jobID uuid.UUID, eventID uuid.UUID, body api.UpdateEventInput, reqEditors ...api.RequestEditorFn) (*api.UpdateEventResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, batchID, jobID, eventID, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateEventWithResponse")
	}

	var r0 *api.UpdateEventResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, uuid.UUID, api.UpdateEventInput, ...api.RequestEditorFn) (*api.UpdateEventResponse, error)); ok {
		return rf(ctx, projectID, batchID, jobID, eventID, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, uuid.UUID, api.UpdateEventInput, ...api.RequestEditorFn) *api.UpdateEventResponse); ok {
		r0 = rf(ctx, projectID, batchID, jobID, eventID, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.UpdateEventResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, uuid.UUID, api.UpdateEventInput, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, batchID, jobID, eventID, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_UpdateEventWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateEventWithResponse'
type ClientWithResponsesInterface_UpdateEventWithResponse_Call struct {
	*mock.Call
}

// UpdateEventWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - batchID uuid.UUID
//   - jobID uuid.UUID
//   - eventID uuid.UUID
//   - body api.UpdateEventInput
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) UpdateEventWithResponse(ctx interface{}, projectID interface{}, batchID interface{}, jobID interface{}, eventID interface{}, body interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_UpdateEventWithResponse_Call {
	return &ClientWithResponsesInterface_UpdateEventWithResponse_Call{Call: _e.mock.On("UpdateEventWithResponse",
		append([]interface{}{ctx, projectID, batchID, jobID, eventID, body}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_UpdateEventWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, jobID uuid.UUID, eventID uuid.UUID, body api.UpdateEventInput, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_UpdateEventWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-6)
		for i, a := range args[6:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(uuid.UUID), args[4].(uuid.UUID), args[5].(api.UpdateEventInput), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_UpdateEventWithResponse_Call) Return(_a0 *api.UpdateEventResponse, _a1 error) *ClientWithResponsesInterface_UpdateEventWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_UpdateEventWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, uuid.UUID, api.UpdateEventInput, ...api.RequestEditorFn) (*api.UpdateEventResponse, error)) *ClientWithResponsesInterface_UpdateEventWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateExperienceTagWithBodyWithResponse provides a mock function with given fields: ctx, projectID, experienceTagID, contentType, body, reqEditors
func (_m *ClientWithResponsesInterface) UpdateExperienceTagWithBodyWithResponse(ctx context.Context, projectID uuid.UUID, experienceTagID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn) (*api.UpdateExperienceTagResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, experienceTagID, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateExperienceTagWithBodyWithResponse")
	}

	var r0 *api.UpdateExperienceTagResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*api.UpdateExperienceTagResponse, error)); ok {
		return rf(ctx, projectID, experienceTagID, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) *api.UpdateExperienceTagResponse); ok {
		r0 = rf(ctx, projectID, experienceTagID, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.UpdateExperienceTagResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, experienceTagID, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_UpdateExperienceTagWithBodyWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateExperienceTagWithBodyWithResponse'
type ClientWithResponsesInterface_UpdateExperienceTagWithBodyWithResponse_Call struct {
	*mock.Call
}

// UpdateExperienceTagWithBodyWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - experienceTagID uuid.UUID
//   - contentType string
//   - body io.Reader
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) UpdateExperienceTagWithBodyWithResponse(ctx interface{}, projectID interface{}, experienceTagID interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_UpdateExperienceTagWithBodyWithResponse_Call {
	return &ClientWithResponsesInterface_UpdateExperienceTagWithBodyWithResponse_Call{Call: _e.mock.On("UpdateExperienceTagWithBodyWithResponse",
		append([]interface{}{ctx, projectID, experienceTagID, contentType, body}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_UpdateExperienceTagWithBodyWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, experienceTagID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_UpdateExperienceTagWithBodyWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(string), args[4].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_UpdateExperienceTagWithBodyWithResponse_Call) Return(_a0 *api.UpdateExperienceTagResponse, _a1 error) *ClientWithResponsesInterface_UpdateExperienceTagWithBodyWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_UpdateExperienceTagWithBodyWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*api.UpdateExperienceTagResponse, error)) *ClientWithResponsesInterface_UpdateExperienceTagWithBodyWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateExperienceTagWithResponse provides a mock function with given fields: ctx, projectID, experienceTagID, body, reqEditors
func (_m *ClientWithResponsesInterface) UpdateExperienceTagWithResponse(ctx context.Context, projectID uuid.UUID, experienceTagID uuid.UUID, body api.UpdateExperienceTagInput, reqEditors ...api.RequestEditorFn) (*api.UpdateExperienceTagResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, experienceTagID, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateExperienceTagWithResponse")
	}

	var r0 *api.UpdateExperienceTagResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, api.UpdateExperienceTagInput, ...api.RequestEditorFn) (*api.UpdateExperienceTagResponse, error)); ok {
		return rf(ctx, projectID, experienceTagID, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, api.UpdateExperienceTagInput, ...api.RequestEditorFn) *api.UpdateExperienceTagResponse); ok {
		r0 = rf(ctx, projectID, experienceTagID, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.UpdateExperienceTagResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, api.UpdateExperienceTagInput, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, experienceTagID, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_UpdateExperienceTagWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateExperienceTagWithResponse'
type ClientWithResponsesInterface_UpdateExperienceTagWithResponse_Call struct {
	*mock.Call
}

// UpdateExperienceTagWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - experienceTagID uuid.UUID
//   - body api.UpdateExperienceTagInput
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) UpdateExperienceTagWithResponse(ctx interface{}, projectID interface{}, experienceTagID interface{}, body interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_UpdateExperienceTagWithResponse_Call {
	return &ClientWithResponsesInterface_UpdateExperienceTagWithResponse_Call{Call: _e.mock.On("UpdateExperienceTagWithResponse",
		append([]interface{}{ctx, projectID, experienceTagID, body}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_UpdateExperienceTagWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, experienceTagID uuid.UUID, body api.UpdateExperienceTagInput, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_UpdateExperienceTagWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(api.UpdateExperienceTagInput), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_UpdateExperienceTagWithResponse_Call) Return(_a0 *api.UpdateExperienceTagResponse, _a1 error) *ClientWithResponsesInterface_UpdateExperienceTagWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_UpdateExperienceTagWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, api.UpdateExperienceTagInput, ...api.RequestEditorFn) (*api.UpdateExperienceTagResponse, error)) *ClientWithResponsesInterface_UpdateExperienceTagWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateExperienceWithBodyWithResponse provides a mock function with given fields: ctx, projectID, experienceID, contentType, body, reqEditors
func (_m *ClientWithResponsesInterface) UpdateExperienceWithBodyWithResponse(ctx context.Context, projectID uuid.UUID, experienceID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn) (*api.UpdateExperienceResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, experienceID, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateExperienceWithBodyWithResponse")
	}

	var r0 *api.UpdateExperienceResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*api.UpdateExperienceResponse, error)); ok {
		return rf(ctx, projectID, experienceID, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) *api.UpdateExperienceResponse); ok {
		r0 = rf(ctx, projectID, experienceID, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.UpdateExperienceResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, experienceID, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_UpdateExperienceWithBodyWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateExperienceWithBodyWithResponse'
type ClientWithResponsesInterface_UpdateExperienceWithBodyWithResponse_Call struct {
	*mock.Call
}

// UpdateExperienceWithBodyWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - experienceID uuid.UUID
//   - contentType string
//   - body io.Reader
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) UpdateExperienceWithBodyWithResponse(ctx interface{}, projectID interface{}, experienceID interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_UpdateExperienceWithBodyWithResponse_Call {
	return &ClientWithResponsesInterface_UpdateExperienceWithBodyWithResponse_Call{Call: _e.mock.On("UpdateExperienceWithBodyWithResponse",
		append([]interface{}{ctx, projectID, experienceID, contentType, body}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_UpdateExperienceWithBodyWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, experienceID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_UpdateExperienceWithBodyWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(string), args[4].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_UpdateExperienceWithBodyWithResponse_Call) Return(_a0 *api.UpdateExperienceResponse, _a1 error) *ClientWithResponsesInterface_UpdateExperienceWithBodyWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_UpdateExperienceWithBodyWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*api.UpdateExperienceResponse, error)) *ClientWithResponsesInterface_UpdateExperienceWithBodyWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateExperienceWithResponse provides a mock function with given fields: ctx, projectID, experienceID, body, reqEditors
func (_m *ClientWithResponsesInterface) UpdateExperienceWithResponse(ctx context.Context, projectID uuid.UUID, experienceID uuid.UUID, body api.UpdateExperienceInput, reqEditors ...api.RequestEditorFn) (*api.UpdateExperienceResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, experienceID, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateExperienceWithResponse")
	}

	var r0 *api.UpdateExperienceResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, api.UpdateExperienceInput, ...api.RequestEditorFn) (*api.UpdateExperienceResponse, error)); ok {
		return rf(ctx, projectID, experienceID, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, api.UpdateExperienceInput, ...api.RequestEditorFn) *api.UpdateExperienceResponse); ok {
		r0 = rf(ctx, projectID, experienceID, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.UpdateExperienceResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, api.UpdateExperienceInput, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, experienceID, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_UpdateExperienceWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateExperienceWithResponse'
type ClientWithResponsesInterface_UpdateExperienceWithResponse_Call struct {
	*mock.Call
}

// UpdateExperienceWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - experienceID uuid.UUID
//   - body api.UpdateExperienceInput
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) UpdateExperienceWithResponse(ctx interface{}, projectID interface{}, experienceID interface{}, body interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_UpdateExperienceWithResponse_Call {
	return &ClientWithResponsesInterface_UpdateExperienceWithResponse_Call{Call: _e.mock.On("UpdateExperienceWithResponse",
		append([]interface{}{ctx, projectID, experienceID, body}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_UpdateExperienceWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, experienceID uuid.UUID, body api.UpdateExperienceInput, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_UpdateExperienceWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(api.UpdateExperienceInput), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_UpdateExperienceWithResponse_Call) Return(_a0 *api.UpdateExperienceResponse, _a1 error) *ClientWithResponsesInterface_UpdateExperienceWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_UpdateExperienceWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, api.UpdateExperienceInput, ...api.RequestEditorFn) (*api.UpdateExperienceResponse, error)) *ClientWithResponsesInterface_UpdateExperienceWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateJobWithBodyWithResponse provides a mock function with given fields: ctx, projectID, batchID, jobID, contentType, body, reqEditors
func (_m *ClientWithResponsesInterface) UpdateJobWithBodyWithResponse(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, jobID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn) (*api.UpdateJobResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, batchID, jobID, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateJobWithBodyWithResponse")
	}

	var r0 *api.UpdateJobResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*api.UpdateJobResponse, error)); ok {
		return rf(ctx, projectID, batchID, jobID, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) *api.UpdateJobResponse); ok {
		r0 = rf(ctx, projectID, batchID, jobID, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.UpdateJobResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, batchID, jobID, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_UpdateJobWithBodyWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateJobWithBodyWithResponse'
type ClientWithResponsesInterface_UpdateJobWithBodyWithResponse_Call struct {
	*mock.Call
}

// UpdateJobWithBodyWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - batchID uuid.UUID
//   - jobID uuid.UUID
//   - contentType string
//   - body io.Reader
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) UpdateJobWithBodyWithResponse(ctx interface{}, projectID interface{}, batchID interface{}, jobID interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_UpdateJobWithBodyWithResponse_Call {
	return &ClientWithResponsesInterface_UpdateJobWithBodyWithResponse_Call{Call: _e.mock.On("UpdateJobWithBodyWithResponse",
		append([]interface{}{ctx, projectID, batchID, jobID, contentType, body}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_UpdateJobWithBodyWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, jobID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_UpdateJobWithBodyWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-6)
		for i, a := range args[6:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(uuid.UUID), args[4].(string), args[5].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_UpdateJobWithBodyWithResponse_Call) Return(_a0 *api.UpdateJobResponse, _a1 error) *ClientWithResponsesInterface_UpdateJobWithBodyWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_UpdateJobWithBodyWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*api.UpdateJobResponse, error)) *ClientWithResponsesInterface_UpdateJobWithBodyWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateJobWithResponse provides a mock function with given fields: ctx, projectID, batchID, jobID, body, reqEditors
func (_m *ClientWithResponsesInterface) UpdateJobWithResponse(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, jobID uuid.UUID, body api.UpdateJobInput, reqEditors ...api.RequestEditorFn) (*api.UpdateJobResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, batchID, jobID, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateJobWithResponse")
	}

	var r0 *api.UpdateJobResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, api.UpdateJobInput, ...api.RequestEditorFn) (*api.UpdateJobResponse, error)); ok {
		return rf(ctx, projectID, batchID, jobID, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, api.UpdateJobInput, ...api.RequestEditorFn) *api.UpdateJobResponse); ok {
		r0 = rf(ctx, projectID, batchID, jobID, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.UpdateJobResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, api.UpdateJobInput, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, batchID, jobID, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_UpdateJobWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateJobWithResponse'
type ClientWithResponsesInterface_UpdateJobWithResponse_Call struct {
	*mock.Call
}

// UpdateJobWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - batchID uuid.UUID
//   - jobID uuid.UUID
//   - body api.UpdateJobInput
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) UpdateJobWithResponse(ctx interface{}, projectID interface{}, batchID interface{}, jobID interface{}, body interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_UpdateJobWithResponse_Call {
	return &ClientWithResponsesInterface_UpdateJobWithResponse_Call{Call: _e.mock.On("UpdateJobWithResponse",
		append([]interface{}{ctx, projectID, batchID, jobID, body}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_UpdateJobWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, batchID uuid.UUID, jobID uuid.UUID, body api.UpdateJobInput, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_UpdateJobWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(uuid.UUID), args[4].(api.UpdateJobInput), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_UpdateJobWithResponse_Call) Return(_a0 *api.UpdateJobResponse, _a1 error) *ClientWithResponsesInterface_UpdateJobWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_UpdateJobWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, uuid.UUID, api.UpdateJobInput, ...api.RequestEditorFn) (*api.UpdateJobResponse, error)) *ClientWithResponsesInterface_UpdateJobWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateProjectWithBodyWithResponse provides a mock function with given fields: ctx, projectID, contentType, body, reqEditors
func (_m *ClientWithResponsesInterface) UpdateProjectWithBodyWithResponse(ctx context.Context, projectID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn) (*api.UpdateProjectResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateProjectWithBodyWithResponse")
	}

	var r0 *api.UpdateProjectResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*api.UpdateProjectResponse, error)); ok {
		return rf(ctx, projectID, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) *api.UpdateProjectResponse); ok {
		r0 = rf(ctx, projectID, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.UpdateProjectResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_UpdateProjectWithBodyWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateProjectWithBodyWithResponse'
type ClientWithResponsesInterface_UpdateProjectWithBodyWithResponse_Call struct {
	*mock.Call
}

// UpdateProjectWithBodyWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - contentType string
//   - body io.Reader
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) UpdateProjectWithBodyWithResponse(ctx interface{}, projectID interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_UpdateProjectWithBodyWithResponse_Call {
	return &ClientWithResponsesInterface_UpdateProjectWithBodyWithResponse_Call{Call: _e.mock.On("UpdateProjectWithBodyWithResponse",
		append([]interface{}{ctx, projectID, contentType, body}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_UpdateProjectWithBodyWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_UpdateProjectWithBodyWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(string), args[3].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_UpdateProjectWithBodyWithResponse_Call) Return(_a0 *api.UpdateProjectResponse, _a1 error) *ClientWithResponsesInterface_UpdateProjectWithBodyWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_UpdateProjectWithBodyWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*api.UpdateProjectResponse, error)) *ClientWithResponsesInterface_UpdateProjectWithBodyWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateProjectWithResponse provides a mock function with given fields: ctx, projectID, body, reqEditors
func (_m *ClientWithResponsesInterface) UpdateProjectWithResponse(ctx context.Context, projectID uuid.UUID, body api.UpdateProjectInput, reqEditors ...api.RequestEditorFn) (*api.UpdateProjectResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateProjectWithResponse")
	}

	var r0 *api.UpdateProjectResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, api.UpdateProjectInput, ...api.RequestEditorFn) (*api.UpdateProjectResponse, error)); ok {
		return rf(ctx, projectID, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, api.UpdateProjectInput, ...api.RequestEditorFn) *api.UpdateProjectResponse); ok {
		r0 = rf(ctx, projectID, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.UpdateProjectResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, api.UpdateProjectInput, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_UpdateProjectWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateProjectWithResponse'
type ClientWithResponsesInterface_UpdateProjectWithResponse_Call struct {
	*mock.Call
}

// UpdateProjectWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - body api.UpdateProjectInput
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) UpdateProjectWithResponse(ctx interface{}, projectID interface{}, body interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_UpdateProjectWithResponse_Call {
	return &ClientWithResponsesInterface_UpdateProjectWithResponse_Call{Call: _e.mock.On("UpdateProjectWithResponse",
		append([]interface{}{ctx, projectID, body}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_UpdateProjectWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, body api.UpdateProjectInput, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_UpdateProjectWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(api.UpdateProjectInput), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_UpdateProjectWithResponse_Call) Return(_a0 *api.UpdateProjectResponse, _a1 error) *ClientWithResponsesInterface_UpdateProjectWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_UpdateProjectWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, api.UpdateProjectInput, ...api.RequestEditorFn) (*api.UpdateProjectResponse, error)) *ClientWithResponsesInterface_UpdateProjectWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateSystemWithBodyWithResponse provides a mock function with given fields: ctx, projectID, systemID, contentType, body, reqEditors
func (_m *ClientWithResponsesInterface) UpdateSystemWithBodyWithResponse(ctx context.Context, projectID uuid.UUID, systemID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn) (*api.UpdateSystemResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, systemID, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateSystemWithBodyWithResponse")
	}

	var r0 *api.UpdateSystemResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*api.UpdateSystemResponse, error)); ok {
		return rf(ctx, projectID, systemID, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) *api.UpdateSystemResponse); ok {
		r0 = rf(ctx, projectID, systemID, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.UpdateSystemResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, systemID, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_UpdateSystemWithBodyWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateSystemWithBodyWithResponse'
type ClientWithResponsesInterface_UpdateSystemWithBodyWithResponse_Call struct {
	*mock.Call
}

// UpdateSystemWithBodyWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - systemID uuid.UUID
//   - contentType string
//   - body io.Reader
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) UpdateSystemWithBodyWithResponse(ctx interface{}, projectID interface{}, systemID interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_UpdateSystemWithBodyWithResponse_Call {
	return &ClientWithResponsesInterface_UpdateSystemWithBodyWithResponse_Call{Call: _e.mock.On("UpdateSystemWithBodyWithResponse",
		append([]interface{}{ctx, projectID, systemID, contentType, body}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_UpdateSystemWithBodyWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, systemID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_UpdateSystemWithBodyWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(string), args[4].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_UpdateSystemWithBodyWithResponse_Call) Return(_a0 *api.UpdateSystemResponse, _a1 error) *ClientWithResponsesInterface_UpdateSystemWithBodyWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_UpdateSystemWithBodyWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*api.UpdateSystemResponse, error)) *ClientWithResponsesInterface_UpdateSystemWithBodyWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateSystemWithResponse provides a mock function with given fields: ctx, projectID, systemID, body, reqEditors
func (_m *ClientWithResponsesInterface) UpdateSystemWithResponse(ctx context.Context, projectID uuid.UUID, systemID uuid.UUID, body api.UpdateSystemInput, reqEditors ...api.RequestEditorFn) (*api.UpdateSystemResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, systemID, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateSystemWithResponse")
	}

	var r0 *api.UpdateSystemResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, api.UpdateSystemInput, ...api.RequestEditorFn) (*api.UpdateSystemResponse, error)); ok {
		return rf(ctx, projectID, systemID, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, api.UpdateSystemInput, ...api.RequestEditorFn) *api.UpdateSystemResponse); ok {
		r0 = rf(ctx, projectID, systemID, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.UpdateSystemResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, api.UpdateSystemInput, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, systemID, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_UpdateSystemWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateSystemWithResponse'
type ClientWithResponsesInterface_UpdateSystemWithResponse_Call struct {
	*mock.Call
}

// UpdateSystemWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - systemID uuid.UUID
//   - body api.UpdateSystemInput
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) UpdateSystemWithResponse(ctx interface{}, projectID interface{}, systemID interface{}, body interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_UpdateSystemWithResponse_Call {
	return &ClientWithResponsesInterface_UpdateSystemWithResponse_Call{Call: _e.mock.On("UpdateSystemWithResponse",
		append([]interface{}{ctx, projectID, systemID, body}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_UpdateSystemWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, systemID uuid.UUID, body api.UpdateSystemInput, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_UpdateSystemWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(api.UpdateSystemInput), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_UpdateSystemWithResponse_Call) Return(_a0 *api.UpdateSystemResponse, _a1 error) *ClientWithResponsesInterface_UpdateSystemWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_UpdateSystemWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, api.UpdateSystemInput, ...api.RequestEditorFn) (*api.UpdateSystemResponse, error)) *ClientWithResponsesInterface_UpdateSystemWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateWorkflowSuitesWithBodyWithResponse provides a mock function with given fields: ctx, projectID, workflowID, contentType, body, reqEditors
func (_m *ClientWithResponsesInterface) UpdateWorkflowSuitesWithBodyWithResponse(ctx context.Context, projectID uuid.UUID, workflowID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn) (*api.UpdateWorkflowSuitesResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, workflowID, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateWorkflowSuitesWithBodyWithResponse")
	}

	var r0 *api.UpdateWorkflowSuitesResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*api.UpdateWorkflowSuitesResponse, error)); ok {
		return rf(ctx, projectID, workflowID, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) *api.UpdateWorkflowSuitesResponse); ok {
		r0 = rf(ctx, projectID, workflowID, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.UpdateWorkflowSuitesResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, workflowID, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_UpdateWorkflowSuitesWithBodyWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateWorkflowSuitesWithBodyWithResponse'
type ClientWithResponsesInterface_UpdateWorkflowSuitesWithBodyWithResponse_Call struct {
	*mock.Call
}

// UpdateWorkflowSuitesWithBodyWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - workflowID uuid.UUID
//   - contentType string
//   - body io.Reader
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) UpdateWorkflowSuitesWithBodyWithResponse(ctx interface{}, projectID interface{}, workflowID interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_UpdateWorkflowSuitesWithBodyWithResponse_Call {
	return &ClientWithResponsesInterface_UpdateWorkflowSuitesWithBodyWithResponse_Call{Call: _e.mock.On("UpdateWorkflowSuitesWithBodyWithResponse",
		append([]interface{}{ctx, projectID, workflowID, contentType, body}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_UpdateWorkflowSuitesWithBodyWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, workflowID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_UpdateWorkflowSuitesWithBodyWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(string), args[4].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_UpdateWorkflowSuitesWithBodyWithResponse_Call) Return(_a0 *api.UpdateWorkflowSuitesResponse, _a1 error) *ClientWithResponsesInterface_UpdateWorkflowSuitesWithBodyWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_UpdateWorkflowSuitesWithBodyWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*api.UpdateWorkflowSuitesResponse, error)) *ClientWithResponsesInterface_UpdateWorkflowSuitesWithBodyWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateWorkflowSuitesWithResponse provides a mock function with given fields: ctx, projectID, workflowID, body, reqEditors
func (_m *ClientWithResponsesInterface) UpdateWorkflowSuitesWithResponse(ctx context.Context, projectID uuid.UUID, workflowID uuid.UUID, body api.UpdateWorkflowSuitesInput, reqEditors ...api.RequestEditorFn) (*api.UpdateWorkflowSuitesResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, workflowID, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateWorkflowSuitesWithResponse")
	}

	var r0 *api.UpdateWorkflowSuitesResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, api.UpdateWorkflowSuitesInput, ...api.RequestEditorFn) (*api.UpdateWorkflowSuitesResponse, error)); ok {
		return rf(ctx, projectID, workflowID, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, api.UpdateWorkflowSuitesInput, ...api.RequestEditorFn) *api.UpdateWorkflowSuitesResponse); ok {
		r0 = rf(ctx, projectID, workflowID, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.UpdateWorkflowSuitesResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, api.UpdateWorkflowSuitesInput, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, workflowID, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_UpdateWorkflowSuitesWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateWorkflowSuitesWithResponse'
type ClientWithResponsesInterface_UpdateWorkflowSuitesWithResponse_Call struct {
	*mock.Call
}

// UpdateWorkflowSuitesWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - workflowID uuid.UUID
//   - body api.UpdateWorkflowSuitesInput
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) UpdateWorkflowSuitesWithResponse(ctx interface{}, projectID interface{}, workflowID interface{}, body interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_UpdateWorkflowSuitesWithResponse_Call {
	return &ClientWithResponsesInterface_UpdateWorkflowSuitesWithResponse_Call{Call: _e.mock.On("UpdateWorkflowSuitesWithResponse",
		append([]interface{}{ctx, projectID, workflowID, body}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_UpdateWorkflowSuitesWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, workflowID uuid.UUID, body api.UpdateWorkflowSuitesInput, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_UpdateWorkflowSuitesWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(api.UpdateWorkflowSuitesInput), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_UpdateWorkflowSuitesWithResponse_Call) Return(_a0 *api.UpdateWorkflowSuitesResponse, _a1 error) *ClientWithResponsesInterface_UpdateWorkflowSuitesWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_UpdateWorkflowSuitesWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, api.UpdateWorkflowSuitesInput, ...api.RequestEditorFn) (*api.UpdateWorkflowSuitesResponse, error)) *ClientWithResponsesInterface_UpdateWorkflowSuitesWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateWorkflowWithBodyWithResponse provides a mock function with given fields: ctx, projectID, workflowID, contentType, body, reqEditors
func (_m *ClientWithResponsesInterface) UpdateWorkflowWithBodyWithResponse(ctx context.Context, projectID uuid.UUID, workflowID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn) (*api.UpdateWorkflowResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, workflowID, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateWorkflowWithBodyWithResponse")
	}

	var r0 *api.UpdateWorkflowResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*api.UpdateWorkflowResponse, error)); ok {
		return rf(ctx, projectID, workflowID, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) *api.UpdateWorkflowResponse); ok {
		r0 = rf(ctx, projectID, workflowID, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.UpdateWorkflowResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, workflowID, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_UpdateWorkflowWithBodyWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateWorkflowWithBodyWithResponse'
type ClientWithResponsesInterface_UpdateWorkflowWithBodyWithResponse_Call struct {
	*mock.Call
}

// UpdateWorkflowWithBodyWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - workflowID uuid.UUID
//   - contentType string
//   - body io.Reader
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) UpdateWorkflowWithBodyWithResponse(ctx interface{}, projectID interface{}, workflowID interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_UpdateWorkflowWithBodyWithResponse_Call {
	return &ClientWithResponsesInterface_UpdateWorkflowWithBodyWithResponse_Call{Call: _e.mock.On("UpdateWorkflowWithBodyWithResponse",
		append([]interface{}{ctx, projectID, workflowID, contentType, body}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_UpdateWorkflowWithBodyWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, workflowID uuid.UUID, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_UpdateWorkflowWithBodyWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(string), args[4].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_UpdateWorkflowWithBodyWithResponse_Call) Return(_a0 *api.UpdateWorkflowResponse, _a1 error) *ClientWithResponsesInterface_UpdateWorkflowWithBodyWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_UpdateWorkflowWithBodyWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, string, io.Reader, ...api.RequestEditorFn) (*api.UpdateWorkflowResponse, error)) *ClientWithResponsesInterface_UpdateWorkflowWithBodyWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateWorkflowWithResponse provides a mock function with given fields: ctx, projectID, workflowID, body, reqEditors
func (_m *ClientWithResponsesInterface) UpdateWorkflowWithResponse(ctx context.Context, projectID uuid.UUID, workflowID uuid.UUID, body api.UpdateWorkflowInput, reqEditors ...api.RequestEditorFn) (*api.UpdateWorkflowResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, projectID, workflowID, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateWorkflowWithResponse")
	}

	var r0 *api.UpdateWorkflowResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, api.UpdateWorkflowInput, ...api.RequestEditorFn) (*api.UpdateWorkflowResponse, error)); ok {
		return rf(ctx, projectID, workflowID, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, api.UpdateWorkflowInput, ...api.RequestEditorFn) *api.UpdateWorkflowResponse); ok {
		r0 = rf(ctx, projectID, workflowID, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.UpdateWorkflowResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, api.UpdateWorkflowInput, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, projectID, workflowID, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_UpdateWorkflowWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateWorkflowWithResponse'
type ClientWithResponsesInterface_UpdateWorkflowWithResponse_Call struct {
	*mock.Call
}

// UpdateWorkflowWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uuid.UUID
//   - workflowID uuid.UUID
//   - body api.UpdateWorkflowInput
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) UpdateWorkflowWithResponse(ctx interface{}, projectID interface{}, workflowID interface{}, body interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_UpdateWorkflowWithResponse_Call {
	return &ClientWithResponsesInterface_UpdateWorkflowWithResponse_Call{Call: _e.mock.On("UpdateWorkflowWithResponse",
		append([]interface{}{ctx, projectID, workflowID, body}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_UpdateWorkflowWithResponse_Call) Run(run func(ctx context.Context, projectID uuid.UUID, workflowID uuid.UUID, body api.UpdateWorkflowInput, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_UpdateWorkflowWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(api.UpdateWorkflowInput), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_UpdateWorkflowWithResponse_Call) Return(_a0 *api.UpdateWorkflowResponse, _a1 error) *ClientWithResponsesInterface_UpdateWorkflowWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_UpdateWorkflowWithResponse_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, api.UpdateWorkflowInput, ...api.RequestEditorFn) (*api.UpdateWorkflowResponse, error)) *ClientWithResponsesInterface_UpdateWorkflowWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// ValidateExperienceLocationWithBodyWithResponse provides a mock function with given fields: ctx, contentType, body, reqEditors
func (_m *ClientWithResponsesInterface) ValidateExperienceLocationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn) (*api.ValidateExperienceLocationResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ValidateExperienceLocationWithBodyWithResponse")
	}

	var r0 *api.ValidateExperienceLocationResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, io.Reader, ...api.RequestEditorFn) (*api.ValidateExperienceLocationResponse, error)); ok {
		return rf(ctx, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, io.Reader, ...api.RequestEditorFn) *api.ValidateExperienceLocationResponse); ok {
		r0 = rf(ctx, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ValidateExperienceLocationResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, io.Reader, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_ValidateExperienceLocationWithBodyWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ValidateExperienceLocationWithBodyWithResponse'
type ClientWithResponsesInterface_ValidateExperienceLocationWithBodyWithResponse_Call struct {
	*mock.Call
}

// ValidateExperienceLocationWithBodyWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - contentType string
//   - body io.Reader
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) ValidateExperienceLocationWithBodyWithResponse(ctx interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_ValidateExperienceLocationWithBodyWithResponse_Call {
	return &ClientWithResponsesInterface_ValidateExperienceLocationWithBodyWithResponse_Call{Call: _e.mock.On("ValidateExperienceLocationWithBodyWithResponse",
		append([]interface{}{ctx, contentType, body}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_ValidateExperienceLocationWithBodyWithResponse_Call) Run(run func(ctx context.Context, contentType string, body io.Reader, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_ValidateExperienceLocationWithBodyWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(string), args[2].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_ValidateExperienceLocationWithBodyWithResponse_Call) Return(_a0 *api.ValidateExperienceLocationResponse, _a1 error) *ClientWithResponsesInterface_ValidateExperienceLocationWithBodyWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_ValidateExperienceLocationWithBodyWithResponse_Call) RunAndReturn(run func(context.Context, string, io.Reader, ...api.RequestEditorFn) (*api.ValidateExperienceLocationResponse, error)) *ClientWithResponsesInterface_ValidateExperienceLocationWithBodyWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// ValidateExperienceLocationWithResponse provides a mock function with given fields: ctx, body, reqEditors
func (_m *ClientWithResponsesInterface) ValidateExperienceLocationWithResponse(ctx context.Context, body api.ExperienceLocation, reqEditors ...api.RequestEditorFn) (*api.ValidateExperienceLocationResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ValidateExperienceLocationWithResponse")
	}

	var r0 *api.ValidateExperienceLocationResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, api.ExperienceLocation, ...api.RequestEditorFn) (*api.ValidateExperienceLocationResponse, error)); ok {
		return rf(ctx, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, api.ExperienceLocation, ...api.RequestEditorFn) *api.ValidateExperienceLocationResponse); ok {
		r0 = rf(ctx, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ValidateExperienceLocationResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, api.ExperienceLocation, ...api.RequestEditorFn) error); ok {
		r1 = rf(ctx, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientWithResponsesInterface_ValidateExperienceLocationWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ValidateExperienceLocationWithResponse'
type ClientWithResponsesInterface_ValidateExperienceLocationWithResponse_Call struct {
	*mock.Call
}

// ValidateExperienceLocationWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - body api.ExperienceLocation
//   - reqEditors ...api.RequestEditorFn
func (_e *ClientWithResponsesInterface_Expecter) ValidateExperienceLocationWithResponse(ctx interface{}, body interface{}, reqEditors ...interface{}) *ClientWithResponsesInterface_ValidateExperienceLocationWithResponse_Call {
	return &ClientWithResponsesInterface_ValidateExperienceLocationWithResponse_Call{Call: _e.mock.On("ValidateExperienceLocationWithResponse",
		append([]interface{}{ctx, body}, reqEditors...)...)}
}

func (_c *ClientWithResponsesInterface_ValidateExperienceLocationWithResponse_Call) Run(run func(ctx context.Context, body api.ExperienceLocation, reqEditors ...api.RequestEditorFn)) *ClientWithResponsesInterface_ValidateExperienceLocationWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]api.RequestEditorFn, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(api.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(api.ExperienceLocation), variadicArgs...)
	})
	return _c
}

func (_c *ClientWithResponsesInterface_ValidateExperienceLocationWithResponse_Call) Return(_a0 *api.ValidateExperienceLocationResponse, _a1 error) *ClientWithResponsesInterface_ValidateExperienceLocationWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ClientWithResponsesInterface_ValidateExperienceLocationWithResponse_Call) RunAndReturn(run func(context.Context, api.ExperienceLocation, ...api.RequestEditorFn) (*api.ValidateExperienceLocationResponse, error)) *ClientWithResponsesInterface_ValidateExperienceLocationWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// NewClientWithResponsesInterface creates a new instance of ClientWithResponsesInterface. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewClientWithResponsesInterface(t interface {
	mock.TestingT
	Cleanup(func())
}) *ClientWithResponsesInterface {
	mock := &ClientWithResponsesInterface{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
